// Generated by dts-bundle v0.7.3

declare module '@graspologic/memstore' {
    export * from '@graspologic/memstore/specification';
    export * from '@graspologic/memstore/store';
    export * from '@graspologic/memstore/reader';
}

declare module '@graspologic/memstore/specification' {
    export * from '@graspologic/memstore/specification/AttributeType';
    export * from '@graspologic/memstore/specification/LayoutBuilder';
    export * from '@graspologic/memstore/specification/types';
}

declare module '@graspologic/memstore/store' {
    export * from '@graspologic/memstore/store/types';
    export * from '@graspologic/memstore/store/SlotAllocator';
    export * from '@graspologic/memstore/store/ArrayStore';
    export * from '@graspologic/memstore/store/IdStore';
}

declare module '@graspologic/memstore/reader' {
    export * from '@graspologic/memstore/reader/createReader';
    export * from '@graspologic/memstore/reader/ReaderStore';
    export * from '@graspologic/memstore/reader/types';
    export * from '@graspologic/memstore/reader/MemoryReaderInspector';
}

declare module '@graspologic/memstore/specification/AttributeType' {
    import { AttributeType } from '@graspologic/memstore/specification/types';
    /**
        * @internal
        *
        * A mapping from AttributeType to the number of bytes required to store it
        */
    export const DATA_TYPE_TO_BYTES: Record<AttributeType, number>;
    /**
        * @internal
        *
        * Gets the size in bytes for the given data type
        * @param type The data type to inspect
        */
    export function getAttributeTypeByteSize(type: AttributeType): number;
}

declare module '@graspologic/memstore/specification/LayoutBuilder' {
    import { MemoryLayout, LayoutBuilder } from '@graspologic/memstore/specification/types';
    export const SpacerAttributeName = "__SPACER__";
    /**
        * @internal
        *
        * Creates a LayoutBuilder which can be used to construct a MemoryLayout
        */
    export function createLayoutBuilder(): LayoutBuilder;
    /**
        * Gets the total number of bytes required to represent a single item in memory
        * @param layout The memory layout
        */
    export function getBytesPerItem(layout: MemoryLayout): number;
}

declare module '@graspologic/memstore/specification/types' {
    export enum AttributeType {
            Float32 = 0,
            Uint8 = 1,
            Uint32 = 2
    }
    /**
        * The specification for a single attribute contained in a MemoryLayout
        */
    export interface AttributeSpecification {
            /**
                * The property name to use for this attribute in JavaScript client contexts
                */
            name: string;
            /**
                * The byte offset into the array that this attribute belongs
                */
            offset: number;
            /**
                * The offset of the attribute in the typed array variant (e.g. float32array)
                */
            typedOffset: number;
            /**
                * The number of elements constituting this attribute
                */
            size: number;
            /**
                * The Attribute type
                */
            type: AttributeType;
            /**
                * Whether the attribute is an alias attribute
                */
            alias?: boolean;
            /**
                * Optional type interpretation hint
                */
            hint?: InterpretationHint;
    }
    /**
        * A builder for constructing MemoryLayout instances
        */
    export interface LayoutBuilder {
            /**
                * Adds space in the layout for a uint8 attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addUint8(name: string, options?: AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a uint8[2] attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addUint8Vec2(name: string, options?: Vec2AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a uint8[3] attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addUint8Vec3(name: string, options?: Vec3AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a uint8[4] attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addUint8Vec4(name: string, options?: Vec4AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a float32 attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addFloat32(name: string, options?: AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a float32[2] attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addFloat32Vec2(name: string, options?: Vec2AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a float32[3] attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addFloat32Vec3(name: string, options?: Vec3AttributeOptions): LayoutBuilder;
            /**
                * Adds space in the layout for a uint32 attribute
                * @param name The name of the attribute
                * @param options The options for the attribute
                */
            addUint32(name: string, options?: AttributeOptions): LayoutBuilder;
            /**
                * Builds the final MemoryLayout
                */
            build(): MemoryLayout;
    }
    /**
        * A set of options used for constructing the MemoryLayout for a single attribute
        */
    export interface AttributeOptions {
            /**
                * The set of aliases for the attribute
                */
            aliases?: AttributeAlias[];
            /**
                * The hint used for interpreting the attribute's value
                */
            hint?: InterpretationHint;
    }
    /**
        * Indicates how a value should be interpreted
        */
    export enum InterpretationHint {
            /**
                * Interpret a uint8 value as a boolean
                */
            Boolean = 0
    }
    /**
        * An alias for an attribute
        */
    export interface AttributeAlias {
            /**
                * The alias name
                */
            name: string;
            /**
                * The number of elements for this alias
                */
            size?: number;
            /**
                * The type of attribute
                */
            type: AttributeType;
            /**
                * The hint used for intepreting the alias' value
                */
            hint?: InterpretationHint;
    }
    /**
        * The set of attribute options for a vec2 attribute
        */
    export interface Vec2AttributeOptions extends AttributeOptions {
            /**
                * The individual component names, i.e. x, y
                */
            components?: [string, string];
    }
    /**
        * The set of attribute options for a vec3 attribute
        */
    export interface Vec3AttributeOptions extends AttributeOptions {
            /**
                * The individual component names, i.e. x, y, z
                */
            components?: [string, string, string];
    }
    /**
        * The set of attribute options for a vec4 attribute
        */
    export interface Vec4AttributeOptions extends AttributeOptions {
            /**
                * The individual component names, i.e. x, y, z, w
                */
            components?: [string, string, string, string];
    }
    /**
        * Represents the layout for a single item's attributes in memory
        */
    export type MemoryLayout = Map<AttributeName, AttributeSpecification> & {
            stride: number;
    };
    /**
        * The name of an attribute
        */
    export type AttributeName = string;
}

declare module '@graspologic/memstore/store/types' {
    import { AttributeName } from '@graspologic/memstore/specification';
    /**
        * The configuration for the ArrayStore
        */
    export interface StoreConfig {
            /**
                * The initial capacity of the store
                *
                * @defaultValue 10000
                */
            capacity: number;
            /**
                * If true, a SharedArrayBuffer will be used
                *
                * @defaultValue true
                */
            shared: boolean;
            /**
                * The array buffer to use
                */
            buffer?: ArrayBuffer;
            /**
                * If true, on store creation, it is assumed that the buffer is full of item data
                *
                * @defaultValue false
                */
            allocatedOnCreate?: boolean;
            /**
                * If true, items within the store will support animation
                *
                * @defaultValue true
                */
            animation?: boolean;
    }
    /**
        * A handler for when an attribute has been updated
        * @param index The index of the item
        * @param attribute The name of the attribute that was updated, if undefined, all attributes have been changed
        * @param value The new value of the attribute
        */
    export type AttributeUpdatedHandler = (index: number, attribute?: AttributeName) => void;
    /**
        * A handler for when an item has been remove or added
        * @param index The index of the item
        */
    export type AddRemoveItemHandler = (index: number) => void;
    /**
        * A callback for detaching
        */
    export type Detach = () => void;
}

declare module '@graspologic/memstore/store/SlotAllocator' {
    /**
        * A class for managing id allocation
        */
    export class SlotAllocator {
            /**
                * Constructor for the SlotAllocator
                * @param capacity The number of ids to support
                * @param consumed If true, the allocator is assumed to be full
                * @throws If an invalid capacity is passed to the constructor
                */
            constructor(capacity?: number, consumed?: boolean);
            /**
                * Resets the allocator back to the default state
                * @param capacity The number of items to support
                * @throws If an invalid capacity is passed to the function
                */
            reset(capacity: number): void;
            /**
                * Grow the capacity of the slot allocator by __newCapacity__
                * @param newCapacity The new capacity of the allocator
                * @throws If an invalid capacity is passed to the function
                */
            grow(newCapacity: number): void;
            /**
                * Returns true if there are available ids
                */
            get hasFreeSpace(): boolean;
            /**
                * Frees __index__ for re-use
                * @param index The index to free
                * @throws An error for an invalid index
                */
            free(index: number): void;
            /**
                * Allocates a new index
                *
                * @throws An error if there is no space available
                */
            alloc(): number;
            /**
                * Returns an iterator for the used slots
                */
            used(): Iterable<number>;
            /**
                * Returns true if the given index has been allocated
                * @param index The index to check
                */
            has(index: number): boolean;
            /**
                * Returns the number of used indices
                */
            get usedCount(): number;
            /**
                * Destroy's the allocator
                */
            destroy(): void;
    }
}

declare module '@graspologic/memstore/store/ArrayStore' {
    import { MemoryLayout } from '@graspologic/memstore/specification';
    import { Detach } from '@graspologic/memstore/store/types';
    import { StoreConfig } from '@graspologic/memstore/store';
    /**
        * Interface for buffer-backed array storage. Access to data is limited to primitive size-declared values
        * (e.g. Uint8, Uint32, Float32).
        *
        * Each size-declared type may be also define accessors in Vec2 and Vec3 formats, which indicate that we will
        * allocate 2x or 3x the space of a single value respectively, and interpret the data as a fixed-size array of 2 or 3.
        *
        * Each getter/setter combination should be named in the following way:
        *   (read|write)<type><vec?>(Offset|Attr) - e.g. readUint8Vec2Offset writeFloat32Attr()
        *
        * __Offset__ indicates that we are using the given buffer offset directly without consulting
        * with a memory layout specification. Care should be used when using this option.
        *-
        * __Attr__ indicates that we are referencing a memory layout specification and the item index to
        * determine the correct memory reference.
        */
    export interface ArrayStore {
            /**
                * The store configuration
                */
            readonly config: StoreConfig;
            /**
                * The number of bytes each item consumes
                */
            readonly bytesPerItem: number;
            /**
                * Returns the number of items which should be rendered
                */
            readonly count: number;
            /**
                * The internal memory structure of the store
                */
            readonly layout: MemoryLayout;
            /**
                * Adds a resize handler for when the store resizes
                * @param handler The resize handler
                * @returns A callback for removing the handler
                */
            onResize(handler: () => void): Detach;
            /**
                * Resizes the array store
                * @param newSize The new size the ArrayStore should be
                */
            resize(newSize: number): void;
            /**
                * Returns raw item data for the given item
                * @param idx The index of the item
                * @returns An array buffer containing just the contents of the item in the memory layout of this ArrayStore
                */
            itemData(idx: number): ArrayBuffer;
            /**
                * Slurps data from the source buffer into this buffer
                * @param targetIdx The target index
                * @param sourceBuffer The source arraybuffer
                * @param sourceOffset The offset at which to start copying. Default=0
                */
            slurp(targetIdx: number, sourceBuffer: ArrayBuffer, sourceOffset?: number): void;
            /**
                * Computes the byte offset for the given item
                * @param idx The idx of the byte offset to get
                */
            getByteOffset(idx: number): number;
            /**
                * Gets the byte offset for the given attribute and item
                * @param idx The index of the item
                * @param attribute The attribute to get the byte offset for
                */
            getByteOffsetAttr(idx: number, attribute: string): number;
            /**
                * Destroys this ArrayStore
                */
            destroy(): void;
            /**
                * The backing buffer
                */
            readonly buffer: ArrayBuffer;
            /**
                * @internal
                *
                * Returns a dataview of the underlying buffer
                */
            readonly dataView: DataView;
            /**
                * @internal
                *
                * Returns the Float32Array view of the buffer
                */
            readonly float32Array: Float32Array;
            /**
                * @internal
                *
                * Returns the Uint8Array view of the buffer
                */
            readonly uint8Array: Uint8Array;
            /**
                * @internal
                *
                * Returns the Uint32Array view of the buffer
                */
            readonly uint32Array: Uint32Array;
    }
    /**
        * Implementation of an ArrayStore
        * @see {@link ArrayStore} for more info
        */
    export class ArrayStoreImpl implements ArrayStore {
            readonly layout: MemoryLayout;
            readonly config: StoreConfig;
            readonly bytesPerItem: number;
            /**
                * Constructor for the ItemArrayBuffer
                * @param layout The memory layout
                * @param options The store options
                */
            constructor(layout: MemoryLayout, options?: Partial<StoreConfig>);
            /**
                * @inheritdoc
                * @see {@link ArrayStore.buffer}
                */
            get buffer(): ArrayBuffer;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.dataView}
                */
            get dataView(): DataView;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.float32Array}
                */
            get float32Array(): Float32Array;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.uint8Array}
                */
            get uint8Array(): Uint8Array;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.uint32Array}
                */
            get uint32Array(): Uint32Array;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.onResize}
                */
            onResize(handler: () => void): () => void;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.resize}
                */
            resize(newSize: number): void;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.itemData}
                */
            itemData(idx: number): ArrayBuffer;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.getByteOffset}
                */
            getByteOffset(idx: number): number;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.getByteOffsetAttr}
                */
            getByteOffsetAttr(idx: number, attribute: string): number;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.count}
                */
            get count(): number;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.destroy}
                */
            destroy(): void;
            /**
                * @inheritdoc
                * @see {@link ArrayStore.slurp}
                */
            slurp(targetIdx: number, sourceBuffer: ArrayBuffer, sourceOffset?: number): void;
    }
}

declare module '@graspologic/memstore/store/IdStore' {
    import { AttributeName } from '@graspologic/memstore/specification';
    import { ArrayStore } from '@graspologic/memstore/store/ArrayStore';
    import { SlotAllocator } from '@graspologic/memstore/store/SlotAllocator';
    import { AttributeUpdatedHandler, AddRemoveItemHandler, Detach } from '@graspologic/memstore/store/types';
    /**
        * A store which stores ids
        */
    export interface IdStore {
            /**
                * The backing ArrayStore
                */
            readonly store: ArrayStore;
            /**
                * The count of ids
                */
            readonly count: number;
            /**
                * Returns an iterator for all of the items contained in this store
                */
            itemIds(): Iterable<number>;
            /**
                * Calls __handler__ when an attribute is updated
                * @param handler The attribute updated handler
                */
            onAttributeUpdated(handler: AttributeUpdatedHandler): () => void;
            /**
                * Calls __handler__ when an item has been added
                * @param handler The item added handler
                */
            onAddItem(handler: AddRemoveItemHandler): () => void;
            /**
                * Calls __handler__ when an item has been removed
                * @param handler The item removed handler
                */
            onRemoveItem(handler: AddRemoveItemHandler): () => void;
            /**
                * Adds space a new item
                * @returns The store index of the new item
                */
            add(): number;
            /**
                * Removes the primitive with the given store id
                * @param storeId The store id
                */
            remove(idx: number): void;
            /**
                * Resets the Buffer back to the default state
                */
            reset(): void;
            /**
                * Destroys this store instance
                */
            destroy(): void;
            /**
                * Notifies the PrimitiveStore of an Attribute change externally
                * @param storeId The store id
                * @param attribute The attribute that changed
                */
            notify(storeId: number, attribute: AttributeName): void;
    }
    /**
        * __&commat;internal__
        *
        * An implementation of an IdStore
        */
    export class IdStoreImpl implements IdStore {
            /** a map of available storage slots in the buffer, modeled as alinked list */
            protected slotAllocator: SlotAllocator;
            /** callbacks and handlers */
            protected onUpdateHandlers: AttributeUpdatedHandler[];
            protected onAddHandlers: AddRemoveItemHandler[];
            protected onRemoveHandlers: AddRemoveItemHandler[];
            /**
                * Constructor for the IdStoreImpl
                * @param store The backing ArrayStore
                * @param allocator The allocator for allocating new ids
                */
            constructor(store: ArrayStore, allocator: SlotAllocator);
            /**
                * @inheritdoc
                * @see {@link IdStore.store}
                */
            get store(): ArrayStore;
            /**
                * @inheritdoc
                * @see {@link IdStore.count}
                */
            get count(): number;
            /**
                * @inheritdoc
                * @see {@link IdStore.itemIds}
                */
            itemIds(): Iterable<number>;
            /**
                * @inheritdoc
                * @see {@link IdStore.onAttributeUpdated}
                */
            onAttributeUpdated(handler: AttributeUpdatedHandler): Detach;
            /**
                * @inheritdoc
                * @see {@link IdStore.onAddItem}
                */
            onAddItem(handler: AddRemoveItemHandler): Detach;
            /**
                * @inheritdoc
                * @see {@link IdStore.onRemoveItem}
                */
            onRemoveItem(handler: AddRemoveItemHandler): Detach;
            /**
                * @inheritdoc
                * @see {@link IdStore.add}
                */
            add(events?: boolean): number;
            /**
                * @inheritdoc
                * @see {@link IdStore.remove}
                */
            remove(idx: number, events?: boolean): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.reset}
                */
            reset(): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.destroy}
                */
            destroy(): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.notify}
                */
            notify(id: number, attribute?: AttributeName): void;
            /**
                * Raises the add event
                * @param itemIndex The added item index
                */
            protected fireAddHandlers(itemIndex: number): void;
            /**
                * Raises the add event
                * @param itemIndex The added item index
                */
            protected fireRemoveHandlers(itemIndex: number): void;
    }
}

declare module '@graspologic/memstore/reader/createReader' {
    import { MemoryLayout } from '@graspologic/memstore/specification';
    import { MemoryReaderClass } from '@graspologic/memstore/reader/types';
    /**
        * Describes a property
        */
    export type PropertySpecification = string | {
            name: string;
            initialValue?: any;
            ephemeral?: boolean;
    };
    /**
        * Creates a MemoryReader implementation which can read the given memory layout efficiently
        * @param readerType The type of reader
        * @param layout The memory layout
        * @param additionalProperties The additional properties to add to the implementation
        * @param setterAugmenter The setter augmenter, which can be used to manipulate the underlying generated property setters
        */
    export function createReader<P>(readerType: symbol, layout: MemoryLayout, additionalProperties?: PropertySpecification[]): MemoryReaderClass<P>;
}

declare module '@graspologic/memstore/reader/ReaderStore' {
    import { IdStoreImpl, ArrayStore, SlotAllocator } from '@graspologic/memstore/store';
    import { MemoryReaderClass, ReaderStore, MemoryReader } from '@graspologic/memstore/reader/types';
    /**
        * @inheritdoc
        * @see {@link ReaderStore}
        */
    export class ReaderStoreImpl<P extends MemoryReader> extends IdStoreImpl implements ReaderStore<P> {
            propertyBags: Record<number, any>;
            /**
                * Constructor for the ReaderStoreImpl
                * @param itemClass The class of the item, used when constructing new items
                * @param store The underlying store to use
                * @param allocator The allocator to use for allocating new ids
                */
            constructor(itemClass: MemoryReaderClass<P>, store: ArrayStore, allocator?: SlotAllocator);
            /**
                * @inheritdoc
                * @see {@link ReaderStore.receive}
                */
            receive(primitive: P): number;
            /**
                * @inheritdoc
                * @see {@link ReaderStore.itemAt}
                */
            itemAt(storeId: number): P;
            [Symbol.iterator](): Iterator<P>;
            scan(): IterableIterator<P>;
            /**
                * @inheritdoc
                * @see {@link ReaderStore.slurp}
                */
            slurp(targetId: number, sourceBuffer: ArrayBuffer, propertyBag?: any, sourceOffset?: number): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.add}
                */
            add(events?: boolean): number;
            /**
                * @inheritdoc
                * @see {@link IdStore.remove}
                */
            remove(idx: number): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.reset}
                */
            reset(): void;
            /**
                * @inheritdoc
                * @see {@link IdStore.destroy}
                */
            destroy(): void;
    }
}

declare module '@graspologic/memstore/reader/types' {
    import { MemoryLayout } from '@graspologic/memstore/specification';
    import { IdStore } from '@graspologic/memstore/store';
    /**
        * An object for interacting with the raw data for an item stored in an ArrayStore
        */
    export interface MemoryReader {
            /**
                * The memory layout
                */
            readonly layout: MemoryLayout;
            /**
                * The type of item
                */
            readonly type: symbol;
            /**
                * The underlying store
                */
            readonly store: ReaderStore<any>;
            /**
                * The low-level buffer access to the memory
                */
            readonly buffer: ArrayBuffer;
            /**
                * The low-level Uint8Array view access to the memory
                */
            readonly uint8Array: Uint8Array;
            /**
                * The low-level Float32Array view access to the memory
                */
            readonly float32Array: Float32Array;
            /**
                * The low-level Uint32Array view access to the memory
                */
            readonly uint32Array: Uint32Array;
            /**
                * The id of the item in the store
                */
            storeId: number;
            /**
                * The byte offset of the item in the store
                */
            byteOffset: number;
            /**
                * The word offset of the item in the store
                */
            wordOffset: number;
            /**
                * Connects this reader to a store instance
                * @param storeId The new storeid
                * @param store Thes store
                */
            connect(storeId: number, store: ReaderStore<any>): void;
    }
    /**
        * An object which can be constructed to produce a MemoryReader
        * @typeparam P The property interface for the item (i.e. Edge, Node)
        */
    export interface MemoryReaderClass<P> {
            new (store?: ReaderStore<P>, storeId?: number): P & MemoryReader;
    }
    /**
        * A getter function interface
        */
    export type GetterFn<T = any> = () => T;
    /**
        * A setter function
        * @param value The new value of the property
        */
    export type SetterFn<T = any, This = MemoryReader> = (this: This, value: T) => void;
    /**
        * A store which provides a list like functionality for interacting with MemoryReader based items
        */
    export interface ReaderStore<P> extends IdStore, Iterable<P & MemoryReader> {
            /**
                * dynamic property storage
                */
            propertyBags: Record<number, any>;
            /**
                * Accept an item into the store
                * @param primitive The primitive to accept into storage
                */
            receive(primitive: P & MemoryReader): number;
            /**
                * Get an item at an index
                * @param index The item index
                */
            itemAt(index: number): P & MemoryReader;
            /**
                * Copies data from a store into this store
                * @param targetId The target item id
                * @param sourceBuffer The source buffer
                * @param propertyBag The optional property bag
                * @param store The store to copy from
                */
            slurp(targetId: number, sourceBuffer: ArrayBuffer, propertyBag?: any, sourceOffset?: number): void;
            /**
                * Creates an iterator that efficiently scans through the items contained in this store
                *
                * _NOTE_ Items returned from this iterator should not be stored, as references are re-used for iteration
                */
            scan(): IterableIterator<P>;
    }
}

declare module '@graspologic/memstore/reader/MemoryReaderInspector' {
    import { AttributeName } from '@graspologic/memstore/specification';
    import { MemoryReader } from '@graspologic/memstore/reader/types';
    /**
        * A utility class for reading/writing individual properties of a MemoryReader
        */
    export class MemoryReaderInspector {
            /**
                * Calculates the byte offset for the given item's attribute
                * @param itemIndex The item index of the item
                * @param attribute The attribute
                */
            getByteOffset(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Calculates the typed offset for the given attribute
                * @param itemIndex The item index of the item
                * @param attribute The attribute
                */
            getTypedOffset(item: MemoryReader, attribute: AttributeName): number;
            getWordOffset(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Reads the __property__ for the __item__
                * @param item The item to get the property for
                * @param property The property to read
                */
            readProperty<P>(item: MemoryReader, property: AttributeName): P | undefined;
            /**
                * Writes the __property__ for the __item__
                * @param item The item to update
                * @param property The property to update
                * @param value The value of the property
                */
            writeProperty<P>(item: MemoryReader, property: AttributeName, value: P): void;
            /**
                * Reads __attribute__ from __item__ as a number
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readNumber(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Writes __attribute__ for __item__ as a number
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeNumber(item: MemoryReader, attribute: AttributeName, value: number): void;
            /**
                * Reads __attribute__ from __item__ as a string
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readString(item: MemoryReader, attribute: AttributeName): string | undefined;
            /**
                * Writes __attribute__ for __item__ as a string
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeString(item: MemoryReader, attribute: AttributeName, value: string): void;
            /**
                * Reads __attribute__ from __item__ as a boolean
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readBoolAttr(item: MemoryReader, attribute: AttributeName): boolean;
            /**
                * Writes __attribute__ for __item__ as a boolean
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeBoolAttr(item: MemoryReader, attribute: AttributeName, value: boolean): void;
            /**
                * Reads __attribute__ from __item__ as a float32
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readFloat32Attr(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Writes __attribute__ for __item__ as a float32
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeFloat32Attr(item: MemoryReader, attribute: AttributeName, value: number): void;
            /**
                * Reads __attribute__ from __item__ as a float32[2]
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readFloat32Vec2Attr(item: MemoryReader, attribute: AttributeName): [number, number];
            /**
                * Writes __attribute__ for __item__ as a float32[2]
                * @param item The item to update
                * @param attribute The attribute to update
                * @param x The x component to update
                * @param y The y component to update
                */
            writeFloat32Vec2Attr(item: MemoryReader, attribute: AttributeName, x: number, y: number): void;
            /**
                * Writes the float32[2] to the __typedOffset__ of the item
                * @param item The item to update
                * @param typedOffset The offset into the array to write the float32[2]
                * @param x The x component to update
                * @param y The y component to update
                */
            writeFloat32Vec2Offset(item: MemoryReader, typedOffset: number, x: number, y: number): void;
            /**
                * Copies the float32[3] from the sourceAttribute to targetAttribute
                * @param item The item to update
                * @param sourceAttribute The source attribute to copy from
                * @param targetAttribute The target attribute to copy to
                */
            copyFloat32Vec3Attr(item: MemoryReader, sourceAttribute: AttributeName, targetAttribute: AttributeName): Float32Array;
            /**
                * Copies the float32[2] from sourceTypedOffset to targetTypedOffset
                * @param item The item to update
                * @param sourceTypedOffset The typed offset for the source attribute
                * @param targetTypedOffset typed offset for the target attribute
                */
            copyFloat32Vec3Offset(item: MemoryReader, sourceTypedOffset: number, targetTypedOffset: number): Float32Array;
            /**
                * Writes __attribute__ for __item__ as a float32[3]
                * @param item The item to update
                * @param attribute The attribute to update
                * @param x The x component to update
                * @param y The y component to update
                * @param z The z component to update
                */
            writeFloat32Vec3Attr(item: MemoryReader, attribute: AttributeName, x: number, y: number, z: number): void;
            /**
                * Writes the float32[3] to the __typedOffset__ of the item
                * @param item The item to update
                * @param typedOffset The offset into the array to write the float32[3]
                * @param x The x component to update
                * @param y The y component to update
                * @param z The z component to update
                */
            writeFloat32Vec3Offset(item: MemoryReader, typedOffset: number, x: number, y: number, z: number): void;
            /**
                * Reads __attribute__ from __item__ as a float32[3]
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readFloat32Vec3Attr(item: MemoryReader, attribute: AttributeName): [number, number, number];
            /**
                * Reads __attribute__ from __item__ as a unit8
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readUint8Attr(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Writes __attribute__ for __item__ as a unit8
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeUint8Attr(item: MemoryReader, attribute: AttributeName, value: number): void;
            /**
                * Reads __attribute__ from __item__ as a unit8[2]
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readUint8Vec2Attr(item: MemoryReader, attribute: AttributeName): [number, number];
            /**
                * Writes __attribute__ for __item__ as a uint8[2]
                * @param item The item to update
                * @param attribute The attribute to update
                * @param x The x component to update
                * @param y The y component to update
                * @param z The z component to update
                */
            writeUint8Vec2Attr(item: MemoryReader, attribute: AttributeName, x: number, y: number): void;
            /**
                * Reads __attribute__ from __item__ as a unit8[3]
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readUint8Vec3Attr(item: MemoryReader, attribute: AttributeName): [number, number, number] | undefined;
            /**
                * Writes __attribute__ for __item__ as a uint8[3]
                * @param item The item to update
                * @param attribute The attribute to update
                * @param x The x component to update
                * @param y The y component to update
                * @param z The z component to update
                */
            writeUint8Vec3Attr(item: MemoryReader, attribute: AttributeName, x: number, y: number, z: number): void;
            /**
                * Reads __attribute__ from __item__ as a unit8[4]
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readUint8Vec4Attr(item: MemoryReader, attribute: AttributeName): [number, number, number, number] | undefined;
            /**
                * Writes __attribute__ for __item__ as a uint8[4]
                * @param item The item to update
                * @param attribute The attribute to update
                * @param x The x component to update
                * @param y The y component to update
                * @param z The z component to update
                * @param zz The zz component to update
                */
            writeUint8Vec4Attr(item: MemoryReader, attribute: AttributeName, x: number, y: number, z: number, zz: number): void;
            /**
                * Reads __attribute__ from __item__ as a uint32
                * @param item The item to get the attribute for
                * @param attribute The attribute to read
                */
            readUint32Attr(item: MemoryReader, attribute: AttributeName): number;
            /**
                * Writes __attribute__ for __item__ as a unit32
                * @param item The item to update
                * @param attribute The attribute to update
                * @param value The attribute value
                */
            writeUint32Attr(item: MemoryReader, attribute: AttributeName, value: number): void;
            /**
                * Writes the unit32 at the given __typedOffset__ for the item
                * @param item The item to update
                * @param typedOffset The offset into the array to write the uint32
                * @param value The attribute value
                */
            writeUint32Offset(item: MemoryReader, typedOffset: number, value: number): void;
            /**
                * Copies the uint32 from sourceTypedOffset to targetTypedOffset
                * @param item The item to update
                * @param sourceTypedOffset The typed offset for the source attribute
                * @param targetTypedOffset typed offset for the target attribute
                */
            copyUint32Offset(item: MemoryReader, sourceTypedOffset: number, targetTypedOffset: number): void;
    }
}

