// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@graspologic/graph
//   ../@graspologic/common
//   ../@graspologic/camera
//   ../@graspologic/memstore

declare module '@graspologic/renderer' {
    export { Node, Edge } from '@graspologic/graph';
    export * from '@graspologic/renderer/renderer';
    export * from '@graspologic/renderer/types';
    export * from '@graspologic/renderer/data';
    export * from '@graspologic/renderer/events';
    export * from '@graspologic/renderer/util';
    export * from '@graspologic/common';
}

declare module '@graspologic/renderer/renderer' {
    export * from '@graspologic/renderer/renderer/WebGLGraphRenderer';
}

declare module '@graspologic/renderer/types' {
    export * from '@graspologic/renderer/types/data';
    export * from '@graspologic/renderer/types/scene';
    export * from '@graspologic/renderer/types/renderer';
    export * from '@graspologic/renderer/types/primitives';
}

declare module '@graspologic/renderer/data' {
    export * from '@graspologic/renderer/data/processGraph';
}

declare module '@graspologic/renderer/events' {
    export * from '@graspologic/renderer/events/enableClickEvents';
    export * from '@graspologic/renderer/events/enablePanZoomEvents';
}

declare module '@graspologic/renderer/util' {
    export * from '@graspologic/renderer/util/colorizeRenderer';
}

declare module '@graspologic/renderer/renderer/WebGLGraphRenderer' {
    import { NodeComponentColorizer, Scene, PositionMap, InitializeHandler, GraphRenderer, UsesWebGL, GraphRendererEvents } from '@graspologic/renderer/types';
    import { Camera } from '@graspologic/camera';
    import { EventEmitter, RenderConfiguration, RenderConfigurationOptions } from '@graspologic/common';
    import { GraphContainer } from '@graspologic/graph';
    /**
        * A WebGL 2 based graph renderer
        */
    export class WebGLGraphRenderer extends EventEmitter<GraphRendererEvents> implements GraphRenderer, UsesWebGL {
            gl: WebGL2RenderingContext;
            config: RenderConfiguration;
            /** Returns the current engine time for animation tweening */
            engineTime: () => number;
            /**
                * Creates a new instance of the GraphRenderer
                * @param options The options for the render configuration
                */
            static createInstance(options?: Partial<RenderConfigurationOptions>, data?: GraphContainer, gl?: WebGL2RenderingContext): WebGLGraphRenderer;
            /**
                * @internal
                *
                * Triggers the onVertexClick event
                */
            handleClicked(): void;
            /**
                * Returns the underlying graph structure
                */
            get graph(): GraphContainer;
            /**
                * Gets whether or not the renderere is destroyed
                */
            get destroyed(): boolean;
            /**
                * Gets the camera
                */
            get camera(): Camera;
            /**
                * Add an initialization callback
                */
            onInitialize<T>(initializeHandler: InitializeHandler<T>): void;
            /**
                * Gets the scene, on which nodes and edges can be added
                */
            get scene(): Scene;
            /**
                * Returns the canvas behind the graph renderer
                */
            get view(): HTMLCanvasElement;
            /**
                * Loads the given graph into the renderer
                * @param data The graph to load
                * @param colorizer The colorizer function which determines the color of a node
                */
            load(data: GraphContainer, colorizer?: NodeComponentColorizer): void;
            /**
                * Changes the position of the given nodes
                * @deprecated since the nodestore shares memory with the renderer, this should no longer be necessary
                * @param newPositions The new positions of the nodes
                * @param duration The optional duration for how long the transition should take
                */
            changePositions(newPositions: PositionMap, duration?: number): void;
            /**
                * Resizes the renderer
                * @param width The width of the canvas
                * @param height The height of the canvas
                */
            resize(width: number, height: number): void;
            /**
                * @internal
                *
                * Forces the renderables to rebind to their data
                */
            rebind(): void;
            /**
                * Makes the graph renderer "dirty", so on the next render it will repaint itself
                */
            makeDirty: () => void;
            /**
                * A wrapper around camera.fitToView to ensure that the currently loaded graph is in view
                * @param duration The amount of time to take transitioning to the new view
                */
            zoomToGraph(duration?: number): void;
            /**
                * A wrapper around camera.fitToView to match the viewport
                * @param duration The amount of time to take transitioning to the new view
                */
            zoomToViewport(duration?: number): void;
            /**
                * Updates the weights in the graph
                */
            updateWeights(): Bounds3D;
            /**
                * Starts the animation loop
                */
            start(): void;
            /**
                * Stops the animation loop
                */
            stop(): void;
            /**
                * Renders the graph
                * @param delta The optional *engine time* diff since the last render, changing this will speed up or slow down animations
                * @returns The delta, either computed or the parameter passed to the function
                */
            render(delta?: number): number;
            /**
                * Returns a promise that is resolved before the first render
                */
            awaitKickoff(): Promise<void>;
            /**
                * Destroy's the graph renderer
                */
            destroy(): void;
    }
}

declare module '@graspologic/renderer/types/data' {
    import { ReaderStore } from '@graspologic/memstore';
    export type RegisterHandler<T> = (type: symbol, item: T) => any;
    /**
        * A generic store for storing "types" of items
        */
    export interface TypeStore<T> extends Iterable<T> {
            /**
                * Registers a primitive store with the data manager
                * @param type the render primitive type
                * @param store the data store to register
                */
            register(type: symbol, item: T): void;
            /**
                * Gets the types of data contained in this store
                */
            types(): Iterable<symbol>;
            /**
                * Adds a handler for when a type store is registered
                * @param handler The handler to add
                * @returns A unsubscribe function
                */
            onRegister(handler: RegisterHandler<T>): () => void;
            /**
                * Gets the data associated with the given primitive type
                * @param type The primitive type
                */
            retrieve<P extends T = T>(type: symbol): P | undefined;
            /**
                * Destroys the data manager
                */
            destroy(): void;
    }
    export type DataStore<T = any> = TypeStore<ReaderStore<T>>;
}

declare module '@graspologic/renderer/types/scene' {
    import { Primitive } from '@graspologic/renderer/types/primitives';
    import { Renderable, RenderOptions } from '@graspologic/common';
    import { Edge, Node } from '@graspologic/graph';
    /**
        * Represents a collection of primitives/renderables that are rendered
        * on the graph
        */
    export interface Scene {
            /**
                * Whether or not the scene needs a redraw
                */
            needsRedraw: boolean;
            /**
                * Adds the list of primitives to the scene
                * @param primitives The list of primitives to add
                */
            add(primitives: Primitive | Primitive[]): void;
            /**
                * Removes the given primitive from the sene
                * @param primitive The primitive to remove
                */
            remove(primitive: Primitive): void;
            /**
                * Clears the set of primitives loaded into the scene
                */
            clear(): void;
            /**
                * Gets the list of primitives contained in the scene
                * @param ids The list of ids to filter to
                * @param scan If true, a scan will be used instead of a traditional iterator __NOTE__ scanning reuses object references,
                * items returned should _not_ be stored
                */
            primitives(ids?: Set<string>, scan?: boolean): Iterable<Primitive>;
            /**
                * Returns the list of nodes in the scene
                * @param scan If true, a scan will be used instead of a traditional iterator __NOTE__ scanning reuses object references,
                * items returned should _not_ be stored
                */
            nodes(scan?: boolean): Iterable<Node>;
            /**
                * Gets the list of edges contained in the scene
                * @param scan If true, a scan will be used instead of a traditional iterator __NOTE__ scanning reuses object references,
                * items returned should _not_ be stored
                */
            edges(scan?: boolean): Iterable<Edge>;
            /**
                * Adds a renderable object that will be added to the rendering pipeline
                * @param renderable The renderable to add
                * @param doubleBuffered If the renderable should be double buffered
                */
            addRenderable(renderable: Renderable, doubleBuffered?: boolean): void;
            /**
                * Removes a renderable object from the rendering pipeline
                * @param renderable The renderable to remove
                */
            removeRenderable(renderable: Renderable): void;
            /**
                * Gets the list of renderables contained in this scene
                */
            renderables(): Iterable<Renderable>;
            /**
                * Tells the scene that a resize has occurred
                * @param width The width of the scene
                * @param height The height of the scene
                */
            resize(width: number, height: number): void;
            /**
                * @internal
                *
                * Initializes the scene
                * @param props The initialization props
                */
            initialize(props: {
                    gl: WebGLRenderingContext;
            }): void;
            /**
                * @internal
                *
                * Renders the scene
                * @param options The render options
                */
            render(options: Partial<RenderOptions>): void;
            /**
                * @internal
                *
                * Destroys the scene
                */
            destroy(): void;
            /**
                * @internal
                *
                * Rebuilds the node/edge saturation
                */
            rebuildSaturation(): void;
    }
}

declare module '@graspologic/renderer/types/renderer' {
    import { Scene } from '@graspologic/renderer/types/scene';
    import { Camera } from '@graspologic/camera';
    import { HasEvents, RenderConfiguration, Maybe, Id } from '@graspologic/common';
    import { Node, GraphContainer } from '@graspologic/graph';
    export type InitializeHandler<T> = (context: T) => void;
    /**
        * An interface indicating that a renderer uses WebGL
        */
    export interface UsesWebGL {
            /**
                * Returns the webgl context
                */
            readonly gl: WebGLRenderingContext;
    }
    export interface GraphRendererEvents {
            dirty(): void;
            resize(): void;
            load(): void;
            vertexClick(node: Node | undefined): void;
            vertexHovered(node: Node | undefined): void;
    }
    /**
        * Renderer for rendering a graph
        */
    export interface GraphRenderer extends HasEvents<GraphRendererEvents> {
            /**
                * Gets the camera
                */
            readonly camera: Camera;
            /**
                * Gets whether or not the renderer has been destroyed
                */
            readonly destroyed: boolean;
            /**
                * Returns the underlying graph structure
                */
            readonly graph: GraphContainer;
            /**
                * Gets the current render configuration
                */
            config: RenderConfiguration;
            /**
                * Gets the scene, on which nodes and edges can be added
                */
            scene: Scene;
            /**
                * Returns the canvas behind the graph renderer
                */
            view: HTMLElement;
            /**
                * @internal
                *
                * Lets the renderer know that a node has been clicked
                */
            handleClicked(): void;
            /**
                * Add an initialization callback
                */
            onInitialize<T>(initializeHandler: InitializeHandler<T>): void;
            /**
                * Loads the given graph into the renderer
                * @param data The graph to load
                * @param colorizer The colorizer function which determines the color of a node
                */
            load(data: GraphContainer, colorizer?: NodeComponentColorizer): void;
            /**
                * Changes the position of the given nodes
                * @param newPositions The new positions of the nodes
                * @param duration The optional duration for how long the transition should take
                */
            changePositions(newPositions: PositionMap, duration?: number): void;
            /**
                * Resizes the renderer
                * @param width The width of the canvas
                * @param height The height of the canvas
                */
            resize(width: number, height: number): void;
            /**
                * Makes the graph renderer "dirty", so on the next render it will repaint itself
                */
            makeDirty(): void;
            /**
                * A wrapper around camera.fitToView to ensure that the currently loaded graph is in view
                * @param duration The amount of time to take transitioning to the new view
                */
            zoomToGraph(duration?: number): void;
            /**
                * A wrapper around camera.fitToView to match the viewport
                * @param duration The amount of time to take transitioning to the new view
                */
            zoomToViewport(duration?: number): void;
            /**
                * Updates the weights in the graph
                */
            updateWeights(): void;
            /**
                * Starts the animation loop
                */
            start(): void;
            /**
                * Stops the animation loop
                */
            stop(): void;
            /**
                * Renders the graph
                * @param delta The optional *engine time* diff since the last render, changing this will speed up or slow down animations
                * @returns The delta, either computed or the parameter passed to the function
                */
            render(delta?: number): number;
            /**
                * Returns a promise that is resolved before the first render
                */
            awaitKickoff(): Promise<void>;
            /**
                * Destroy's the graph renderer
                */
            destroy(): void;
            /**
                * @internal
                *
                * Forces a re-bind to the underlying data store
                */
            rebind(): void;
    }
    export enum VisualDimensions {
            TwoD = "2D",
            ThreeD = "3D"
    }
    /**
        * A mapping between a key and a position object
        */
    export interface PositionMap {
            [key: string]: {
                    x: number;
                    y: number;
                    z?: number;
            };
    }
    /**
        * Provides a component based color for the given node
        * @param id The id of the node
        * @param group The group of the node
        * @returns A color in the form of [r, g, b, a] components
        */
    export type NodeComponentColorizer = (id: Maybe<Id>, group: Maybe<Id>) => [number, number, number, number];
    /**
        * Provides a color for the given node
        * @param id The id of the node
        * @param group The group of the node
        * @returns A color in the form of 0xbbggrraa
        */
    export type NodeBGRAColorizer = (id: Maybe<Id>, group: Maybe<Id>) => number;
    /**
        * Provides a color for the given node
        * @param id The id of the node
        * @param group The group of the node
        * @returns A color in the form of [r, g, b, a] components or an int color
        */
    export type NodeColorizer = (id: Maybe<Id>, group: Maybe<Id>) => [number, number, number, number] | number;
}

declare module '@graspologic/renderer/types/primitives' {
    import { MemoryReader } from '@graspologic/memstore';
    /**
        * A basic graphical primitive object
        */
    export type Primitive = MemoryReader & {
            id: string | undefined;
    };
}

declare module '@graspologic/renderer/data/processGraph' {
    import { NodeColorizer } from '@graspologic/renderer/types';
    import { GraphContainer } from '@graspologic/graph';
    /**
        * @internal
        *
        * Processes the graph contained in __data__ by normalizing weights, and assigning colors using __colorizerFn__
        * @param data The graph data
        * @param colorizerFn The colorizer
        */
    export function processGraph(data: GraphContainer, colorizerFn?: NodeColorizer): void;
}

declare module '@graspologic/renderer/events/enableClickEvents' {
    import { GraphRenderer } from '@graspologic/renderer/types';
    import { Disconnect } from '@graspologic/common';
    /**
      * Enables click events on the given graph renderer
      * @param renderer The graph renderer
      * @returns A disconnect function
      */
    export function enableClickEvents(renderer: GraphRenderer): Disconnect;
}

declare module '@graspologic/renderer/events/enablePanZoomEvents' {
    import { GraphRenderer } from '@graspologic/renderer/types';
    import { Disconnect } from '@graspologic/common';
    export interface EnablePanZoomEventOptions {
            /**
                * Enable the zoom to graph operation
                *
                * @defaultValue true
                */
            zoomToGraph: boolean;
    }
    /**
        * Enables pan & zoom events on the given graph renderer
        * @param renderer The graph renderer
        * @returns A disconnect function
        */
    export function enablePanZoomEvents(renderer: GraphRenderer, options?: Partial<EnablePanZoomEventOptions>): Disconnect;
}

declare module '@graspologic/renderer/util/colorizeRenderer' {
    import { GraphRenderer, NodeBGRAColorizer, NodeColorizer } from '@graspologic/renderer/types';
    export function correctColor(color: number): number;
    export function createBGRAColorizer(colorizerFn?: NodeColorizer): NodeBGRAColorizer;
    /**
        * Applies a colorizer function to the graph renderer
        * @param renderer The renderer to colorize
        * @param colorizerFn The function to use to color the renderer
        */
    export function colorizeRenderer(renderer: GraphRenderer, colorizerFn?: NodeColorizer): void;
    /**
        * Converts color components to a BGRA int color
        * @param components The color components [r, g, b, a]
        */
    export function componentColorToBGRA(components: [number, number, number, number]): number;
}

