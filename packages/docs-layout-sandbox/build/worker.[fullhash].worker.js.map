{"version":3,"file":"worker.[fullhash].worker.js","sources":["webpack:///webpack/bootstrap","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/RenderConfiguration.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/defaults.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/Interpolator.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/Properties.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/equality.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/events.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/fastDebounce.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/mixin.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-common-virtual-0d8c0ab72a/1/packages/libs/common/src/utils/processMinMax.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/graph/GraphContainer.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/graph/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/graph/internGraph.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/graph/populateAdjacency.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/graph/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/helpers/computeBounds.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/helpers/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/helpers/rand.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/impl/AnimatableEdgeImpl.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/impl/EdgeImpl.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/impl/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/layout.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/store.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/edge/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/impl/AnimatableNodeImpl.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/impl/NodeImpl.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/impl/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/layout.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/store.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/node/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/primitives/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/space/QuadTree.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/space/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/space/measure.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-graph-virtual-3961d3c38a/1/packages/libs/graph/src/space/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/clock/CountdownClock.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/clock/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/clock/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/layout/BaseExecutor.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/layout/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/workers/LayoutWorkerManager.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/workers/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/workers/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-core-virtual-a126a25cb9/1/packages/libs/layout-core/src/workers/workerFactory.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/AnnealingClock.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/DensityGrid.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/OpenOrdLayoutExecutor.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/factory.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/jumps.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/sampleBitmap.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/reader/MemoryReaderInspector.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/reader/ReaderStore.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/reader/createReader.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/reader/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/reader/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/specification/AttributeType.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/specification/LayoutBuilder.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/specification/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/specification/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/ArrayStore.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/IdStore.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/SlotAllocator.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/defaults.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/index.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-memstore-virtual-221945d339/1/packages/libs/memstore/src/store/types.ts","webpack:////home/chtrevin/ws/graspologic-js/.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/worker.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"../../../.yarn/__virtual__/cache-loader-virtual-a44cf2d551/0/cache/cache-loader-npm-4.1.0-82c3da90d8-0339778bdd.zip/node_modules/cache-loader/dist/cjs.js!../../../.yarn/__virtual__/babel-loader-virtual-9514560f53/0/cache/babel-loader-npm-8.1.0-e8c38740ba-fdbcae91cc.zip/node_modules/babel-loader/lib/index.js?!../../../.yarn/__virtual__/ts-loader-virtual-5ef653d34a/0/cache/ts-loader-npm-8.0.11-a6f1286fbd-2a5b570816.zip/node_modules/ts-loader/index.js?!../../../.yarn/__virtual__/@graspologic-layout-openord-virtual-d415035778/1/packages/libs/layout-openord/src/worker.ts\");\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { DEFAULT_DRAW_EDGES, DEFAULT_HIDE_EDGES_ON_MOVE, DEFAULT_DRAW_NODES, DEFAULT_HIDE_NODES_ON_MOVE, DEFAULT_HIDE_DESELECTED, DEFAULT_IS_3D, DEFAULT_BG_COLOR, DEFAULT_EDGE_CONSTANT_WIDTH, DEFAULT_EDGE_DEPTH_WRITE, DEFAULT_EDGE_ANTIALIAS, DEFAULT_EDGE_ALPHA, DEFAULT_EDGE_MIN_WIDTH, DEFAULT_EDGE_MAX_WIDTH, DEFAULT_EDGE_FILTERED_OUT_SATURATION, DEFAULT_EDGE_FILTERED_IN_SATURATION, DEFAULT_NODE_MIN_RADIUS, DEFAULT_NODE_MAX_RADIUS, DEFAULT_NODE_OUTLINE, DEFAULT_NODE_FILTERED_OUT_SATURATION, DEFAULT_NODE_FILTERED_IN_SATURATION, DEFAULT_CORNER_AXES, DEFAULT_DRAW_AXES, DEFAULT_INTERPOLATION_TIME, DEFAULT_HOVER_HIGHLIGHT_COLOR, DEFAULT_NODE_COUNT_HINT, DEFAULT_EDGE_COUNT_HINT, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_CAMERA_MODE, DEFAULT_AUTO_BIND, DEFAULT_BOUNDS, } from './defaults';\nimport { PropertyContainer, areColorsEqual, } from './utils';\n// TODO: These need to be documented\n// TODO: Theres got to be a way to auto gen this stuff\n/**\n * Container for the render configuration\n */\nclass RenderConfigurationImpl {\n    constructor() {\n        // Configurable properties\n        this._drawEdges = new PropertyContainer(DEFAULT_DRAW_EDGES);\n        this._hideEdgesOnMove = new PropertyContainer(DEFAULT_HIDE_EDGES_ON_MOVE);\n        this._drawNodes = new PropertyContainer(DEFAULT_DRAW_NODES);\n        this._hideNodesOnMove = new PropertyContainer(DEFAULT_HIDE_NODES_ON_MOVE);\n        this._hideDeselected = new PropertyContainer(DEFAULT_HIDE_DESELECTED);\n        this._is3D = new PropertyContainer(DEFAULT_IS_3D);\n        this._backgroundColor = new PropertyContainer(DEFAULT_BG_COLOR, areColorsEqual);\n        // Edge Properties\n        this._edgeConstantWidth = new PropertyContainer(DEFAULT_EDGE_CONSTANT_WIDTH);\n        this._edgeDepthWrite = new PropertyContainer(DEFAULT_EDGE_DEPTH_WRITE);\n        this._edgeAntialias = new PropertyContainer(DEFAULT_EDGE_ANTIALIAS);\n        this._edgeAlpha = new PropertyContainer(DEFAULT_EDGE_ALPHA);\n        this._edgeMinWidth = new PropertyContainer(DEFAULT_EDGE_MIN_WIDTH);\n        this._edgeMaxWidth = new PropertyContainer(DEFAULT_EDGE_MAX_WIDTH);\n        this._edgeFilteredOutSaturation = new PropertyContainer(DEFAULT_EDGE_FILTERED_OUT_SATURATION);\n        this._edgeFilteredInSaturation = new PropertyContainer(DEFAULT_EDGE_FILTERED_IN_SATURATION);\n        // Node Properties\n        this._nodeMinRadius = new PropertyContainer(DEFAULT_NODE_MIN_RADIUS);\n        this._nodeMaxRadius = new PropertyContainer(DEFAULT_NODE_MAX_RADIUS);\n        this._nodeOutline = new PropertyContainer(DEFAULT_NODE_OUTLINE);\n        this._nodeFilteredOutSaturation = new PropertyContainer(DEFAULT_NODE_FILTERED_OUT_SATURATION);\n        this._nodeFilteredInSaturation = new PropertyContainer(DEFAULT_NODE_FILTERED_IN_SATURATION);\n        this._nodeFilteredIds = new PropertyContainer(undefined);\n        this._nodeCountHint = new PropertyContainer(DEFAULT_NODE_COUNT_HINT);\n        this._edgeCountHint = new PropertyContainer(DEFAULT_EDGE_COUNT_HINT);\n        this._width = new PropertyContainer(DEFAULT_WIDTH);\n        this._height = new PropertyContainer(DEFAULT_HEIGHT);\n        this._dataBounds = new PropertyContainer(DEFAULT_BOUNDS);\n        // Axis Properties\n        this._cornerAxes = new PropertyContainer(DEFAULT_CORNER_AXES);\n        this._drawAxes = new PropertyContainer(DEFAULT_DRAW_AXES);\n        // Other\n        this._interpolationTime = new PropertyContainer(DEFAULT_INTERPOLATION_TIME);\n        this._hoverHighlightColor = new PropertyContainer(DEFAULT_HOVER_HIGHLIGHT_COLOR);\n        this._autoBind = new PropertyContainer(DEFAULT_AUTO_BIND);\n        this._cameraAdjustmentMode = new PropertyContainer(DEFAULT_CAMERA_MODE);\n    }\n    get backgroundColor() {\n        return this._backgroundColor.value;\n    }\n    set backgroundColor(value) {\n        this._backgroundColor.value = value;\n    }\n    onBackgroundColorChanged(handler) {\n        return this._backgroundColor.on('change', handler);\n    }\n    get drawEdges() {\n        return this._drawEdges.value;\n    }\n    set drawEdges(value) {\n        this._drawEdges.value = value;\n    }\n    onDrawEdgesChanged(handler) {\n        return this._drawEdges.on('change', handler);\n    }\n    get hideEdgesOnMove() {\n        return this._hideEdgesOnMove.value;\n    }\n    set hideEdgesOnMove(value) {\n        this._hideEdgesOnMove.value = value;\n    }\n    onHideEdgesOnMoveChanged(handler) {\n        return this._hideEdgesOnMove.on('change', handler);\n    }\n    get drawNodes() {\n        return this._drawNodes.value;\n    }\n    set drawNodes(value) {\n        this._drawNodes.value = value;\n    }\n    onDrawNodesChanged(handler) {\n        return this._drawNodes.on('change', handler);\n    }\n    get hideNodesOnMove() {\n        return this._hideNodesOnMove.value;\n    }\n    set hideNodesOnMove(value) {\n        this._hideNodesOnMove.value = value;\n    }\n    onHideNodesOnMoveChanged(handler) {\n        return this._hideNodesOnMove.on('change', handler);\n    }\n    get hideDeselected() {\n        return this._hideDeselected.value;\n    }\n    set hideDeselected(value) {\n        this._hideDeselected.value = value;\n    }\n    onHideDeselectedChanged(handler) {\n        return this._hideDeselected.on('change', handler);\n    }\n    get edgeConstantWidth() {\n        return this._edgeConstantWidth.value;\n    }\n    set edgeConstantWidth(value) {\n        this._edgeConstantWidth.value = value;\n    }\n    onEdgeConstantWidthChanged(handler) {\n        return this._edgeConstantWidth.on('change', handler);\n    }\n    get edgeDepthWrite() {\n        return this._edgeDepthWrite.value;\n    }\n    set edgeDepthWrite(value) {\n        this._edgeDepthWrite.value = value;\n    }\n    onEdgeDepthWriteChanged(handler) {\n        return this._edgeDepthWrite.on('change', handler);\n    }\n    get edgeAlpha() {\n        return this._edgeAlpha.value;\n    }\n    set edgeAlpha(value) {\n        this._edgeAlpha.value = value;\n    }\n    onEdgeAlphaChanged(handler) {\n        return this._edgeAlpha.on('change', handler);\n    }\n    get dataBounds() {\n        return this._dataBounds.value;\n    }\n    set dataBounds(value) {\n        this._dataBounds.value = value;\n    }\n    onDataBoundsChanged(handler) {\n        return this._dataBounds.on('change', handler);\n    }\n    get edgeAntialias() {\n        return this._edgeAntialias.value;\n    }\n    set edgeAntialias(value) {\n        this._edgeAntialias.value = value;\n    }\n    onEdgeAntialiasChanged(handler) {\n        return this._edgeAntialias.on('change', handler);\n    }\n    get edgeMinWidth() {\n        return this._edgeMinWidth.value;\n    }\n    set edgeMinWidth(value) {\n        this._edgeMinWidth.value = value;\n    }\n    onEdgeMinWidthChanged(handler) {\n        return this._edgeMinWidth.on('change', handler);\n    }\n    get edgeMaxWidth() {\n        return this._edgeMaxWidth.value;\n    }\n    set edgeMaxWidth(value) {\n        this._edgeMaxWidth.value = value;\n    }\n    onEdgeMaxWidthChanged(handler) {\n        return this._edgeMaxWidth.on('change', handler);\n    }\n    get nodeMinRadius() {\n        return this._nodeMinRadius.value;\n    }\n    set nodeMinRadius(value) {\n        this._nodeMinRadius.value = value;\n    }\n    onNodeMinRadiusChanged(handler) {\n        return this._nodeMinRadius.on('change', handler);\n    }\n    get autoBind() {\n        return this._autoBind.value;\n    }\n    set autoBind(value) {\n        this._autoBind.value = value;\n    }\n    get nodeMaxRadius() {\n        return this._nodeMaxRadius.value;\n    }\n    set nodeMaxRadius(value) {\n        this._nodeMaxRadius.value = value;\n    }\n    onNodeMaxRadiusChanged(handler) {\n        return this._nodeMaxRadius.on('change', handler);\n    }\n    get nodeOutline() {\n        return this._nodeOutline.value;\n    }\n    set nodeOutline(value) {\n        this._nodeOutline.value = value;\n    }\n    onNodeOutlineChanged(handler) {\n        return this._nodeOutline.on('change', handler);\n    }\n    get cornerAxes() {\n        return this._cornerAxes.value;\n    }\n    set cornerAxes(value) {\n        this._cornerAxes.value = value;\n    }\n    onCornerAxesChanged(handler) {\n        return this._cornerAxes.on('change', handler);\n    }\n    get drawAxes() {\n        return this._drawAxes.value;\n    }\n    set drawAxes(value) {\n        this._drawAxes.value = value;\n    }\n    onDrawAxesChanged(handler) {\n        return this._drawAxes.on('change', handler);\n    }\n    get interpolationTime() {\n        return this._interpolationTime.value;\n    }\n    set interpolationTime(value) {\n        this._interpolationTime.value = value;\n    }\n    onInterpolationTimeChanged(handler) {\n        return this._interpolationTime.on('change', handler);\n    }\n    get hoverHighlightColor() {\n        return this._hoverHighlightColor.value;\n    }\n    set hoverHighlightColor(value) {\n        this._hoverHighlightColor.value = value;\n    }\n    onHoverHighlightColorChanged(handler) {\n        return this._hoverHighlightColor.on('change', handler);\n    }\n    get is3D() {\n        return this._is3D.value;\n    }\n    set is3D(value) {\n        this._is3D.value = value;\n    }\n    onIs3DChanged(handler) {\n        return this._is3D.on('change', handler);\n    }\n    validateOn3DChanged(predicate) {\n        this._is3D.checkValidity(predicate);\n    }\n    get edgeFilteredOutSaturation() {\n        return this._edgeFilteredOutSaturation.value;\n    }\n    set edgeFilteredOutSaturation(value) {\n        this._edgeFilteredOutSaturation.value = value;\n    }\n    onEdgeFilteredOutSaturationChanged(handler) {\n        return this._edgeFilteredOutSaturation.on('change', handler);\n    }\n    get edgeFilteredInSaturation() {\n        return this._edgeFilteredInSaturation.value;\n    }\n    set edgeFilteredInSaturation(value) {\n        this._edgeFilteredInSaturation.value = value;\n    }\n    onEdgeFilteredInSaturationChanged(handler) {\n        return this._edgeFilteredInSaturation.on('change', handler);\n    }\n    get nodeFilteredOutSaturation() {\n        return this._nodeFilteredOutSaturation.value;\n    }\n    set nodeFilteredOutSaturation(value) {\n        this._nodeFilteredOutSaturation.value = value;\n    }\n    onNodeFilteredOutSaturationChanged(handler) {\n        return this._nodeFilteredOutSaturation.on('change', handler);\n    }\n    get nodeFilteredInSaturation() {\n        return this._nodeFilteredInSaturation.value;\n    }\n    set nodeFilteredInSaturation(value) {\n        this._nodeFilteredInSaturation.value = value;\n    }\n    onNodeFilteredInSaturationChanged(handler) {\n        return this._edgeFilteredInSaturation.on('change', handler);\n    }\n    get nodeFilteredIds() {\n        return this._nodeFilteredIds.value;\n    }\n    set nodeFilteredIds(value) {\n        this._nodeFilteredIds.value = value;\n    }\n    onNodeFilteredIdsChanged(handler) {\n        return this._nodeFilteredIds.on('change', handler);\n    }\n    get nodeCountHint() {\n        return this._nodeCountHint.value;\n    }\n    set nodeCountHint(value) {\n        this._nodeCountHint.value = value;\n    }\n    onNodeCountHintChanged(handler) {\n        return this._nodeCountHint.on('change', handler);\n    }\n    get edgeCountHint() {\n        return this._edgeCountHint.value;\n    }\n    set edgeCountHint(value) {\n        this._edgeCountHint.value = value;\n    }\n    onEdgeCountHintChanged(handler) {\n        return this._edgeCountHint.on('change', handler);\n    }\n    get width() {\n        return this._width.value;\n    }\n    set width(value) {\n        this._width.value = value;\n    }\n    onWidthChanged(handler) {\n        return this._width.on('change', handler);\n    }\n    get height() {\n        return this._height.value;\n    }\n    set height(value) {\n        this._height.value = value;\n    }\n    onHeightChanged(handler) {\n        return this._height.on('change', handler);\n    }\n    get cameraAdjustmentMode() {\n        return this._cameraAdjustmentMode.value;\n    }\n    set cameraAdjustmentMode(value) {\n        this._cameraAdjustmentMode.value = value;\n    }\n    onCameraAdjustmentModeChanged(handler) {\n        return this._cameraAdjustmentMode.on('change', handler);\n    }\n    copy() {\n        const { backgroundColor, cornerAxes, drawAxes, drawEdges, drawNodes, edgeAlpha, edgeAntialias, edgeConstantWidth, edgeDepthWrite, edgeFilteredInSaturation, edgeFilteredOutSaturation, edgeMaxWidth, edgeMinWidth, hideDeselected, hideEdgesOnMove, hideNodesOnMove, hoverHighlightColor, interpolationTime, is3D, nodeFilteredIds, nodeFilteredInSaturation, nodeFilteredOutSaturation, nodeMaxRadius, nodeMinRadius, nodeOutline, nodeCountHint, edgeCountHint, width, height, cameraAdjustmentMode, autoBind, dataBounds, } = this;\n        return {\n            backgroundColor,\n            cornerAxes,\n            drawAxes,\n            drawEdges,\n            drawNodes,\n            edgeAlpha,\n            edgeAntialias,\n            edgeConstantWidth,\n            edgeDepthWrite,\n            edgeFilteredInSaturation,\n            edgeFilteredOutSaturation,\n            edgeMaxWidth,\n            edgeMinWidth,\n            hideDeselected,\n            hideEdgesOnMove,\n            hideNodesOnMove,\n            hoverHighlightColor,\n            interpolationTime,\n            is3D,\n            nodeFilteredIds,\n            nodeFilteredInSaturation,\n            nodeFilteredOutSaturation,\n            nodeMaxRadius,\n            nodeMinRadius,\n            nodeOutline,\n            nodeCountHint,\n            edgeCountHint,\n            width,\n            height,\n            cameraAdjustmentMode,\n            autoBind,\n            dataBounds,\n        };\n    }\n    /**\n     * Loads the configuration options into the configuration\n     * @param options The partial set of render configuration options\n     */\n    load(options) {\n        Object.keys(options || {}).forEach(key => {\n            ;\n            this[key] = options[key];\n        });\n    }\n}\n/**\n * @internal\n *\n * Creates a new render configuration\n * @param props The partial set of render configuration options\n */\nexport function createConfiguration(props) {\n    const config = new RenderConfigurationImpl();\n    config.load(props || {});\n    return config;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { CameraAdjustmentMode } from './types';\n// Default color is transparent\nexport const DEFAULT_BG_COLOR = [0, 0, 0, 0];\nexport const DEFAULT_DRAW_EDGES = true;\nexport const DEFAULT_HIDE_EDGES_ON_MOVE = false;\nexport const DEFAULT_DRAW_NODES = true;\nexport const DEFAULT_HIDE_NODES_ON_MOVE = false;\nexport const DEFAULT_HIDE_DESELECTED = false;\nexport const DEFAULT_IS_3D = false;\nexport const DEFAULT_INTERPOLATION_TIME = 1000;\nexport const DEFAULT_HOVER_HIGHLIGHT_COLOR = [\n    160 / 255,\n    240 / 255,\n    255 / 255,\n    207 / 255,\n];\nexport const DEFAULT_DRAW_AXES = true;\nexport const DEFAULT_CORNER_AXES = true;\nexport const DEFAULT_EDGE_CONSTANT_WIDTH = true;\nexport const DEFAULT_EDGE_DEPTH_WRITE = false;\nexport const DEFAULT_EDGE_ANTIALIAS = false;\nexport const DEFAULT_EDGE_ALPHA = 0.15;\nexport const DEFAULT_EDGE_MIN_WIDTH = 1.0;\nexport const DEFAULT_EDGE_MAX_WIDTH = 2.0;\nexport const DEFAULT_EDGE_FILTERED_OUT_SATURATION = 0.1;\nexport const DEFAULT_EDGE_FILTERED_IN_SATURATION = 1.0;\nexport const DEFAULT_NODE_MIN_RADIUS = 4.0;\nexport const DEFAULT_NODE_MAX_RADIUS = 8.0;\nexport const DEFAULT_NODE_OUTLINE = true;\nexport const DEFAULT_NODE_FILTERED_OUT_SATURATION = 0.1;\nexport const DEFAULT_NODE_FILTERED_IN_SATURATION = 1.0;\nexport const DEFAULT_NODE_COUNT_HINT = 10000;\nexport const DEFAULT_EDGE_COUNT_HINT = 10000;\nexport const DEFAULT_WIDTH = 500;\nexport const DEFAULT_HEIGHT = 500;\nexport const DEFAULT_BOUNDS = undefined;\nexport const DEFAULT_USE_DEVICE_PIXELS = true;\nexport const DEFAULT_SCALE_VIEW_ON_INIT = true;\nexport const DEFAULT_CAMERA_MODE = CameraAdjustmentMode.Graph;\nexport const DEFAULT_AUTO_BIND = true;\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './utils';\nexport * from './defaults';\nexport * from './RenderConfiguration';\nexport * from './types';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport var CameraAdjustmentMode;\n(function (CameraAdjustmentMode) {\n    /**\n     * Camera is automatically adjusted to fit the graph to the window\n     */\n    CameraAdjustmentMode[CameraAdjustmentMode[\"Graph\"] = 0] = \"Graph\";\n    /**\n     * Camera is adjusted such that the graph coordinate space is a 1 to 1 mapping of the coordinate space to pixel space\n     * i.e. A node at (1000, 1000) will show up at (1000, 1000) on the screen\n     */\n    CameraAdjustmentMode[CameraAdjustmentMode[\"Viewport\"] = 1] = \"Viewport\";\n    /**\n     * Camera is not adjusted automatically\n     */\n    CameraAdjustmentMode[CameraAdjustmentMode[\"None\"] = 2] = \"None\";\n})(CameraAdjustmentMode || (CameraAdjustmentMode = {}));\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport class Interpolator {\n    /**\n     * Constructor\n     * @param config The render configuration\n     */\n    constructor(_interpolationTime) {\n        this._interpolationTime = _interpolationTime;\n        this._frameTime = 0;\n        this._current = 0;\n        this._target = 1;\n    }\n    /**\n     * Resets the interpolation state\n     */\n    reset() {\n        this._frameTime = 0;\n        this.current = 0;\n    }\n    /**\n     * Gets the current value of the interpolator\n     */\n    get current() {\n        return this._current;\n    }\n    /**\n     * Sets the current value of the interpolator\n     */\n    set current(value) {\n        this._current = value;\n    }\n    /**\n     * Gets the target value of the interpolator\n     */\n    set target(value) {\n        this._target = value;\n    }\n    /**\n     * Sets the target value of the interpolator\n     */\n    get target() {\n        return this._target;\n    }\n    /**\n     * Gets whether or not interpolation is complete\n     */\n    get isComplete() {\n        return this._current === this.target;\n    }\n    /**\n     * Gets the interpolation time\n     */\n    get interpolationTime() {\n        return this._interpolationTime;\n    }\n    /**\n     * Sets the interpolation time\n     */\n    set interpolationTime(value) {\n        this._interpolationTime = value;\n    }\n    /**\n     * Updates the interpolation state based on the current time\n     * @param time The current time\n     */\n    tick(time) {\n        if (this._frameTime === 0) {\n            this._frameTime = time;\n        }\n        if (this._interpolationTime > 0) {\n            this.current += (time - this._frameTime) / this._interpolationTime;\n            if (this.current > this.target) {\n                this.current = this.target;\n            }\n        }\n        else {\n            this._frameTime = 0;\n            this._current = this.target;\n        }\n        this._frameTime = time;\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { EventEmitter } from './events';\n/**\n * @internal\n *\n * A class for managing a property that emits an event when it changes\n */\nexport class PropertyContainer extends EventEmitter {\n    /**\n     * Constructor\n     * @param _value The current value\n     * @param areEqual An equality function\n     */\n    constructor(_value, areEqual = (a, b) => a === b) {\n        super();\n        this._value = _value;\n        this.areEqual = areEqual;\n        this.isValid = () => true;\n    }\n    /**\n     * Sets the validator which validates whether or not a value is a valid value for this property container\n     * @param isValid The validator\n     */\n    checkValidity(isValid) {\n        this.isValid = isValid;\n    }\n    /**\n     * Gets the value contained in the container\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * Sets the value in the container\n     */\n    set value(newValue) {\n        if (this.isValid(newValue) && !this.areEqual(newValue, this._value)) {\n            this._value = newValue;\n            this.emit('change', newValue);\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport function areColorsEqual(a, b) {\n    for (let i = 0; i < 4; ++i) {\n        if (b[i] !== a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { applyMixins } from './mixin';\n/**\n * An implementation of an object which emits a set of events\n */\nexport class EventEmitter {\n    constructor() {\n        this.listeners = {};\n    }\n    /**\n     * Adds an event listener for the given event\n     */\n    on(name, handler) {\n        this.listeners[name] = this.listeners[name] || [];\n        this.listeners[name].push(handler);\n        return () => this.off(name, handler);\n    }\n    /**\n     * Removes an event listener for the given event\n     */\n    off(name, handler) {\n        const listeners = this.listeners[name];\n        if (listeners) {\n            const idx = listeners.indexOf(handler);\n            if (idx >= 0) {\n                listeners.splice(idx, 1);\n            }\n        }\n    }\n    /**\n     * Raises the given event\n     */\n    emit(name, payload) {\n        const listeners = this.listeners[name];\n        if (listeners) {\n            listeners.forEach(l => {\n                ;\n                l.call(this, payload);\n            });\n        }\n    }\n    /**\n     * Returns true if there are any listeners for the given event\n     * @param name The event name\n     */\n    hasListeners(name) {\n        this.listeners = this.listeners || {};\n        const listeners = this.listeners[name];\n        if (listeners) {\n            return listeners.length > 0;\n        }\n        return false;\n    }\n}\n/**\n * A mixin that adds support for event emitting\n * @param Base The base class to mixin the EventEmitter into\n */\nexport function EventsMixin(Base) {\n    class EventImpl extends Base {\n        constructor() {\n            super(...arguments);\n            // This is a necessary evil, to ensure that the \"listeners\" fields gets added\n            this.listeners = {};\n        }\n    }\n    applyMixins(EventImpl, [EventEmitter]);\n    return EventImpl;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport function fastDebounce(callback, delay = 100) {\n    let lastUpdate;\n    let startLoop = true;\n    function loop() {\n        const timeSinceLastUpdate = Date.now() - lastUpdate;\n        if (timeSinceLastUpdate < delay) {\n            // Set timeout for the remaining time\n            setTimeout(loop, delay - timeSinceLastUpdate);\n        }\n        else {\n            startLoop = true;\n            callback();\n        }\n    }\n    return function () {\n        lastUpdate = Date.now();\n        if (startLoop) {\n            startLoop = false;\n            loop();\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './Properties';\nexport * from './equality';\nexport * from './processMinMax';\nexport * from './Interpolator';\nexport * from './fastDebounce';\nexport * from './events';\n","export function applyMixins(derivedCtor, constructors) {\n    constructors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n        });\n    });\n    return derivedCtor;\n}\n","/**\n * Updates the given bounds based on the new x, y, z values\n * @param bounds The current bounds\n * @param x The new x to be added\n * @param y The new y to be added\n * @param z The new z to be added\n */\nexport function processMinMax(bounds, x, y, z) {\n    bounds.x.min = Math.min(bounds.x.min, x);\n    bounds.x.max = Math.max(bounds.x.max, x);\n    bounds.y.min = Math.min(bounds.y.min, y);\n    bounds.y.max = Math.max(bounds.y.max, y);\n    bounds.z.min = Math.min(bounds.z.min, z);\n    bounds.z.max = Math.max(bounds.z.max, z);\n}\n/**\n * Updates the given bounds based on the new bounds\n * @param target The current bounds\n * @param newBounds The new bounds\n */\nexport function processMinMaxBounds(target, newBounds) {\n    // X\n    target.x.max = Math.max(newBounds.x.min, newBounds.x.max, target.x.max);\n    target.x.min = Math.min(newBounds.x.min, newBounds.x.max, target.x.min);\n    // X\n    target.y.max = Math.max(newBounds.y.min, newBounds.y.max, target.y.max);\n    target.y.min = Math.min(newBounds.y.min, newBounds.y.max, target.y.min);\n    // Z\n    target.z.max = Math.max(newBounds.z.min, newBounds.z.max, target.z.max);\n    target.z.min = Math.min(newBounds.z.min, newBounds.z.max, target.z.min);\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { createNodeStore, createEdgeStore } from '../primitives';\nimport { weightedCentroid } from '../space/measure';\nimport { internGraph, DEFAULT_INTERN_GRAPH_OPTIONS, } from './internGraph';\nimport { populateAdjacency } from './populateAdjacency';\n/**\n * The datastructure which contains all the internal graph data required for the GraphRenderer\n */\nexport class GraphContainer {\n    // #endregion\n    /**\n     * @internal\n     * Constructs a new instance of the GraphContainer\n     * @param nodes The initial node data store\n     * @param edges The initial edge data store\n     */\n    constructor(nodes, edges) {\n        this._nodes = nodes;\n        this._edges = edges;\n    }\n    /**\n     * @internal\n     * Gets the underlying node store\n     */\n    get nodes() {\n        return this._nodes;\n    }\n    /**\n     * @internal\n     * Gets the underlying edge store\n     */\n    get edges() {\n        return this._edges;\n    }\n    /**\n     * Creates an instance of the GraphContainer using the given input graph\n     * @param inputGraph The pojo graph to intern\n     * @param options The set of options controlling how the graph is interned, defaults to @see {@link DEFAULT_INTERN_GRAPH_OPTIONS}\n     * @returns The GraphContainer\n     */\n    static intern(inputGraph, options = DEFAULT_INTERN_GRAPH_OPTIONS) {\n        return internGraph(inputGraph, options);\n    }\n    /**\n     * @internal\n     * Serializes the GraphContainer instance\n     * @returns The serialized version of the GraphContainer\n     */\n    serialize() {\n        return {\n            nodes: this.nodes.store.buffer,\n            edges: this.edges.store.buffer,\n        };\n    }\n    /**\n     * @internal\n     * Deserializes the GraphContainer instance\n     * @param graph The serialized version of the GraphContainer\n     * @returns The deserialized GraphContainer\n     */\n    static deserialize(graph) {\n        const nodeStore = createNodeStore({\n            buffer: graph.nodes,\n            allocatedOnCreate: true,\n        });\n        const edgeStore = createEdgeStore({\n            buffer: graph.edges,\n            allocatedOnCreate: true,\n        });\n        return new GraphContainer(nodeStore, edgeStore);\n    }\n    /**\n     * @internal\n     * Retrieve neigbors of the given node. This may be reflect edge-cutting\n     * performed by the algorithm\n     * @param n The node index to retrieve neighbors for\n     * @returns A list of neighbor node indices\n     */\n    getNeighbors(n) {\n        const result = this.getAdjacencyMap(false).get(n);\n        return result ? Object.keys(result).map(k => parseInt(k, 10)) : [];\n    }\n    /**\n     * @internal\n     * Retrieve neigbors of the given node. This will not reflect any edge-cutting\n     * performed by the algorithm\n     * @param n The node index to retrieve neighbors for\n     * @returns A list of neighbor node indices\n     */\n    getNeighborsObjective(id) {\n        const result = this.getAdjacencyMap(true).get(id);\n        if (!result) {\n            throw new Error(`could not get adjacency for node ${id}`);\n        }\n        return Object.keys(result).map(k => parseInt(k, 10));\n    }\n    /**\n     * @internal\n     * Gets the edge weight between two nodes, which may reflect edge-cutting.\n     * @throws if source and target are not connected\n     * @param source The source node index\n     * @param target The target node index\n     * @returns The edge weight\n     */\n    getEdgeWeight(source, target) {\n        const result = this.getAdjacencyMap(false).get(source);\n        if (!result) {\n            throw new Error(`could not get adjacency for node ${source}`);\n        }\n        return result[target];\n    }\n    /**\n     * @internal\n     * Gets the edge weight between two nodes, ignoring reflect edge-cutting\n     * @throws if source and target are not connected\n     * @param source The source node index\n     * @param target The target node index\n     * @returns The edge weight\n     */\n    getEdgeWeightObjective(source, target) {\n        const result = this.getAdjacencyMap(true).get(source);\n        if (!result) {\n            throw new Error(`could not get objective adjacency for node ${source}`);\n        }\n        return result[target];\n    }\n    /**\n     * @internal\n     * Returns the computed cetroid of the neighborhood that the given node is a part of\n     * @param n The node to get the neighborhood centroid for\n     * @returns The centroid\n     */\n    getNeighborhoodCentroid(n) {\n        const neighbors = this.getNeighbors(n);\n        const node = this.nodes.itemAt(n);\n        if (!node) {\n            throw new Error('could not get node ' + n);\n        }\n        else if (neighbors.length === 0) {\n            return { x: node.x, y: node.y };\n        }\n        else {\n            const neighborPositions = [node];\n            const neighborWeights = [1];\n            neighbors.forEach(nid => {\n                const neighbor = this.nodes.itemAt(nid);\n                const edgeWeight = this.getEdgeWeight(n, nid);\n                neighborPositions.push(neighbor);\n                neighborWeights.push(edgeWeight);\n            });\n            const result = weightedCentroid(neighborPositions, neighborWeights);\n            return result;\n        }\n    }\n    /**\n     * @internal\n     * Prunes an edge\n     * @param from The source node\n     * @param to The target node\n     */\n    pruneEdge(from, to) {\n        const fromList = this.getAdjacencyMap(false).get(from);\n        const toList = this.getAdjacencyMap(false).get(to);\n        if (!fromList || !toList) {\n            throw new Error(`could not get edge for (${from}, ${to})`);\n        }\n        delete fromList[to];\n        delete toList[from];\n    }\n    /**\n     * @internal\n     * Gets an adjacency map\n     * @param original If the original adjacency map is required\n     * @returns The adjacency map\n     */\n    getAdjacencyMap(original) {\n        if (!this._originalAdjacency) {\n            this._originalAdjacency = populateAdjacency(this.nodes, this.edges);\n        }\n        if (!this._adjacency && !original) {\n            this._adjacency = populateAdjacency(this.nodes, this.edges);\n        }\n        return original ? this._originalAdjacency : this._adjacency;\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './GraphContainer';\nexport * from './types';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { randBetween } from '../helpers';\nimport { createNodeStore, createEdgeStore } from '../primitives';\nimport { GraphContainer } from './GraphContainer';\nexport const DEFAULT_INTERN_GRAPH_OPTIONS = Object.freeze({\n    defaultEdgeWeight: 1,\n    shareable: true,\n});\n/**\n * @internal\n *\n * Interns a raw graph into a GraphContainer, used by graspologic\n * @param input A raw input graph\n * @param options: internization options\n * @returns The GraphContainer\n */\nexport function internGraph(input, { shareable = DEFAULT_INTERN_GRAPH_OPTIONS.shareable, randomize, defaultEdgeWeight = DEFAULT_INTERN_GRAPH_OPTIONS.defaultEdgeWeight, } = DEFAULT_INTERN_GRAPH_OPTIONS) {\n    const graph = getEmptyGraphContainer(input.nodes.length, input.edges.length, shareable);\n    let i = 0;\n    const nodeIdToIndex = new Map();\n    if (input.nodes.length > 0) {\n        let node;\n        let inputNode;\n        i = 0;\n        for (node of graph.nodes.scan()) {\n            if (i >= input.nodes.length) {\n                break;\n            }\n            inputNode = input.nodes[i];\n            if (input.edges.length > 0) {\n                nodeIdToIndex.set(inputNode.id, i);\n            }\n            node.connect(i, graph.nodes);\n            node.load(inputNode);\n            if (randomize && node.x === 0 && node.y === 0) {\n                node.x = randBetween(randomize[0], randomize[1]);\n                node.y = randBetween(randomize[2], randomize[3]);\n            }\n            ++i;\n        }\n    }\n    if (input.edges.length > 0) {\n        let edge;\n        i = 0;\n        for (edge of graph.edges.scan()) {\n            if (i >= input.edges.length) {\n                break;\n            }\n            edge.connect(i, graph.edges);\n            edge.load(input.edges[i], nodeIdToIndex, defaultEdgeWeight);\n            ++i;\n        }\n    }\n    return graph;\n}\n/**\n * Creates an empty graph container\n * @param numNodes The number of nodes to preallocate\n * @param numEdges The number of edges to preallocate\n * @param shareable Whether to use shared-memory\n * @returns An empty graph container\n */\nfunction getEmptyGraphContainer(numNodes, numEdges, shareable = true) {\n    return new GraphContainer(createNodeStore({\n        capacity: numNodes,\n        shared: shareable,\n        allocatedOnCreate: true,\n    }), createEdgeStore({\n        capacity: numEdges,\n        shared: shareable,\n        allocatedOnCreate: true,\n    }));\n}\n","/**\n * @internal\n * Populates an adjacency map\n * @param nodes the nodes data\n * @param edges the edges data\n * @returns An adjacency map\n */\nexport function populateAdjacency(nodes, edges) {\n    const adj = new Map();\n    let node;\n    for (node of nodes) {\n        adj.set(node.storeId, {});\n    }\n    // Load the adjacency matrix\n    let maxWeight = 0.000001;\n    let sourceList;\n    let targetList;\n    let edge;\n    for (edge of edges) {\n        const { sourceIndex, targetIndex, weight } = edge;\n        sourceList = adj.get(sourceIndex);\n        targetList = adj.get(targetIndex);\n        if (weight > maxWeight) {\n            maxWeight = weight;\n        }\n        sourceList[targetIndex] = weight;\n        targetList[sourceIndex] = weight;\n    }\n    // Nomalize the edge weights\n    let value;\n    let key;\n    for (value of adj.values()) {\n        for (key of Object.keys(value)) {\n            value[parseInt(key, 10)] /= maxWeight;\n        }\n    }\n    return adj;\n}\n","export {};\n","/**\n * Computes the bounds of the given graph\n * @param graph The graph to compute the bounds from\n */\nexport function computeBounds(graph) {\n    if (graph) {\n        let bounds;\n        for (const node of graph.nodes) {\n            if (!bounds) {\n                bounds = {\n                    x: {\n                        min: node.x,\n                        max: node.x,\n                    },\n                    y: {\n                        min: node.y,\n                        max: node.y,\n                    },\n                    z: {\n                        min: node.z,\n                        max: node.z,\n                    },\n                };\n            }\n            else {\n                bounds.x.min = Math.min(node.x, bounds.x.min);\n                bounds.x.max = Math.max(node.x, bounds.x.max);\n                bounds.y.min = Math.min(node.y, bounds.y.min);\n                bounds.y.max = Math.max(node.y, bounds.y.max);\n                bounds.z.min = Math.min(node.z, bounds.z.min);\n                bounds.z.max = Math.max(node.z, bounds.z.max);\n            }\n        }\n        return bounds;\n    }\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './rand';\nexport * from './computeBounds';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport function jiggle(factor = 1e-6) {\n    return (Math.random() - 0.5) * factor;\n}\n/**\n * @internal\n *\n * Generates a random number between the min and max values\n * @param min The minimum value of the number\n * @param max The maximum value of the number\n * @returns The random number\n */\nexport function randBetween(min, max) {\n    return Math.random() * (max - min) + min;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './space';\nexport * from './graph';\nexport * from './helpers';\nexport * from './primitives';\n","import { edgeTypedOffset } from '../layout';\nimport { EdgeImpl } from './EdgeImpl';\nimport { MemoryReaderInspector } from '@graspologic/memstore';\n// Cache several frequently accessed names / offsets\nconst allAttributes = '*';\nconst sourcePositionAttr = 'sourcePosition';\nconst sourcePositionStartAttr = 'sourcePosition.start';\nconst sourcePositionTweenAttr = 'sourcePosition.tween';\nconst targetPositionAttr = 'targetPosition';\nconst targetPositionStartAttr = 'targetPosition.start';\nconst targetPositionTweenAttr = 'targetPosition.tween';\nconst sourcePositionTypedOffset = edgeTypedOffset(sourcePositionAttr);\nconst sourcePositionStartTypedOffset = edgeTypedOffset(sourcePositionStartAttr);\nconst sourcePositionTweenTypedOffset = edgeTypedOffset(sourcePositionTweenAttr);\nconst targetPositionTypedOffset = edgeTypedOffset(targetPositionAttr);\nconst targetPositionStartTypedOffset = edgeTypedOffset(targetPositionStartAttr);\nconst targetPositionTweenTypedOffset = edgeTypedOffset(targetPositionTweenAttr);\nconst inspector = new MemoryReaderInspector();\n/**\n * An implementation of an Edge that has animation capabilities\n */\nclass AnimatableEdgeImplInternal extends EdgeImpl {\n    /**\n     * @inheritDoc\n     * @see {@link AnimatableEdge.animateSourcePosition}\n     */\n    animateSourcePosition(position, duration) {\n        // Set the start to the old position\n        inspector.copyFloat32Vec3Offset(this, sourcePositionTypedOffset, sourcePositionStartTypedOffset);\n        this.handleAttributeUpdated(sourcePositionStartAttr);\n        // Update the tween\n        inspector.writeFloat32Vec2Offset(this, sourcePositionTweenTypedOffset, duration || 0, this.store?.engineTime || 0);\n        this.handleAttributeUpdated(sourcePositionTweenAttr);\n        // Update the end sourcePosition\n        inspector.writeFloat32Vec3Offset(this, sourcePositionTypedOffset, position[0] || 0, position[1] || 0, position[2] || 0);\n        this.handleAttributeUpdated(sourcePositionAttr);\n    }\n    /**\n     * @inheritDoc\n     * @see {@link AnimatableEdge.animateTargetPosition}\n     */\n    animateTargetPosition(position, duration) {\n        // Set the start to the old position\n        inspector.copyFloat32Vec3Offset(this, targetPositionTypedOffset, targetPositionStartTypedOffset);\n        this.handleAttributeUpdated(targetPositionStartAttr);\n        // Update the tween\n        inspector.writeFloat32Vec2Offset(this, targetPositionTweenTypedOffset, duration || 0, this.store?.engineTime || 0);\n        this.handleAttributeUpdated(targetPositionTweenAttr);\n        // Update the end targetPosition\n        inspector.writeFloat32Vec3Offset(this, targetPositionTypedOffset, position[0] || 0, position[1] || 0, position[2] || 0);\n        this.handleAttributeUpdated(targetPositionAttr);\n    }\n    /**\n     * @inheritDoc\n     * @see {@link Edge.load}\n     */\n    load(data, nodeIndexMap, defaultEdgeWeight = 1) {\n        super.load(data, nodeIndexMap, defaultEdgeWeight);\n        this.handleAttributeUpdated(allAttributes);\n    }\n    /**\n     * Handler for when an attribute is updated\n     * @param name The name of the attribute\n     */\n    handleAttributeUpdated(name) {\n        if (this.store) {\n            this.store.notify(this.storeId, name);\n        }\n    }\n}\n/**\n * An implementation of an Edge that has animation capabilities\n */\nexport const AnimatableEdgeImpl = AnimatableEdgeImplInternal;\n","import { edgeType, edgeMemoryLayout, ADDITIONAL_EDGE_PROPS } from '../layout';\nimport { createReader } from '@graspologic/memstore';\n// Cache some of the attributes for the \"load\"\nconst sourceIndexTypedOffset = edgeMemoryLayout.get('sourceIndex').typedOffset;\nconst targetIndexTypedOffset = edgeMemoryLayout.get('targetIndex').typedOffset;\nconst colorTypedOffset = edgeMemoryLayout.get('color').typedOffset;\nconst color2TypedOffset = edgeMemoryLayout.get('color2').typedOffset;\nconst weightTypedOffset = edgeMemoryLayout.get('weight').typedOffset;\n/**\n * An implementation of an Edge\n */\nconst BaseEdgeImpl = createReader(edgeType, edgeMemoryLayout, ADDITIONAL_EDGE_PROPS);\nexport class EdgeImpl extends BaseEdgeImpl {\n    /**\n     * @inheritDoc\n     * @see {@link Edge.load}\n     */\n    load(data, nodeIndexMap, defaultEdgeWeight = 1) {\n        ;\n        this.propertyBag = this.store.propertyBags[this.storeId] || {};\n        this.store.propertyBags[this.storeId] = this.propertyBag;\n        this.propertyBag.source = data.source;\n        this.propertyBag.target = data.target;\n        this.uint32Array[this.wordOffset + sourceIndexTypedOffset] = nodeIndexMap.get(data.source);\n        this.uint32Array[this.wordOffset + targetIndexTypedOffset] = nodeIndexMap.get(data.target);\n        this.float32Array[this.wordOffset + weightTypedOffset] =\n            data.weight != null ? data.weight : defaultEdgeWeight;\n        this.uint32Array[this.wordOffset + colorTypedOffset] =\n            data.color || data.sourceColor || 0;\n        this.uint32Array[this.wordOffset + color2TypedOffset] =\n            data.color2 || data.targetColor || 0;\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './EdgeImpl';\nexport * from './AnimatableEdgeImpl';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './store';\nexport * from './types';\nexport * from './impl';\nexport * from './layout';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { createLayoutBuilder, InterpretationHint } from '@graspologic/memstore';\n/**\n * The unique symbol for an edge\n */\nexport const edgeType = Symbol('@graspologic::edge');\n/**\n * @internal\n *\n * The additional edge props\n */\nexport const ADDITIONAL_EDGE_PROPS = ['id', 'source', 'target', 'data'];\n/**\n * @internal\n * The internal memory layout for storing edges\n */\nexport const edgeMemoryLayout = createLayoutBuilder()\n    .addUint32('sourceIndex')\n    .addUint32('targetIndex')\n    .addFloat32('weight')\n    .addFloat32('trueWeight')\n    .addFloat32('saturation')\n    .addFloat32('saturation2')\n    .addUint32('color')\n    .addUint32('color2')\n    .addUint8('visible', { hint: InterpretationHint.Boolean })\n    .addFloat32Vec3('sourcePosition.start')\n    .addFloat32Vec3('sourcePosition')\n    .addFloat32Vec2('sourcePosition.tween', {\n    components: ['sourcePosition.duration', 'sourcePosition.startTime'],\n})\n    .addFloat32Vec3('targetPosition.start')\n    .addFloat32Vec3('targetPosition')\n    .addFloat32Vec2('targetPosition.tween', {\n    components: ['targetPosition.duration', 'targetPosition.startTime'],\n})\n    .build();\n/**\n * Gets the typed offset for the given attribute\n */\nexport function edgeTypedOffset(attribute) {\n    return edgeMemoryLayout.get(attribute)?.typedOffset;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { EdgeImpl, AnimatableEdgeImpl } from './impl';\nimport { edgeMemoryLayout } from './layout';\nimport { ArrayStoreImpl, SlotAllocator, ReaderStoreImpl, } from '@graspologic/memstore';\n/**\n * @internal\n *\n * Returns a data buffer to keep track of Edges\n * @param capacity The initial capacity of the data buffer\n * @param engineTime Function to return the current engine time\n * @returns A data store capable of storing Edge objects\n */\nexport function createEdgeStore(config) {\n    const store = new ArrayStoreImpl(edgeMemoryLayout, config);\n    const slotAllocator = new SlotAllocator(\n    // We use the store capacity, cause it does some defaulting\n    store.config.capacity, \n    // If the user explicitly wanted capacity of 0,\n    // ignore the allocatedOnCreate and assume nothing is used\n    config?.capacity === 0 ? false : Boolean(config?.allocatedOnCreate));\n    const Impl = config?.animation !== false ? AnimatableEdgeImpl : EdgeImpl;\n    return new ReaderStoreImpl(Impl, store, slotAllocator);\n}\n","export {};\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './node';\nexport * from './edge';\nexport * from './types';\n","import { nodeTypedOffset } from '../layout';\nimport { NodeImpl } from './NodeImpl';\nimport { MemoryReaderInspector } from '@graspologic/memstore';\nconst allAttributes = '*';\nconst colorAttr = 'color';\nconst colorStartAttr = 'color.start';\nconst colorTweenAttr = 'color.tween';\nconst positionAttr = 'position';\nconst positionStartAttr = 'position.start';\nconst positionTweenAttr = 'position.tween';\n// For fast lookup\nconst positionTypedOffset = nodeTypedOffset(positionAttr);\nconst positionStartTypedOffset = nodeTypedOffset(positionStartAttr);\nconst positionTweenTypedOffset = nodeTypedOffset(positionTweenAttr);\nconst colorTypedOffset = nodeTypedOffset(colorAttr);\nconst colorStartTypedOffset = nodeTypedOffset(colorStartAttr);\nconst colorTweenTypedOffset = nodeTypedOffset(colorTweenAttr);\nconst inspector = new MemoryReaderInspector();\n/**\n * An implementation of a Node that has animation capabilities\n */\nclass AnimatableNodeImplInternal extends NodeImpl {\n    /**\n     * @inheritDoc\n     * @see {@link AnimatableNode.animatePosition}\n     */\n    animatePosition(position, duration = 0) {\n        // Set the start to the old position\n        inspector.copyFloat32Vec3Offset(this, positionTypedOffset, positionStartTypedOffset);\n        this.handleAttributeUpdated(positionStartAttr);\n        // Update the tween\n        inspector.writeFloat32Vec2Offset(this, positionTweenTypedOffset, duration, this.store?.engineTime || 0);\n        this.handleAttributeUpdated(positionTweenAttr);\n        // Update the end position\n        inspector.writeFloat32Vec3Offset(this, positionTypedOffset, position[0] || 0, position[1] || 0, position[2] || 0);\n        this.handleAttributeUpdated(positionAttr);\n    }\n    /**\n     * @inheritDoc\n     * @see {@link AnimatableNode.animateColor}\n     */\n    animateColor(color, duration = 0) {\n        // Set the start to the old color\n        inspector.copyUint32Offset(this, colorTypedOffset, colorStartTypedOffset);\n        this.handleAttributeUpdated(colorStartAttr);\n        // Update the tween\n        inspector.writeFloat32Vec2Offset(this, colorTweenTypedOffset, duration, this.store?.engineTime || 0);\n        this.handleAttributeUpdated(colorTweenAttr);\n        // Update the end color\n        inspector.writeUint32Offset(this, colorTypedOffset, color);\n        this.handleAttributeUpdated(colorAttr);\n    }\n    /**\n     * @inheritDoc\n     * @see {@link Node.load}\n     */\n    load(data) {\n        super.load(data);\n        this.handleAttributeUpdated(allAttributes);\n    }\n    /**\n     * Handler for when an attribute is updated\n     * @param name The name of the attribute\n     * @param value The value of the attribute\n     */\n    handleAttributeUpdated(name) {\n        if (this.store) {\n            this.store.notify(this.storeId, name);\n        }\n    }\n}\n/**\n * An implementation of a Node that has animation capabilities\n */\nexport const AnimatableNodeImpl = AnimatableNodeImplInternal;\n","import { Shape } from '../../types';\nimport { nodeMemoryLayout, nodeType, ADDITIONAL_NODE_PROPS } from '../layout';\nimport { createReader } from '@graspologic/memstore';\n// Cache some of the attributes for the \"load\"\nconst positionTypedOffset = nodeMemoryLayout.get('position').typedOffset;\nconst radiusTypedOffset = nodeMemoryLayout.get('radius').typedOffset;\nconst shapeTypedOffset = nodeMemoryLayout.get('shape').typedOffset;\nconst weightTypedOffset = nodeMemoryLayout.get('weight').typedOffset;\nconst colorTypedOffset = nodeMemoryLayout.get('color').typedOffset;\nconst visibleTypedOffset = nodeMemoryLayout.get('visible').typedOffset;\n/**\n * An implementation of a Node\n */\nconst BaseNodeImpl = createReader(nodeType, nodeMemoryLayout, ADDITIONAL_NODE_PROPS);\nexport class NodeImpl extends BaseNodeImpl {\n    /**\n     * @inheritDoc\n     * @see {@link Node.load}\n     */\n    load(data) {\n        ;\n        this.propertyBag = this.store.propertyBags[this.storeId] || {};\n        this.store.propertyBags[this.storeId] = this.propertyBag;\n        this.propertyBag.id = data.id;\n        this.propertyBag.group = data.group;\n        this.propertyBag.label = data.label;\n        this.float32Array[this.wordOffset + radiusTypedOffset] =\n            data.size || data.radius || 0;\n        this.float32Array[this.wordOffset + positionTypedOffset] = data.x || 0;\n        this.float32Array[this.wordOffset + positionTypedOffset + 1] = data.y || 0;\n        this.float32Array[this.wordOffset + positionTypedOffset + 2] = data.z || 0;\n        this.float32Array[this.wordOffset + weightTypedOffset] = data.weight || 1;\n        this.uint32Array[this.wordOffset + colorTypedOffset] = data.color || 0;\n        this.uint8Array[this.byteOffset + shapeTypedOffset] = parseShape(data.shape);\n        this.uint8Array[this.byteOffset + visibleTypedOffset] = 1;\n    }\n}\n/**\n * Parses a Shape from an unparsed shape value\n * @param unparsedShape\n */\nexport function parseShape(unparsedShape) {\n    if (typeof unparsedShape === 'string') {\n        unparsedShape = unparsedShape.toLocaleLowerCase();\n        if (unparsedShape === 'square') {\n            return Shape.Square;\n        }\n        else if (unparsedShape === 'diamond') {\n            return Shape.Diamond;\n        }\n    }\n    else if (unparsedShape === Shape.Square ||\n        unparsedShape === Shape.Diamond ||\n        unparsedShape === Shape.Circle) {\n        return unparsedShape;\n    }\n    return Shape.Circle;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './NodeImpl';\nexport * from './AnimatableNodeImpl';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './store';\nexport * from './types';\nexport * from './impl';\nexport * from './layout';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { createLayoutBuilder, InterpretationHint, AttributeType, } from '@graspologic/memstore';\n/**\n * The unique symbol for a node\n */\nexport const nodeType = Symbol('@graspologic::node');\n/**\n * @internal\n *\n * The set of additional node properties\n */\nexport const ADDITIONAL_NODE_PROPS = [\n    'id',\n    'group',\n    'label',\n    'data',\n    { name: 'mass', ephemeral: true, initialValue: 0 },\n    { name: 'dx', ephemeral: true, initialValue: 0 },\n    { name: 'dy', ephemeral: true, initialValue: 0 },\n    { name: 'old_dx', ephemeral: true, initialValue: 0 },\n    { name: 'old_dy', ephemeral: true, initialValue: 0 },\n    { name: 'convergence', ephemeral: true, initialValue: 1 },\n];\n/**\n * @internal\n *\n * The internal memory layout of a Node\n */\nexport const nodeMemoryLayout = createLayoutBuilder()\n    // Properties\n    .addFloat32('weight')\n    .addFloat32('radius', {\n    aliases: [{ name: 'size', type: AttributeType.Float32 }],\n})\n    .addUint8('fixed')\n    // Colors\n    .addUint32('color')\n    .addUint32('color.start')\n    .addFloat32Vec2('color.tween', {\n    components: ['color.duration', 'color.startTime'],\n})\n    // Position\n    .addFloat32Vec3('position', { components: ['x', 'y', 'z'] })\n    .addFloat32Vec3('position.start')\n    .addFloat32Vec2('position.tween', {\n    components: ['position.duration', 'position.startTime'],\n})\n    // Rendering Properties\n    .addFloat32('saturation')\n    .addUint8('shape')\n    .addUint8('visible', { hint: InterpretationHint.Boolean })\n    .addUint8Vec3('pickingColor')\n    .build();\n/**\n * Gets the typed offset for the given attribute\n */\nexport function nodeTypedOffset(attribute) {\n    return nodeMemoryLayout.get(attribute)?.typedOffset;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { NodeImpl, AnimatableNodeImpl } from './impl';\nimport { nodeMemoryLayout } from './layout';\nimport { ArrayStoreImpl, SlotAllocator, ReaderStoreImpl, } from '@graspologic/memstore';\n/**\n * @internal\n *\n * Returns a data buffer to keep track of Nodes\n * @param capacity The initial capacity of the data buffer\n * @param engineTime Function to return the current engine time\n * @returns A data store capable of storing Node objects\n */\nexport function createNodeStore(config) {\n    const store = new ArrayStoreImpl(nodeMemoryLayout, config);\n    const slotAllocator = new SlotAllocator(\n    // We use the store capacity, cause it does some defaulting\n    store.config.capacity, \n    // If the user explicitly wanted capacity of 0,\n    // ignore the allocatedOnCreate and assume nothing is used\n    config?.capacity === 0 ? false : Boolean(config?.allocatedOnCreate));\n    const Impl = config?.animation !== false ? AnimatableNodeImpl : NodeImpl;\n    return new ReaderStoreImpl(Impl, store, slotAllocator);\n}\n","export {};\n","/**\n * The shape of an object\n */\nexport var Shape;\n(function (Shape) {\n    Shape[Shape[\"Circle\"] = 0] = \"Circle\";\n    Shape[Shape[\"Square\"] = 1] = \"Square\";\n    Shape[Shape[\"Diamond\"] = 2] = \"Diamond\";\n})(Shape || (Shape = {}));\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { jiggle } from '../helpers';\n/**\n * @internal\n *\n * An implementation of a quad tree\n */\nexport class QuadTree {\n    /**\n     * Constructor for QuadTree\n     * @param nodes The nodes in the tree\n     * @param level The level of this quad tree\n     */\n    constructor(nodes, level = 0) {\n        this.mass = 0;\n        /**\n         * Center of mass X\n         */\n        this.cx = 0;\n        /**\n         * Center of mass Y\n         */\n        this.cy = 0;\n        this.x0 = Number.POSITIVE_INFINITY;\n        this.x1 = Number.NEGATIVE_INFINITY;\n        this.y0 = Number.POSITIVE_INFINITY;\n        this.y1 = Number.NEGATIVE_INFINITY;\n        this.level = level;\n        let node;\n        let prevNode;\n        let newMass;\n        let numNodes = 0;\n        for (node of nodes) {\n            numNodes++;\n            // jiggle nodes if they are co-located\n            if (prevNode?.x === node.x && prevNode?.y === node.y) {\n                node.x += jiggle(1e-3);\n                node.y += jiggle(1e-3);\n            }\n            // Update center of mass\n            newMass = node.mass + this.mass;\n            this.cx = (node.x * node.mass + this.cx * this.mass) / newMass;\n            this.cy = (node.y * node.mass + this.cy * this.mass) / newMass;\n            this.mass = newMass;\n            // Update bounds\n            this.x0 = Math.min(this.x0, node.x);\n            this.x1 = Math.max(this.x1, node.x);\n            this.y0 = Math.min(this.y0, node.y);\n            this.y1 = Math.max(this.y1, node.y);\n            prevNode = node;\n        }\n        if (numNodes === 0) {\n            throw new Error('there should be at least one node in a QuadTree node');\n        }\n        else if (numNodes === 1) {\n            this.node = nodes[0];\n        }\n        else {\n            const nwChildren = [];\n            const neChildren = [];\n            const swChildren = [];\n            const seChildren = [];\n            for (node of nodes) {\n                if (node.y > this.cy) {\n                    if (node.x > this.cx) {\n                        neChildren.push(node);\n                    }\n                    else {\n                        nwChildren.push(node);\n                    }\n                }\n                else {\n                    if (node.x > this.cx) {\n                        seChildren.push(node);\n                    }\n                    else {\n                        swChildren.push(node);\n                    }\n                }\n            }\n            if (neChildren.length > 0) {\n                this.neChild = new QuadTree(neChildren, this.level + 1);\n            }\n            if (nwChildren.length > 0) {\n                this.nwChild = new QuadTree(nwChildren, this.level + 1);\n            }\n            if (seChildren.length > 0) {\n                this.seChild = new QuadTree(seChildren, this.level + 1);\n            }\n            if (swChildren.length > 0) {\n                this.swChild = new QuadTree(swChildren, this.level + 1);\n            }\n        }\n    }\n    /**\n     * Gets the depth of this quad tree\n     * @returns The depth\n     */\n    get depth() {\n        if (this.isLeaf) {\n            return 0;\n        }\n        else {\n            return (1 +\n                Math.max(this.nwChild ? this.nwChild.depth : 0, this.neChild ? this.neChild.depth : 0, this.swChild ? this.swChild.depth : 0, this.seChild ? this.seChild.depth : 0));\n        }\n    }\n    /**\n     * Gets the size of the quad tree\n     */\n    get size() {\n        return (this.x1 - this.x0) / 2;\n    }\n    /**\n     * True if the quad tree is a leaf\n     */\n    get isLeaf() {\n        return !this.nwChild && !this.neChild && !this.swChild && !this.seChild;\n    }\n    /**\n     * Applies a visitor to the quad tree\n     * @param callback The visitor\n     */\n    visit(callback) {\n        const queue = [this];\n        while (queue.length > 0) {\n            const qt = queue.pop();\n            const halt = callback(qt);\n            if (!halt) {\n                if (qt.nwChild) {\n                    queue.push(qt.nwChild);\n                }\n                if (qt.neChild) {\n                    queue.push(qt.neChild);\n                }\n                if (qt.swChild) {\n                    queue.push(qt.swChild);\n                }\n                if (qt.seChild) {\n                    queue.push(qt.seChild);\n                }\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './measure';\nexport * from './types';\nexport * from './QuadTree';\n","/**\n * @internal\n *\n * Computes the square distance between the two points\n * @param pos1 The first position\n * @param pos2 The second position\n * @returns The square distance\n */\nexport function squareDistanceTo(pos1, pos2) {\n    const dx = pos2.x - pos1.x;\n    const dy = pos2.y - pos1.y;\n    return dx ** 2 + dy ** 2;\n}\n/**\n * @internal\n *\n * Computes the euclidean distance between the two points\n * @param pos1 The first position\n * @param pos2 The second position\n * @returns The distance\n */\nexport function distanceTo(pos1, pos2) {\n    return Math.sqrt(squareDistanceTo(pos1, pos2));\n}\n/**\n * @internal\n * Computes the the weighted center of the given positions, using the given weights\n * @param points The list of points\n * @param weights The list of weights\n * @returns The weighted centroid\n */\nexport function weightedCentroid(points, weights) {\n    if (points.length === 0) {\n        throw new Error('could not compute centroid out of zero points');\n    }\n    if (points.length !== weights.length) {\n        throw new Error('points array and weights array must be the same length');\n    }\n    let xSum = 0.0;\n    let ySum = 0.0;\n    let totalWeight = 0.0;\n    points.forEach((point, index) => {\n        const weight = weights[index];\n        totalWeight += weight;\n        xSum += point.x * weight;\n        ySum += point.y * weight;\n    });\n    const x = xSum / totalWeight;\n    const y = ySum / totalWeight;\n    return { x, y };\n}\n","export {};\n","/**\n * @internal\n *\n * An implementation of a clock which will tick until it reaches a target tick count\n */\nexport class CountdownClock {\n    /**\n     * Constructor for the countdown clock\n     * @param targetTicks The target number of ticks to run\n     */\n    constructor(targetTicks) {\n        this._ticks = 0;\n        this._targetTicks = targetTicks;\n    }\n    /**\n     * Gets the current ticks\n     */\n    get currentTicks() {\n        return this._ticks;\n    }\n    /**\n     * Gets the target ticks\n     */\n    get targetTicks() {\n        return this._targetTicks;\n    }\n    /**\n     * Ticks the current clock\n     */\n    tick() {\n        this._ticks++;\n        return this._ticks < this._targetTicks;\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './CountdownClock';\nexport * from './types';\n","export {};\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './workers';\nexport * from './layout';\nexport * from './clock';\n","import { EventEmitter } from '@graspologic/common';\n/**\n * @internal\n *\n * Base class for layout executors\n */\nexport class BaseExecutor extends EventEmitter {\n    /**\n     * Constructor for the base executor\n     * @param graph The graph to run the layout on\n     * @param config The configuration for the layout\n     * @param clock The clock which is used to indicate when a layout cycle has occurred\n     * @param globalObject The \"global\" object environment\n     */\n    constructor(graph, config, clock, globalObject) {\n        super();\n        this._halted = false;\n        this._complete = false;\n        this._clock = clock;\n        this._graph = graph;\n        this._global = globalObject;\n        this._configuration = config;\n        this.executeStep = this.executeStep.bind(this);\n        globalObject.console.log(`create new ${this.getName()} instance`, this._configuration);\n    }\n    /**\n     * Halts the layout process\n     */\n    halt() {\n        this._halted = true;\n    }\n    /**\n     * Returns true if the layout is halted\n     */\n    get isHalted() {\n        return this._halted;\n    }\n    /**\n     * Returns true if the layout is completed\n     */\n    get isComplete() {\n        return this._complete;\n    }\n    /**\n     * Gets the current clock\n     */\n    get clock() {\n        return this._clock;\n    }\n    /**\n     * Gets the current graph\n     */\n    get graph() {\n        return this._graph;\n    }\n    /**\n     * Gets the current global object\n     */\n    get globalObject() {\n        return this._global;\n    }\n    /**\n     * Gets the current configuration\n     */\n    get configuration() {\n        return this._configuration;\n    }\n    /**\n     * Configures the executor\n     * @param config The layout config\n     */\n    configure(config) {\n        this._configuration = { ...this.defaultConfiguration, ...config };\n    }\n    /**\n     * Executes the layout process\n     */\n    execute() {\n        this._global.console.log(`execute ${this.getName()}, %s nodes, %s edges`, this.graph.nodes.count, this.graph.edges.count);\n        this._halted = false;\n        this._complete = false;\n        this.clearTickListener();\n        return new Promise(resolve => {\n            this.executeStep();\n            this._tickListener = this.on('tick', () => {\n                if (this._complete) {\n                    resolve(this.getProgress());\n                    this.clearTickListener();\n                }\n            });\n        });\n    }\n    /**\n     * Clears the tick listener\n     */\n    clearTickListener() {\n        if (this._tickListener) {\n            this._tickListener();\n            this._tickListener = undefined;\n        }\n    }\n    /**\n     * Executes one step of the layout algorithm\n     */\n    executeStep() {\n        this.performUnitOfWork();\n        // Advance the annealing clock\n        const ticking = this._clock.tick();\n        if (!ticking) {\n            this._complete = true;\n        }\n        // Perform the next layout step on the event queue\n        if (ticking && !this._halted) {\n            this._global.setTimeout(this.executeStep, 0);\n        }\n        // Emit the tick event\n        this.emit('tick', this.getProgress());\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './BaseExecutor';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { WorkerMessageType, } from './types';\nimport { EventEmitter } from '@graspologic/common';\n/**\n * A manager class for using webworker-based layout execution\n */\nexport class LayoutWorkerManager extends EventEmitter {\n    /**\n     * Constructor for the LayoutWorkerManager\n     * @param createWorker A callback for instantiating the worker\n     */\n    constructor(createWorker) {\n        super();\n        this._configuration = {};\n        this._createWorker = createWorker;\n    }\n    /**\n     * Configures the layout worker\n     * @param configuration The configuration options for the layout worker\n     */\n    configure(configuration) {\n        this._configuration = configuration;\n    }\n    /**\n     * Performs the layout on the given graph\n     * @param graph The graph to perform the layout on\n     * @returns A promise for when the layout is completed\n     */\n    layout(graph) {\n        this._worker = this._createWorker();\n        // Listen for completion\n        const result = new Promise((resolve, reject) => {\n            this._worker.onmessage = ev => {\n                const { type, payload } = ev.data;\n                if (type === WorkerMessageType.Progress) {\n                    this.emit('progress', payload);\n                }\n                else if (type === WorkerMessageType.Complete) {\n                    this.reset();\n                    resolve(payload);\n                }\n                else if (type === WorkerMessageType.Error) {\n                    this.reset();\n                    reject(payload);\n                }\n            };\n        });\n        // kick off the layout\n        this.sendMessage(WorkerMessageType.Execute, {\n            graph: graph.serialize(),\n            configuration: this._configuration,\n        });\n        return result;\n    }\n    /**\n     * Resets the layout worker to it's initial state\n     */\n    reset() {\n        if (this._worker) {\n            this._worker.terminate();\n            this._worker = undefined;\n        }\n    }\n    /**\n     * Stops the current layout process\n     */\n    halt() {\n        this.sendMessage(WorkerMessageType.Halt);\n    }\n    /**\n     * Resumes the current layout process\n     */\n    resume() {\n        this.sendMessage(WorkerMessageType.Resume);\n    }\n    /**\n     * Sends a message to the layout worker\n     * @param type The message type\n     * @param payload The payload\n     * @param share The data to share\n     */\n    sendMessage(type, payload, share) {\n        if (this._worker) {\n            this._worker.postMessage({\n                type,\n                payload,\n            }, share || []);\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './LayoutWorkerManager';\nexport * from './workerFactory';\nexport * from './types';\n","/**\n * @internal\n *\n * The type of message for Manager <-> Worker communication\n */\nexport var WorkerMessageType;\n(function (WorkerMessageType) {\n    // Manager -> Worker\n    /**\n     * Tells the worker to configure itself\n     */\n    WorkerMessageType[\"Configure\"] = \"CONFIGURE\";\n    /**\n     * Tells the worker to execute the layout\n     */\n    WorkerMessageType[\"Execute\"] = \"EXECUTE\";\n    /**\n     * Tells the worker to halt layout\n     */\n    WorkerMessageType[\"Halt\"] = \"HALT\";\n    /**\n     * Tells the worker to resume layout\n     */\n    WorkerMessageType[\"Resume\"] = \"RESUME\";\n    /**\n     * Tells the worker to reset it's to the initial state\n     */\n    WorkerMessageType[\"Reset\"] = \"RESET\";\n    // Worker -> Manager\n    /**\n     * Tells the manager that the worker experienced an error\n     */\n    WorkerMessageType[\"Error\"] = \"ERROR\";\n    /**\n     * Tells the manager that progress has occurred on the graph layout\n     */\n    WorkerMessageType[\"Progress\"] = \"PROGRESS\";\n    /**\n     * Tells the manager that the worker has completed layout of the graph\n     */\n    WorkerMessageType[\"Complete\"] = \"COMPLETE\";\n})(WorkerMessageType || (WorkerMessageType = {}));\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport function workerFactoryFromScript(workerScript) {\n    const blob = new Blob([workerScript], { type: 'text/javascript' });\n    const blobUrl = window.URL.createObjectURL(blob);\n    return () => new Worker(blobUrl);\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { AnnealingPhase } from './types';\n/**\n * @internal\n *\n * A type of clock that uses simulated annealing through several phases\n */\nexport class AnnealingClock {\n    constructor(edgeCut = 0.8, schedule = {}) {\n        this._phase = AnnealingPhase.Initial;\n        this._iteration = 0;\n        this._phaseIteration = 0;\n        // annealing state\n        this._temperature = 0;\n        this._attraction = 0;\n        this._damping = 0;\n        // establish the schedule\n        this._schedule = { ...DEFAULT_SCHEDULE, ...schedule };\n        this._targetIterations = Object.values(this._schedule)\n            .map(v => v.iterations)\n            .reduce((prev, curr) => prev + curr, 0);\n        // Taken from the python init_params method\n        this._minEdges = 20.000001;\n        this._cutEnd = 40000.0 * (1.0 - edgeCut);\n        this._cutLengthEnd = this._cutEnd < 1 ? 1 : this._cutEnd;\n        this._cutLengthStart = 4.0 * this._cutLengthEnd;\n        this._cutOffLength = this._cutLengthStart;\n        this._cutRate = (this._cutLengthStart - this._cutLengthEnd) / 400;\n        this.schedulePhase(AnnealingPhase.Initial);\n    }\n    /**\n     * Gets the current phase\n     */\n    get phase() {\n        return this._phase;\n    }\n    /**\n     * Determines if annealing is complete\n     */\n    get isComplete() {\n        return this._phase === AnnealingPhase.Complete;\n    }\n    /**\n     * Gets the current iteration\n     */\n    get iteration() {\n        return this._iteration;\n    }\n    /**\n     * Gets the current phase iteration\n     */\n    get phaseIteration() {\n        return this._phaseIteration;\n    }\n    /**\n     * Gets the target phase iterations\n     */\n    get targetPhaseIterations() {\n        return this.phase != null ? this.schedule[this.phase].iterations : 0;\n    }\n    /**\n     * Gets the target number of iterations\n     */\n    get targetIterations() {\n        return this._targetIterations;\n    }\n    get attraction() {\n        return this._attraction;\n    }\n    get temperature() {\n        return this._temperature;\n    }\n    get damping() {\n        return this._damping;\n    }\n    get minEdges() {\n        return this._minEdges;\n    }\n    /**\n     * Gets the annealing schedule\n     */\n    get schedule() {\n        return this._schedule;\n    }\n    get cutEnd() {\n        return this._cutEnd;\n    }\n    get cutOffLength() {\n        return this._cutOffLength;\n    }\n    get neighborCutsEnabled() {\n        switch (this.phase) {\n            case AnnealingPhase.Liquid:\n            case AnnealingPhase.Expansion:\n            case AnnealingPhase.Cooldown:\n            case AnnealingPhase.Crunch:\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Runs an annealing iteration\n     * @returns True if an iteration was run\n     */\n    tick() {\n        if (this.isComplete) {\n            return false;\n        }\n        else {\n            this._iteration += 1;\n            this._phaseIteration += 1;\n            if (this.phaseIteration >= this.targetPhaseIterations) {\n                this.handlePhaseComplete();\n            }\n            else {\n                this.handlePhaseTick();\n            }\n            return true;\n        }\n    }\n    /**\n     * Handler for when a tick occurs\n     */\n    handlePhaseTick() {\n        if (this.phase === AnnealingPhase.Expansion) {\n            this._cutLengthEnd -= this._cutRate;\n            if (this.attraction > 1.0) {\n                this._attraction -= 0.05;\n            }\n            if (this.minEdges > 12.0) {\n                this._minEdges -= 0.05;\n            }\n            if (this.damping > 0.1) {\n                this._damping -= 0.005;\n            }\n        }\n        else if (this.phase === AnnealingPhase.Cooldown) {\n            if (this.temperature > 50.0) {\n                this._temperature -= 10.0;\n            }\n            if (this._cutOffLength > this._cutLengthEnd) {\n                this._cutOffLength -= this._cutRate * 2.0;\n            }\n            if (this.minEdges > 1.0) {\n                this._minEdges -= 0.2;\n            }\n        }\n    }\n    /**\n     * Handler for when a phase has completed\n     */\n    handlePhaseComplete() {\n        this._phaseIteration = 0;\n        if (this.phase === AnnealingPhase.Initial) {\n            return this.schedulePhase(AnnealingPhase.Liquid);\n        }\n        else if (this.phase === AnnealingPhase.Liquid) {\n            return this.schedulePhase(AnnealingPhase.Expansion);\n        }\n        else if (this.phase === AnnealingPhase.Expansion) {\n            this._minEdges = 12.0000000001;\n            return this.schedulePhase(AnnealingPhase.Cooldown);\n        }\n        else if (this.phase === AnnealingPhase.Cooldown) {\n            this._minEdges = 1.0 + 0.00000000000001;\n            this._cutOffLength = this._cutLengthEnd;\n            return this.schedulePhase(AnnealingPhase.Crunch);\n        }\n        else if (this.phase === AnnealingPhase.Crunch) {\n            // TODO REMOVE, this is functionally eliminated\n            this._minEdges = 99.0;\n            return this.schedulePhase(AnnealingPhase.Simmer);\n        }\n        else if (this.phase === AnnealingPhase.Simmer) {\n            return this.schedulePhase(AnnealingPhase.Complete);\n        }\n    }\n    /**\n     * Schedules __phase__ to run on the next iteration\n     * @param phase The phase to schedule\n     */\n    schedulePhase(phase) {\n        this._phase = phase;\n        if (this.schedule[phase]?.iterations > 0) {\n            this._temperature = this.schedule[phase].temperature;\n            this._attraction = this.schedule[phase].attraction;\n            this._damping = this.schedule[phase].damping;\n        }\n        else {\n            if (phase === AnnealingPhase.Initial) {\n                this.schedulePhase(AnnealingPhase.Liquid);\n            }\n            else if (phase === AnnealingPhase.Liquid) {\n                this.schedulePhase(AnnealingPhase.Expansion);\n            }\n            else if (phase === AnnealingPhase.Cooldown) {\n                this.schedulePhase(AnnealingPhase.Crunch);\n            }\n            else if (phase === AnnealingPhase.Crunch) {\n                this.schedulePhase(AnnealingPhase.Simmer);\n            }\n            else if (phase === AnnealingPhase.Simmer) {\n                this._phase = AnnealingPhase.Complete;\n            }\n        }\n    }\n    get energyDistancePower() {\n        switch (this.phase) {\n            case AnnealingPhase.Liquid:\n                return 4;\n            case AnnealingPhase.Expansion:\n                return 2;\n            default:\n                return 1;\n        }\n    }\n    get useFineDensity() {\n        return this.phase === AnnealingPhase.Simmer;\n    }\n}\n/**\n * @internal\n *\n * The default schedule used during layout\n */\nconst DEFAULT_SCHEDULE = {\n    [AnnealingPhase.Initial]: {\n        iterations: 1,\n        temperature: 2000,\n        attraction: 10,\n        damping: 1,\n    },\n    [AnnealingPhase.Liquid]: {\n        iterations: 200,\n        temperature: 2000,\n        attraction: 2,\n        damping: 1,\n    },\n    [AnnealingPhase.Expansion]: {\n        iterations: 200,\n        temperature: 2000,\n        attraction: 10,\n        damping: 1,\n    },\n    [AnnealingPhase.Cooldown]: {\n        iterations: 200,\n        temperature: 2000,\n        attraction: 1,\n        damping: 0.1,\n    },\n    [AnnealingPhase.Crunch]: {\n        iterations: 50,\n        temperature: 250,\n        attraction: 1.0,\n        damping: 0.25,\n    },\n    [AnnealingPhase.Simmer]: {\n        iterations: 100,\n        temperature: 250,\n        attraction: 0.5,\n        damping: 0,\n    },\n    [AnnealingPhase.Complete]: {\n        iterations: 0,\n        temperature: 0,\n        attraction: 0,\n        damping: 0,\n    },\n};\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { distanceTo, squareDistanceTo, } from '@graspologic/graph';\nexport const GRID_SIZE = 1000;\nexport const RADIUS = 10;\nexport const DIAMETER = 2 * RADIUS;\nexport const FALLOFF = getInitialFalloffStructure();\n/**\n * @internal\n *\n * A node density grid to track the density of nodes in a grid pattern\n */\nexport class DensityGrid {\n    constructor() {\n        this.initialLoad = true;\n        this._bitmap = getInitialDensityBitmap();\n        this._bins = getInitialDensityBins();\n        this._trackedNodes = new Set();\n    }\n    /**\n     * Determines whether the given node is in the denisty grid\n     * @param id The node id\n     */\n    contains(node) {\n        return this._trackedNodes.has(node.storeId);\n    }\n    /**\n     * Gets the number of tracked nodes in the grid\n     */\n    get size() {\n        return this._trackedNodes.size;\n    }\n    /**\n     * Gets the density bitmap\n     */\n    get bitmap() {\n        return this._bitmap;\n    }\n    get checksum() {\n        let result = 0;\n        for (let i = 0; i < GRID_SIZE; ++i) {\n            for (let j = 0; j < GRID_SIZE; ++j) {\n                result += this._bitmap[i][j];\n            }\n        }\n        return result;\n    }\n    /**\n     * Adds a node to the density grid\n     * @param node The node to add to the density grid\n     */\n    add(node) {\n        if (this.contains(node)) {\n            throw new Error(`cannot add node ${node.storeId} to density grid twice`);\n        }\n        this._trackedNodes.add(node.storeId);\n        this.addToBins(node);\n        this.addToBitmap(node);\n    }\n    /**\n     * Subtracts a node from the density grid\n     */\n    subtract(node) {\n        if (!this.contains(node)) {\n            throw new Error(`cannot remove node ${node.storeId}from density grid`);\n        }\n        this._trackedNodes.delete(node.storeId);\n        this.subtractFromBitmap(node);\n        this.subtractFromBins(node);\n    }\n    addToBitmap(node) {\n        const xGrid = gridIndex(node.x) - RADIUS;\n        const yGrid = gridIndex(node.y) - RADIUS;\n        for (let i = 0; i <= DIAMETER; ++i) {\n            for (let j = 0; j <= DIAMETER; ++j) {\n                const xIndex = xGrid + j;\n                const yIndex = yGrid + i;\n                if (isValidIndex(xIndex, yIndex)) {\n                    this._bitmap[yIndex][xIndex] += FALLOFF[i][j];\n                }\n            }\n        }\n    }\n    subtractFromBitmap(node) {\n        const xGrid = gridIndex(node.x) - RADIUS;\n        const yGrid = gridIndex(node.y) - RADIUS;\n        for (let i = 0; i <= DIAMETER; ++i) {\n            for (let j = 0; j <= DIAMETER; ++j) {\n                const xIndex = xGrid + j;\n                const yIndex = yGrid + i;\n                if (isValidIndex(xIndex, yIndex)) {\n                    this.bitmap[yIndex][xIndex] -= FALLOFF[i][j];\n                }\n            }\n        }\n    }\n    addToBins(node) {\n        const xGrid = gridIndex(node.x);\n        const yGrid = gridIndex(node.y);\n        verifyGridIndices(xGrid, yGrid);\n        const bin = this._bins[yGrid][xGrid];\n        bin[node.storeId] = node;\n    }\n    subtractFromBins(node) {\n        const xGrid = gridIndex(node.x);\n        const yGrid = gridIndex(node.y);\n        verifyGridIndices(xGrid, yGrid);\n        const bin = this._bins[yGrid][xGrid];\n        if (bin[node.storeId]) {\n            delete bin[node.storeId];\n        }\n    }\n    // gets the density at a given position excluding the given node's contribution.\n    // the node must be inserted into the denisty grid\n    getDensity(node, testPosition, fine = false) {\n        const INFINITE_DENSITY = 10000.0;\n        if (Number.isNaN(testPosition.x) || Number.isNaN(testPosition.y)) {\n            throw new Error('test position has NaN component');\n        }\n        else if (!isQueryInBounds(testPosition)) {\n            return INFINITE_DENSITY;\n        }\n        else if (fine) {\n            return this.getFineDensity(node, testPosition);\n        }\n        else {\n            return this.getCoarseDensity(node, testPosition);\n        }\n    }\n    getFineDensity(node, position) {\n        const xGrid = gridIndex(position.x);\n        const yGrid = gridIndex(position.y);\n        let density = 0.0;\n        let i;\n        let j;\n        let id;\n        for (i = yGrid - 1; i <= yGrid + 1; ++i) {\n            for (j = xGrid - 1; j <= xGrid + 1; ++j) {\n                const bin = this._bins[i][j];\n                for (id of Object.keys(bin)) {\n                    // exclude the current id so we don't have to do removals before density checks\n                    // This allows the density grid to be read-only in the update phase\n                    if (parseInt(id, 10) !== node.storeId) {\n                        const binItemPos = bin[id];\n                        const distance = squareDistanceTo(position, binItemPos);\n                        density += 1e-4 / (distance + 1e-50);\n                    }\n                }\n            }\n        }\n        return density;\n    }\n    getOverlap(node, position) {\n        const xGrid = gridIndex(position.x);\n        const yGrid = gridIndex(position.y);\n        let overlap = 0.0;\n        let i;\n        let j;\n        let id;\n        for (i = yGrid - 1; i <= yGrid + 1; ++i) {\n            for (j = xGrid - 1; j <= xGrid + 1; ++j) {\n                const bin = this._bins[i][j];\n                for (id of Object.keys(bin)) {\n                    // exclude the current id so we don't have to do removals before density checks\n                    // This allows the density grid to be read-only in the update phase\n                    if (parseInt(id, 10) !== node.storeId) {\n                        const other = bin[id];\n                        const distance = distanceTo(position, other);\n                        const nodeEdgeDistance = distance - node.size - other.size;\n                        if (nodeEdgeDistance < 0) {\n                            overlap += Math.abs(nodeEdgeDistance);\n                        }\n                    }\n                }\n            }\n        }\n        return overlap;\n    }\n    getCoarseDensity(node, position) {\n        const xGrid = gridIndex(position.x);\n        const yGrid = gridIndex(position.y);\n        // Ignore the splash density of the node value\n        const ignorable = this.getDensityToExcludeAtPoint(node, position);\n        const gridValue = this._bitmap[yGrid][xGrid];\n        const density = gridValue - ignorable;\n        return density ** 2;\n    }\n    // density queries ignore the density of the node being moved. This calculates the density value\n    // to ignore\n    getDensityToExcludeAtPoint(node, position) {\n        const nxGrid = gridIndex(node.x);\n        const nyGrid = gridIndex(node.y);\n        const xGrid = gridIndex(position.x);\n        const yGrid = gridIndex(position.y);\n        const xDist = xGrid - nxGrid;\n        const yDist = yGrid - nyGrid;\n        const isNodeApplicable = !this.initialLoad &&\n            this.contains(node) &&\n            Math.abs(xDist) < RADIUS &&\n            Math.abs(yDist) < RADIUS;\n        return isNodeApplicable\n            ? FALLOFF[Math.floor(RADIUS + yDist)][Math.floor(RADIUS + xDist)]\n            : 0.0;\n    }\n}\n/**\n * Gets the initial density bitmap to use\n */\nfunction getInitialDensityBitmap() {\n    const result = [];\n    // Set up a density grid of zero-values and empty bins for each grid cell\n    for (let i = 0; i < GRID_SIZE; ++i) {\n        const row = new Float32Array(GRID_SIZE);\n        result.push(row);\n        for (let j = 0; j < GRID_SIZE; ++j) {\n            row[j] = 0;\n        }\n    }\n    return result;\n}\n/**\n * Gets the initial density bins to use\n */\nfunction getInitialDensityBins() {\n    const result = [];\n    // Set up a density grid of zero-values and empty bins for each grid cell\n    for (let i = 0; i < GRID_SIZE; ++i) {\n        const row = [];\n        result.push(row);\n        for (let j = 0; j < GRID_SIZE; ++j) {\n            row.push({});\n        }\n    }\n    return result;\n}\n/**\n * gets the falloff structure to use for density insertion\n */\nfunction getInitialFalloffStructure() {\n    const result = [];\n    for (let i = -RADIUS; i <= RADIUS; ++i) {\n        result[i + RADIUS] = [];\n        for (let j = -RADIUS; j <= RADIUS; ++j) {\n            const radius = RADIUS;\n            const iAbs = Math.abs(i);\n            const jAbs = Math.abs(j);\n            const iFac = (radius - iAbs) / radius;\n            const jFac = (radius - jAbs) / radius;\n            const falloffValue = iFac * jFac;\n            result[i + RADIUS][j + RADIUS] = falloffValue;\n        }\n    }\n    return result;\n}\nfunction gridIndex(value) {\n    const viewToGrid = 0.25;\n    const halfView = GRID_SIZE * 2.0;\n    const result = Math.floor((value + halfView + 0.5) * viewToGrid);\n    return Math.max(0, Math.min(result, GRID_SIZE - 1));\n}\nfunction verifyGridIndices(xGrid, yGrid) {\n    if (xGrid >= GRID_SIZE || yGrid >= GRID_SIZE) {\n        throw new Error(`invalid grid storeId: (${xGrid}, ${yGrid})`);\n    }\n}\nfunction isQueryInBounds(position) {\n    const boundary = 10;\n    const xGrid = gridIndex(position.x);\n    const yGrid = gridIndex(position.y);\n    const isOutOfBounds = (idx) => idx > GRID_SIZE - boundary || idx < boundary;\n    return !isOutOfBounds(xGrid) && !isOutOfBounds(yGrid);\n}\nfunction isValidIndex(xIndex, yIndex) {\n    return yIndex >= 0 && xIndex >= 0 && yIndex < GRID_SIZE && xIndex < GRID_SIZE;\n}\n","import { jumpTowards, jumpRandom } from './jumps';\nimport { sampleBitmap } from './sampleBitmap';\nimport { NodeUpdateKind, AnnealingPhase, DEFAULT_CONFIGURATION, } from './types';\nimport { squareDistanceTo, randBetween, } from '@graspologic/graph';\nimport { BaseExecutor } from '@graspologic/layout-core';\n/**\n * @internal\n *\n * A layout executor which will run the OpenOrd layout on a graph\n */\nexport class OpenOrdLayoutExecutor extends BaseExecutor {\n    /**\n     * Constructor for the OpenOrdLayoutExecutor\n     * @param graph The graph to layout\n     * @param configuration The configuration for the algorithm\n     * @param clock The annealing clock which controls how long phases are run\n     * @param globalObject The global object\n     * @param densityGrid The node density grid\n     */\n    constructor(graph, configuration, clock, globalObject, densityGrid) {\n        super(graph, configuration, clock, globalObject);\n        this._densityGrid = densityGrid;\n        // Randomize the graph layout if it's zeroed out\n        let isZeroed = true;\n        let node;\n        // Randomize the graph layout if it's zeroed out\n        for (node of this.graph.nodes) {\n            if (node.x !== 0 || node.y !== 0) {\n                isZeroed = false;\n                break;\n            }\n        }\n        if (isZeroed) {\n            this.globalObject.console.log('randomizing layouts');\n            for (node of this.graph.nodes) {\n                node.x = randBetween(0, 1024);\n                node.y = randBetween(0, 1024);\n            }\n        }\n        this.initializeDensityGrid();\n    }\n    /**\n     * Gets the name of the layout algorithm\n     */\n    getName() {\n        return 'OpenOrd';\n    }\n    /**\n     * Gets the density grid\n     */\n    get densityGrid() {\n        return this._densityGrid;\n    }\n    /**\n     * Gets the default configuration\n     */\n    get defaultConfiguration() {\n        return DEFAULT_CONFIGURATION;\n    }\n    /**\n     * Constructs the tick progress object\n     */\n    getProgress() {\n        const { phase, iteration, phaseIteration, targetPhaseIterations, targetIterations, } = this.clock;\n        const { emitDensitySnapshots, densitySnapshotSamplingRate, densitySnapshotEmitRate, emitEnergy, emitObjectiveEnergy, } = this.configuration;\n        const result = {\n            clock: {\n                phase,\n                iteration,\n                phaseIteration,\n                targetIterations,\n                targetPhaseIterations,\n            },\n            densityGrid: {},\n            metrics: {},\n        };\n        if (emitDensitySnapshots) {\n            if (densitySnapshotEmitRate == null ||\n                this.clock.iteration % densitySnapshotEmitRate === 0) {\n                result.densityGrid.bitmap = sampleBitmap(this.densityGrid, densitySnapshotSamplingRate);\n            }\n        }\n        if (emitEnergy) {\n            const energy = this.energy;\n            result.metrics.energy = energy;\n        }\n        if (emitObjectiveEnergy) {\n            const [objectiveEnergy, attractiveEnergy, repulsiveEnergy, overlapEnergy,] = this.objectiveEnergy;\n            result.metrics.objectiveEnergy = objectiveEnergy;\n            result.metrics.attractiveEnergy = attractiveEnergy;\n            result.metrics.repulsiveEnergy = repulsiveEnergy;\n            result.metrics.overlapEnergy = overlapEnergy;\n        }\n        return result;\n    }\n    /**\n     * Performs a single unit of work\n     */\n    performUnitOfWork() {\n        if (this.configuration.iterativeForceModel) {\n            this.performIterativeUnitOfWork();\n        }\n        else {\n            this.performConcurrentUnitOfWork();\n        }\n    }\n    /**\n     * Initializes the internal density grid\n     */\n    initializeDensityGrid() {\n        let node;\n        for (node of this.graph.nodes) {\n            this.densityGrid.add(node);\n        }\n    }\n    /**\n     * perform the unit of work (layout step) with a concurrent force model - updates are applied after they have all been computed\n     */\n    performConcurrentUnitOfWork() {\n        let node;\n        for (node of this.graph.nodes) {\n            const update = this.computeNodeUpdate(node);\n            this.applyUpdate(update);\n        }\n    }\n    /**\n     * perform the unit of work (layout step) with a iterative force model - updates are applied in series\n     */\n    performIterativeUnitOfWork() {\n        let update;\n        for (update of this.computeIterativeUpdates()) {\n            this.applyUpdate(update);\n        }\n    }\n    /**\n     * This is a generator so that we can either resolve the updates iteratively using\n     * a stochastic gradient descent method, or all at the same time using a force modeling\n     * approach\n     * @returns The updates for each of the nodes\n     */\n    *computeIterativeUpdates() {\n        let node;\n        for (node of this.graph.nodes) {\n            yield this.computeNodeUpdate(node);\n        }\n    }\n    computeNodeUpdate(node) {\n        const [centroidJump, centroidEdgeCut] = this.computeCentroidJump(node);\n        const centroidJumpEnergy = this.computeNodePosEnergy(node, centroidJump);\n        const jumpScale = 0.01 * this.clock.temperature;\n        const randJumpPosition = jumpRandom(centroidJump, jumpScale);\n        const randJumpEnergy = this.computeNodePosEnergy(node, randJumpPosition);\n        if (randJumpEnergy < centroidJumpEnergy) {\n            return {\n                node,\n                kind: NodeUpdateKind.RandomJump,\n                position: randJumpPosition,\n                energy: randJumpEnergy,\n            };\n        }\n        else {\n            return {\n                node,\n                kind: NodeUpdateKind.CentroidJump,\n                position: centroidJump,\n                energy: centroidJumpEnergy,\n                prunedEdge: centroidEdgeCut,\n            };\n        }\n    }\n    computeNodePosEnergy(node, position) {\n        const attractive = this.nodeAttractiveForce(node, position);\n        const repulsive = this.nodeRepulsiveForce(node, position);\n        return attractive + repulsive;\n    }\n    nodeAttractiveForce(node, position) {\n        //const attractionFactor = this.clock.attraction ** 4 * 2e-2\n        const energyDistancePower = this.clock.energyDistancePower;\n        let sum = 0.0;\n        let neighborId;\n        let neighbor;\n        let weight;\n        for (neighborId of this.graph.getNeighbors(node.storeId)) {\n            neighbor = this.graph.nodes.itemAt(neighborId);\n            weight = this.graph.getEdgeWeight(node.storeId, neighborId);\n            if (weight != null) {\n                const energyDistance = squareDistanceTo(position, neighbor) ** energyDistancePower;\n                const neighborEnergy = weight * energyDistance; // * attractionFactor\n                sum += neighborEnergy;\n            }\n        }\n        return sum;\n    }\n    nodeRepulsiveForce(node, position) {\n        return this.densityGrid.getDensity(node, position, this.clock.useFineDensity);\n    }\n    computeCentroidJump(node) {\n        const isNeighborCutRequired = () => {\n            // TODO: This turns on when users set the edge cut manually. It doesn't fire with the default\n            // value of 0.8. Is this even useful?\n            const cutEndActive = this.clock.cutEnd < 39500.9;\n            const numNeighborsExceedsMin = () => {\n                const numNeighbors = this.graph.getNeighbors(node.storeId).length;\n                return numNeighbors > this.clock.minEdges;\n            };\n            return (this.clock.neighborCutsEnabled &&\n                cutEndActive &&\n                numNeighborsExceedsMin());\n        };\n        const centroidPos = this.graph.getNeighborhoodCentroid(node.storeId);\n        const jumpPos = jumpTowards(node, centroidPos, this.clock.damping);\n        const jumpDist = squareDistanceTo(centroidPos, jumpPos);\n        const prunedEdge = jumpDist > 0 && isNeighborCutRequired()\n            ? this.getEdgeToCut(node, centroidPos)\n            : undefined;\n        return [jumpPos, prunedEdge];\n    }\n    getEdgeToCut(node, centroidPos) {\n        const neighbors = this.graph.getNeighbors(node.storeId);\n        const squareConnections = Math.sqrt(neighbors.length);\n        let maxDistance = 0.0;\n        let maxNeighbor;\n        neighbors.forEach(neighborId => {\n            const neighbor = this.graph.nodes.itemAt(neighborId);\n            const distance = squareDistanceTo(centroidPos, neighbor) * squareConnections;\n            if (distance > maxDistance && distance > this.clock.cutOffLength) {\n                maxDistance = distance;\n                maxNeighbor = neighborId;\n            }\n        });\n        return maxNeighbor;\n    }\n    applyUpdate({ node, position, prunedEdge }) {\n        if (this.densityGrid.contains(node)) {\n            this.densityGrid.subtract(node);\n        }\n        // Move node position\n        node.x = position.x;\n        node.y = position.y;\n        if (prunedEdge) {\n            this.graph.pruneEdge(node.storeId, prunedEdge);\n        }\n        this.densityGrid.add(node);\n    }\n    /**\n     * Gets the working energy. This differs from the objective energy in that we cull low-weight edges as the\n     * algorithm progresses. The objective energy keep these in tact.\n     */\n    get energy() {\n        let result = 0;\n        let node;\n        for (node of this.graph.nodes) {\n            result += this.computeNodePosEnergy(node, node);\n        }\n        return result;\n    }\n    /**\n     * Gets the objective energy according to Equation 1 of the OpenOrd Paper\n     *\n     * https://www.researchgate.net/publication/253087985_OpenOrd_An_Open-Source_Toolbox_for_Large_Graph_Layout\n     */\n    get objectiveEnergy() {\n        let attractiveEnergy = 0;\n        let repulsiveEnergy = 0;\n        let overlapEnergy = 0.001;\n        let node;\n        let neighbor;\n        for (node of this.graph.nodes) {\n            repulsiveEnergy += this.densityGrid.getDensity(node, node, false);\n            if (this.clock.phase && this.clock.phase > AnnealingPhase.Liquid) {\n                overlapEnergy += this.densityGrid.getOverlap(node, node);\n            }\n            for (neighbor of this.graph\n                .getNeighborsObjective(node.storeId)\n                .map(nid => this.graph.nodes.itemAt(nid))) {\n                const distance = squareDistanceTo(node, neighbor);\n                const weight = this.graph.getEdgeWeightObjective(node.storeId, neighbor.storeId);\n                attractiveEnergy += distance * weight;\n            }\n        }\n        const objectiveEnergy = attractiveEnergy + repulsiveEnergy;\n        return [objectiveEnergy, attractiveEnergy, repulsiveEnergy, overlapEnergy];\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { AnnealingClock } from './AnnealingClock';\nimport { DensityGrid } from './DensityGrid';\nimport { OpenOrdLayoutExecutor } from './OpenOrdLayoutExecutor';\nimport { DEFAULT_CONFIGURATION } from './types';\n/**\n * @internal\n *\n * Creates an instance of the OpenOrdLayoutExector\n * @param graph The graph to layout\n * @param configuration The layout configuration\n * @param globalObject The global object to use\n */\nexport function createInstance(graph, configuration = {}, globalObject = window) {\n    const finalConfig = {\n        ...DEFAULT_CONFIGURATION,\n        ...configuration,\n    };\n    return new OpenOrdLayoutExecutor(graph, finalConfig, new AnnealingClock(configuration.edgeCut, configuration.schedule), globalObject, new DensityGrid());\n}\n","/**\n * @internal\n *\n * Moves __pos1__ closer to __pos2__ by a __damping__ factor\n * @param pos1 The start position\n * @param pos2 The end position\n * @param damping The damping factor\n */\nexport function jumpTowards(pos1, pos2, damping) {\n    if (damping < 0.0 || damping > 1.0) {\n        throw new Error('jump factor must be between 0-1');\n    }\n    else {\n        const inverse = 1.0 - damping;\n        return {\n            x: pos1.x * inverse + damping * pos2.x,\n            y: pos1.y * inverse + damping * pos2.y,\n        };\n    }\n}\n/**\n * @internal\n *\n * Moves __source__ a random __distance__ away from it's current position\n * @param source The source position\n * @param distance The distance of the jump\n */\nexport function jumpRandom(source, distance) {\n    const r1 = Math.random();\n    const r2 = Math.random();\n    const x = source.x + (0.5 - r1) * distance;\n    const y = source.y + (0.5 - r2) * distance;\n    return { x, y };\n}\n","/**\n * @internal\n *\n * Generates a sample bitmap from the given density grid\n * @param densityGrid The density grid to sample\n * @param rate The sampling rate. 1=full sample. 2=skip every other row+column\n */\nexport function sampleBitmap(densityGrid, rate) {\n    const bitmap = densityGrid.bitmap;\n    const result = [];\n    for (let rowIndex = 0; rowIndex < bitmap.length; rowIndex += rate) {\n        const row = [];\n        result.push(row);\n        for (let colIndex = 0; colIndex < bitmap[0].length; colIndex += rate) {\n            row.push(bitmap[rowIndex][colIndex]);\n        }\n    }\n    return result;\n}\n","/**\n * @internal\n *\n * The default set of configuration options for the layout\n */\nexport const DEFAULT_CONFIGURATION = Object.freeze({\n    emitDensitySnapshots: false,\n    densitySnapshotSamplingRate: 4,\n    edgeCut: 0.8,\n    schedule: {},\n});\n/**\n * @internal\n *\n * The phase of the layout\n */\nexport var AnnealingPhase;\n(function (AnnealingPhase) {\n    AnnealingPhase[AnnealingPhase[\"Initial\"] = 0] = \"Initial\";\n    AnnealingPhase[AnnealingPhase[\"Liquid\"] = 1] = \"Liquid\";\n    AnnealingPhase[AnnealingPhase[\"Expansion\"] = 2] = \"Expansion\";\n    AnnealingPhase[AnnealingPhase[\"Cooldown\"] = 3] = \"Cooldown\";\n    AnnealingPhase[AnnealingPhase[\"Crunch\"] = 4] = \"Crunch\";\n    AnnealingPhase[AnnealingPhase[\"Simmer\"] = 5] = \"Simmer\";\n    AnnealingPhase[AnnealingPhase[\"Complete\"] = 6] = \"Complete\";\n})(AnnealingPhase || (AnnealingPhase = {}));\n/**\n * @internal\n *\n * Gets a user friendly string of the given annealing phase\n * @param input The annealing phase\n */\nexport function getAnnealingPhaseString(input) {\n    switch (input) {\n        case AnnealingPhase.Initial:\n            return 'initial';\n        case AnnealingPhase.Liquid:\n            return 'liquid';\n        case AnnealingPhase.Expansion:\n            return 'expansion';\n        case AnnealingPhase.Cooldown:\n            return 'cooldown';\n        case AnnealingPhase.Crunch:\n            return 'crunch';\n        case AnnealingPhase.Simmer:\n            return 'simmer';\n        default:\n            return 'unknown';\n    }\n}\nexport var NodeUpdateKind;\n(function (NodeUpdateKind) {\n    NodeUpdateKind[NodeUpdateKind[\"CentroidJump\"] = 0] = \"CentroidJump\";\n    NodeUpdateKind[NodeUpdateKind[\"RandomJump\"] = 1] = \"RandomJump\";\n})(NodeUpdateKind || (NodeUpdateKind = {}));\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './specification';\nexport * from './store';\nexport * from './reader';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { AttributeType } from '../specification';\nconst FLOAT_BYTE_SIZE = Float32Array.BYTES_PER_ELEMENT;\n/**\n * A utility class for reading/writing individual properties of a MemoryReader\n */\nexport class MemoryReaderInspector {\n    /**\n     * Calculates the byte offset for the given item's attribute\n     * @param itemIndex The item index of the item\n     * @param attribute The attribute\n     */\n    getByteOffset(item, attribute) {\n        const attr = item.layout.get(attribute);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!attr) {\n                throw new Error('unknown attribute: ' + attribute);\n            }\n        }\n        return item.byteOffset + attr.offset;\n    }\n    /**\n     * Calculates the typed offset for the given attribute\n     * @param itemIndex The item index of the item\n     * @param attribute The attribute\n     */\n    getTypedOffset(item, attribute) {\n        const attr = item.layout.get(attribute);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!attr) {\n                throw new Error('unknown attribute: ' + attribute);\n            }\n        }\n        return attr.typedOffset;\n    }\n    getWordOffset(item, attribute) {\n        return this.getByteOffset(item, attribute) / FLOAT_BYTE_SIZE;\n    }\n    // #region Read/Write Generic Property\n    /**\n     * Reads the __property__ for the __item__\n     * @param item The item to get the property for\n     * @param property The property to read\n     */\n    readProperty(item, property) {\n        const itemProperties = item.store.propertyBags[item.storeId];\n        if (itemProperties != null) {\n            return itemProperties[property];\n        }\n    }\n    /**\n     * Writes the __property__ for the __item__\n     * @param item The item to update\n     * @param property The property to update\n     * @param value The value of the property\n     */\n    writeProperty(item, property, value) {\n        let itemProperties = item.store.propertyBags[item.storeId];\n        if (!itemProperties) {\n            itemProperties = {};\n            item.store.propertyBags[item.storeId] = itemProperties;\n        }\n        itemProperties[property] = value;\n        item.store?.notify(item.storeId, property);\n    }\n    // #endregion\n    // #region Number\n    /**\n     * Reads __attribute__ from __item__ as a number\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readNumber(item, attribute) {\n        if (!item.layout.has(attribute)) {\n            return this.readProperty(item, attribute) || 0;\n        }\n        else {\n            const attrib = item.layout.get(attribute);\n            if (attrib.type === AttributeType.Uint8) {\n                return this.readUint8Attr(item, attribute);\n            }\n            else if (attrib.type === AttributeType.Uint32) {\n                return this.readUint32Attr(item, attribute);\n            }\n            else {\n                return this.readFloat32Attr(item, attribute);\n            }\n        }\n    }\n    /**\n     * Writes __attribute__ for __item__ as a number\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeNumber(item, attribute, value) {\n        const attrib = item.layout.get(attribute);\n        if (!attrib) {\n            this.writeProperty(item, attribute, value);\n        }\n        else {\n            if (attrib.type === AttributeType.Uint8) {\n                this.writeUint8Attr(item, attribute, value);\n            }\n            else if (attrib.type === AttributeType.Uint32) {\n                this.writeUint32Attr(item, attribute, value);\n            }\n            else {\n                this.writeFloat32Attr(item, attribute, value);\n            }\n        }\n        item.store?.notify(item.storeId, attribute);\n    }\n    // #endregion\n    // #region String\n    /**\n     * Reads __attribute__ from __item__ as a string\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readString(item, attribute) {\n        return this.readProperty(item, attribute);\n    }\n    /**\n     * Writes __attribute__ for __item__ as a string\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeString(item, attribute, value) {\n        this.writeProperty(item, attribute, value);\n        item.store?.notify(item.storeId, attribute);\n    }\n    // #endregion\n    // #region Boolean\n    /**\n     * Reads __attribute__ from __item__ as a boolean\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readBoolAttr(item, attribute) {\n        return Boolean(this.readUint8Attr(item, attribute));\n    }\n    /**\n     * Writes __attribute__ for __item__ as a boolean\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeBoolAttr(item, attribute, value) {\n        this.writeUint8Attr(item, attribute, value ? 1 : 0);\n    }\n    // #endregion\n    // #region Float32 Single Value\n    /**\n     * Reads __attribute__ from __item__ as a float32\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readFloat32Attr(item, attribute) {\n        return item.float32Array[this.getWordOffset(item, attribute)];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a float32\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeFloat32Attr(item, attribute, value) {\n        item.float32Array[this.getWordOffset(item, attribute)] = value;\n    }\n    // #endregion\n    // #region Float32 Vec2\n    /**\n     * Reads __attribute__ from __item__ as a float32[2]\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readFloat32Vec2Attr(item, attribute) {\n        const offset = this.getWordOffset(item, attribute);\n        return [item.float32Array[offset], item.float32Array[offset + 1]];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a float32[2]\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param x The x component to update\n     * @param y The y component to update\n     */\n    writeFloat32Vec2Attr(item, attribute, x, y) {\n        const offset = this.getWordOffset(item, attribute);\n        item.float32Array[offset] = x;\n        item.float32Array[offset + 1] = y;\n    }\n    /**\n     * Writes the float32[2] to the __typedOffset__ of the item\n     * @param item The item to update\n     * @param typedOffset The offset into the array to write the float32[2]\n     * @param x The x component to update\n     * @param y The y component to update\n     */\n    writeFloat32Vec2Offset(item, typedOffset, x, y) {\n        item.float32Array[item.wordOffset + typedOffset] = x;\n        item.float32Array[item.wordOffset + typedOffset + 1] = y;\n    }\n    // #endregion\n    // #region Float32 Vec3\n    /**\n     * Copies the float32[3] from the sourceAttribute to targetAttribute\n     * @param item The item to update\n     * @param sourceAttribute The source attribute to copy from\n     * @param targetAttribute The target attribute to copy to\n     */\n    copyFloat32Vec3Attr(item, sourceAttribute, targetAttribute) {\n        const offset = this.getWordOffset(item, sourceAttribute);\n        const subarray = item.float32Array.subarray(offset, offset + 3);\n        item.float32Array.set(subarray, this.getWordOffset(item, targetAttribute));\n        return subarray;\n    }\n    /**\n     * Copies the float32[2] from sourceTypedOffset to targetTypedOffset\n     * @param item The item to update\n     * @param sourceTypedOffset The typed offset for the source attribute\n     * @param targetTypedOffset typed offset for the target attribute\n     */\n    copyFloat32Vec3Offset(item, sourceTypedOffset, targetTypedOffset) {\n        const subarray = item.float32Array.subarray(item.wordOffset + sourceTypedOffset, item.wordOffset + sourceTypedOffset + 3);\n        item.float32Array.set(subarray, item.wordOffset + targetTypedOffset);\n        return subarray;\n    }\n    /**\n     * Writes __attribute__ for __item__ as a float32[3]\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param x The x component to update\n     * @param y The y component to update\n     * @param z The z component to update\n     */\n    writeFloat32Vec3Attr(item, attribute, x, y, z) {\n        const offset = this.getWordOffset(item, attribute);\n        item.float32Array[offset] = x;\n        item.float32Array[offset + 1] = y;\n        item.float32Array[offset + 2] = z;\n    }\n    /**\n     * Writes the float32[3] to the __typedOffset__ of the item\n     * @param item The item to update\n     * @param typedOffset The offset into the array to write the float32[3]\n     * @param x The x component to update\n     * @param y The y component to update\n     * @param z The z component to update\n     */\n    writeFloat32Vec3Offset(item, typedOffset, x, y, z) {\n        item.float32Array[item.wordOffset + typedOffset] = x;\n        item.float32Array[item.wordOffset + typedOffset + 1] = y;\n        item.float32Array[item.wordOffset + typedOffset + 2] = z;\n    }\n    /**\n     * Reads __attribute__ from __item__ as a float32[3]\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readFloat32Vec3Attr(item, attribute) {\n        const offset = this.getWordOffset(item, attribute);\n        return [\n            item.float32Array[offset],\n            item.float32Array[offset + 1],\n            item.float32Array[offset + 2],\n        ];\n    }\n    // #endregion\n    // #region Uint8 Single Value\n    /**\n     * Reads __attribute__ from __item__ as a unit8\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readUint8Attr(item, attribute) {\n        return item.uint8Array[this.getByteOffset(item, attribute)];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a unit8\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeUint8Attr(item, attribute, value) {\n        item.uint8Array[this.getByteOffset(item, attribute)] = value;\n    }\n    // #endregion\n    // #region Uint8 Vec2\n    /**\n     * Reads __attribute__ from __item__ as a unit8[2]\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readUint8Vec2Attr(item, attribute) {\n        const offset = this.getByteOffset(item, attribute);\n        return [item.uint8Array[offset], item.uint8Array[offset + 1]];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a uint8[2]\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param x The x component to update\n     * @param y The y component to update\n     * @param z The z component to update\n     */\n    writeUint8Vec2Attr(item, attribute, x, y) {\n        const offset = this.getByteOffset(item, attribute);\n        item.uint8Array[offset] = x;\n        item.uint8Array[offset + 1] = y;\n    }\n    // #endregion\n    // #region Uint8 Vec3\n    /**\n     * Reads __attribute__ from __item__ as a unit8[3]\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readUint8Vec3Attr(item, attribute) {\n        const offset = this.getByteOffset(item, attribute);\n        return [\n            item.uint8Array[offset],\n            item.uint8Array[offset + 1],\n            item.uint8Array[offset + 2],\n        ];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a uint8[3]\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param x The x component to update\n     * @param y The y component to update\n     * @param z The z component to update\n     */\n    writeUint8Vec3Attr(item, attribute, x, y, z) {\n        const offset = this.getByteOffset(item, attribute);\n        item.uint8Array[offset] = x;\n        item.uint8Array[offset + 1] = y;\n        item.uint8Array[offset + 2] = z;\n    }\n    // #endregion\n    // #region Uint8 Vec4\n    /**\n     * Reads __attribute__ from __item__ as a unit8[4]\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readUint8Vec4Attr(item, attribute) {\n        const offset = this.getByteOffset(item, attribute);\n        return [\n            item.uint8Array[offset],\n            item.uint8Array[offset + 1],\n            item.uint8Array[offset + 2],\n            item.uint8Array[offset + 3],\n        ];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a uint8[4]\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param x The x component to update\n     * @param y The y component to update\n     * @param z The z component to update\n     * @param zz The zz component to update\n     */\n    writeUint8Vec4Attr(item, attribute, x, y, z, zz) {\n        const offset = this.getByteOffset(item, attribute);\n        item.uint8Array[offset] = x;\n        item.uint8Array[offset + 1] = y;\n        item.uint8Array[offset + 2] = z;\n        item.uint8Array[offset + 3] = zz;\n    }\n    // #endregion\n    // #region Uint32 Single Value\n    /**\n     * Reads __attribute__ from __item__ as a uint32\n     * @param item The item to get the attribute for\n     * @param attribute The attribute to read\n     */\n    readUint32Attr(item, attribute) {\n        return item.uint32Array[this.getWordOffset(item, attribute)];\n    }\n    /**\n     * Writes __attribute__ for __item__ as a unit32\n     * @param item The item to update\n     * @param attribute The attribute to update\n     * @param value The attribute value\n     */\n    writeUint32Attr(item, attribute, value) {\n        item.uint32Array[this.getWordOffset(item, attribute)] = value;\n    }\n    /**\n     * Writes the unit32 at the given __typedOffset__ for the item\n     * @param item The item to update\n     * @param typedOffset The offset into the array to write the uint32\n     * @param value The attribute value\n     */\n    writeUint32Offset(item, typedOffset, value) {\n        item.uint32Array[item.wordOffset + typedOffset] = value;\n    }\n    /**\n     * Copies the uint32 from sourceTypedOffset to targetTypedOffset\n     * @param item The item to update\n     * @param sourceTypedOffset The typed offset for the source attribute\n     * @param targetTypedOffset typed offset for the target attribute\n     */\n    copyUint32Offset(item, sourceTypedOffset, targetTypedOffset) {\n        item.uint32Array[item.wordOffset + targetTypedOffset] =\n            item.uint32Array[item.wordOffset + sourceTypedOffset];\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { IdStoreImpl, SlotAllocator } from '../store';\n/**\n * @inheritdoc\n * @see {@link ReaderStore}\n */\nexport class ReaderStoreImpl extends IdStoreImpl {\n    /**\n     * Constructor for the ReaderStoreImpl\n     * @param itemClass The class of the item, used when constructing new items\n     * @param store The underlying store to use\n     * @param allocator The allocator to use for allocating new ids\n     */\n    constructor(itemClass, store, allocator = new SlotAllocator(store.config.capacity)) {\n        super(store, allocator);\n        this.propertyBags = {};\n        this.items = new Array(store.config.capacity);\n        this.itemClass = itemClass;\n        // reconnect items on resize\n        store.onResize(() => {\n            this.items.forEach(i => i && i.connect(i.storeId, this));\n        });\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ReaderStore.receive}\n     */\n    receive(primitive) {\n        const storeId = this.add(false);\n        this.slurp(storeId, primitive.buffer, primitive.byteOffset);\n        primitive.connect(storeId, this);\n        this.fireAddHandlers(storeId);\n        return storeId;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ReaderStore.itemAt}\n     */\n    itemAt(storeId) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (!this.slotAllocator.has(storeId)) {\n                throw new Error(`Element ${storeId} does not exist`);\n            }\n        }\n        return (this.items[storeId] ||\n            (this.items[storeId] = this.createConnectedItem(storeId)));\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ReaderStore.createConnectedItem}\n     */\n    createConnectedItem(storeId) {\n        if (!this.propertyBags[storeId]) {\n            this.propertyBags[storeId] = {};\n        }\n        return new this.itemClass(this, storeId);\n    }\n    *[Symbol.iterator]() {\n        let idx;\n        for (idx of this.itemIds()) {\n            yield this.itemAt(idx);\n        }\n    }\n    *scan() {\n        let idx;\n        let item;\n        if (this.count > 0) {\n            item = this.createConnectedItem(0);\n        }\n        if (item) {\n            for (idx of this.itemIds()) {\n                if (!this.propertyBags[idx]) {\n                    this.propertyBags[idx] = {};\n                }\n                item.connect(idx, this);\n                yield item;\n            }\n        }\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ReaderStore.slurp}\n     */\n    slurp(targetId, sourceBuffer, propertyBag = {}, sourceOffset = 0) {\n        this.store.slurp(targetId, sourceBuffer, sourceOffset);\n        if (propertyBag) {\n            this.propertyBags[targetId] = propertyBag;\n        }\n        else {\n            this.propertyBags[targetId] = undefined;\n        }\n        // All the attributes for this item were updated\n        this.notify(targetId);\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.add}\n     */\n    add(events = true) {\n        const id = super.add(false);\n        this.propertyBags[id] = {};\n        if (events) {\n            this.fireAddHandlers(id);\n        }\n        return id;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.remove}\n     */\n    remove(idx) {\n        super.remove(idx);\n        // TODO - handle with onRemove hook?\n        // this.writeBool(idx, this.visibleAttrib as T, false)\n        this.propertyBags[idx] = undefined;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.reset}\n     */\n    reset() {\n        super.reset();\n        this.propertyBags = {};\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.destroy}\n     */\n    destroy() {\n        super.destroy();\n        this.propertyBags = {};\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { SpacerAttributeName, AttributeType, InterpretationHint, } from '../specification';\n/**\n * Creates a MemoryReader implementation which can read the given memory layout efficiently\n * @param readerType The type of reader\n * @param layout The memory layout\n * @param additionalProperties The additional properties to add to the implementation\n * @param setterAugmenter The setter augmenter, which can be used to manipulate the underlying generated property setters\n */\nexport function createReader(readerType, layout, additionalProperties = []) {\n    class Impl {\n        /**\n         * Constructor for the MemoryReader implementation\n         * @param store The backing data store\n         * @param storeId The id to use when accessing the store\n         */\n        constructor(store = undefined, storeId = -1) {\n            // item data\n            this.storeId = -1;\n            this.byteOffset = 0;\n            this.wordOffset = 0;\n            const autobuffer = store == null;\n            if (autobuffer) {\n                this.isFlushNeeded = true;\n                const buffer = new ArrayBuffer(layout.stride);\n                this.uint8Array = new Uint8Array(buffer);\n                this.uint32Array = new Uint32Array(buffer);\n                this.float32Array = new Float32Array(buffer);\n                this.propertyBag = {};\n            }\n            else {\n                this.isFlushNeeded = false;\n                this.connect(storeId, store);\n            }\n            additionalProperties.forEach(property => {\n                if (typeof property !== 'string') {\n                    const { name, initialValue, ephemeral } = property;\n                    if (ephemeral) {\n                        ;\n                        this[name] = initialValue;\n                    }\n                    else {\n                        this.propertyBag[name] = initialValue;\n                    }\n                }\n            });\n        }\n        /**\n         * @inheritdoc\n         * @see {@link MemoryReader.type}\n         */\n        get type() {\n            return readerType;\n        }\n        /**\n         * @inheritdoc\n         * @see {@link MemoryReader.layout}\n         */\n        get layout() {\n            return layout;\n        }\n        /**\n         * @inheritdoc\n         * @see {@link MemoryReader.buffer}\n         */\n        get buffer() {\n            return this.uint8Array.buffer;\n        }\n        /**\n         * @inheritdoc\n         * @see {@link MemoryReader.connect}\n         */\n        connect(storeId, store) {\n            if (this.storeId !== storeId) {\n                this.byteOffset = storeId * store.store.bytesPerItem;\n                this.wordOffset = this.byteOffset / 4;\n                this.storeId = storeId;\n                // flush this items buffer out if we're waiting for a store connection\n                if (this.isFlushNeeded) {\n                    store.slurp(storeId, this.uint8Array.buffer, this.propertyBag);\n                    this.isFlushNeeded = false;\n                }\n                // copy property bag\n                this.propertyBag = store.propertyBags[storeId];\n            }\n            // It is important to not have \" if (this.store != store) \"\n            // It's possible that the store doesn't change, but the underlying arrays do\n            // copy array aliases\n            this.store = store;\n            this.uint32Array = store.store.uint32Array;\n            this.float32Array = store.store.float32Array;\n            this.uint8Array = store.store.uint8Array;\n        }\n        /**\n         * Handles an attribute being set\n         * @param name The name of the attribute\n         */\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        handleAttributeUpdated(name) { }\n    }\n    const proto = Impl.prototype;\n    /**\n     * Wire layout properties into the memory layout\n     */\n    layout.forEach(attribute => {\n        if (attribute.name === SpacerAttributeName) {\n            return;\n        }\n        const { name, size, type, typedOffset, hint } = attribute;\n        let setter;\n        let getter;\n        if (type === AttributeType.Float32) {\n            if (size === 1) {\n                //\n                // Singular Float Values\n                //\n                getter = function () {\n                    return this.float32Array[this.wordOffset + typedOffset];\n                };\n                setter = function (value) {\n                    this.float32Array[this.wordOffset + typedOffset] = value || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n            else if (size === 2) {\n                //\n                // Vec2 Float Values\n                //\n                getter = function () {\n                    return [\n                        this.float32Array[this.wordOffset + typedOffset],\n                        this.float32Array[this.wordOffset + typedOffset + 1],\n                    ];\n                };\n                setter = function (value) {\n                    this.float32Array[this.wordOffset + typedOffset] = value[0] || 0;\n                    this.float32Array[this.wordOffset + typedOffset + 1] = value[1] || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n            else if (size === 3) {\n                //\n                // Vec3 Float Values\n                //\n                getter = function () {\n                    return [\n                        this.float32Array[this.wordOffset + typedOffset],\n                        this.float32Array[this.wordOffset + typedOffset + 1],\n                        this.float32Array[this.wordOffset + typedOffset + 2],\n                    ];\n                };\n                setter = function (value) {\n                    this.float32Array[this.wordOffset + typedOffset] = value[0] || 0;\n                    this.float32Array[this.wordOffset + typedOffset + 1] = value[1] || 0;\n                    this.float32Array[this.wordOffset + typedOffset + 2] = value[2] || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n        }\n        else if (type === AttributeType.Uint8) {\n            if (size === 1) {\n                if (hint === InterpretationHint.Boolean) {\n                    //\n                    // Single Byte Boolean\n                    //\n                    getter = function () {\n                        return this.uint8Array[this.byteOffset + typedOffset] > 0;\n                    };\n                    setter = function (value) {\n                        this.uint8Array[this.byteOffset + typedOffset] = value ? 1 : 0;\n                        this.handleAttributeUpdated(name);\n                    };\n                }\n                else {\n                    //\n                    // Single Byte Number\n                    //\n                    getter = function () {\n                        return this.uint8Array[this.byteOffset + typedOffset];\n                    };\n                    setter = function (value) {\n                        this.uint8Array[this.byteOffset + typedOffset] = value;\n                        this.handleAttributeUpdated(name);\n                    };\n                }\n            }\n            else if (size === 2) {\n                //\n                // Vec2 Byte Values\n                //\n                getter = function () {\n                    return [\n                        this.uint8Array[this.byteOffset + typedOffset],\n                        this.uint8Array[this.byteOffset + typedOffset + 1],\n                    ];\n                };\n                setter = function (value) {\n                    this.uint8Array[this.byteOffset + typedOffset] = value[0] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 1] = value[1] || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n            else if (size === 3) {\n                //\n                // Vec3 Byte Values\n                //\n                getter = function () {\n                    return [\n                        this.uint8Array[this.byteOffset + typedOffset],\n                        this.uint8Array[this.byteOffset + typedOffset + 1],\n                        this.uint8Array[this.byteOffset + typedOffset + 2],\n                    ];\n                };\n                setter = function (value) {\n                    this.uint8Array[this.byteOffset + typedOffset] = value[0] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 1] = value[1] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 2] = value[2] || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n            else if (size === 4) {\n                //\n                // Vec4 Byte Values\n                //\n                getter = function () {\n                    return [\n                        this.uint8Array[this.byteOffset + typedOffset],\n                        this.uint8Array[this.byteOffset + typedOffset + 1],\n                        this.uint8Array[this.byteOffset + typedOffset + 2],\n                        this.uint8Array[this.byteOffset + typedOffset + 3],\n                    ];\n                };\n                setter = function (value) {\n                    this.uint8Array[this.byteOffset + typedOffset] = value[0] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 1] = value[1] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 2] = value[2] || 0;\n                    this.uint8Array[this.byteOffset + typedOffset + 3] = value[3] || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n        }\n        else if (type === AttributeType.Uint32) {\n            if (size === 1) {\n                //\n                // Uint32 Single Values\n                //\n                getter = function () {\n                    return this.uint32Array[this.wordOffset + typedOffset];\n                };\n                setter = function (value) {\n                    this.uint32Array[this.wordOffset + typedOffset] = value || 0;\n                    this.handleAttributeUpdated(name);\n                };\n            }\n        }\n        if (setter) {\n            proto.__defineSetter__(name, setter);\n        }\n        if (getter) {\n            proto.__defineGetter__(name, getter);\n        }\n    });\n    /**\n     * Wire additional properties into the property bag\n     */\n    additionalProperties.forEach(property => {\n        const name = typeof property === 'string' ? property : property.name;\n        const ephemeral = typeof property !== 'string' ? Boolean(property.ephemeral) : false;\n        if (!ephemeral) {\n            proto.__defineGetter__(name, function () {\n                return this.propertyBag[name];\n            });\n            proto.__defineSetter__(name, function (value) {\n                this.propertyBag[name] = value;\n            });\n        }\n    });\n    return Impl;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './createReader';\nexport * from './ReaderStore';\nexport * from './types';\nexport * from './MemoryReaderInspector';\n","export {};\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { AttributeType } from './types';\n/**\n * @internal\n *\n * A mapping from AttributeType to the number of bytes required to store it\n */\nexport const DATA_TYPE_TO_BYTES = {\n    [AttributeType.Float32]: 4,\n    [AttributeType.Uint32]: 4,\n    [AttributeType.Uint8]: 1,\n};\n/**\n * @internal\n *\n * Gets the size in bytes for the given data type\n * @param type The data type to inspect\n */\nexport function getAttributeTypeByteSize(type) {\n    return DATA_TYPE_TO_BYTES[type];\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { getAttributeTypeByteSize } from './AttributeType';\nimport { AttributeType, } from './types';\nexport const SpacerAttributeName = '__SPACER__';\n/**\n * @internal\n *\n * Creates a LayoutBuilder which can be used to construct a MemoryLayout\n */\nexport function createLayoutBuilder() {\n    const toBuild = new Map();\n    function addAttribute(name, type, size, options) {\n        toBuild.set(name, {\n            name,\n            size,\n            type,\n            options,\n        });\n    }\n    const me = {\n        addUint8(name, options) {\n            addAttribute(name, AttributeType.Uint8, 1, options);\n            return me;\n        },\n        addUint8Vec2(name, options) {\n            addAttribute(name, AttributeType.Uint8, 2, options);\n            return me;\n        },\n        addUint8Vec3(name, options) {\n            addAttribute(name, AttributeType.Uint8, 3, options);\n            return me;\n        },\n        addUint8Vec4(name, options) {\n            addAttribute(name, AttributeType.Uint8, 4, options);\n            return me;\n        },\n        addFloat32(name, options) {\n            addAttribute(name, AttributeType.Float32, 1, options);\n            return me;\n        },\n        addFloat32Vec2(name, options) {\n            addAttribute(name, AttributeType.Float32, 2, options);\n            return me;\n        },\n        addFloat32Vec3(name, options) {\n            addAttribute(name, AttributeType.Float32, 3, options);\n            return me;\n        },\n        addUint32(name, options) {\n            addAttribute(name, AttributeType.Uint32, 1, options);\n            return me;\n        },\n        build() {\n            const built = new Map();\n            // Organize so the FLOAT types come before the BYTE types\n            // The reason we do this is because FLOAT offsets have to be multiples of 4 (bytes)\n            // so, we pack the floats first, so that all their offsets are multiples of 4\n            // then we fill in the rest with the bytes\n            let offset = 0;\n            // Float32 first\n            toBuild.forEach(attr => {\n                if (attr.type === AttributeType.Float32) {\n                    offset += buildAttribute(attr, offset, built);\n                }\n            });\n            // Uint32 next\n            toBuild.forEach(attr => {\n                if (attr.type === AttributeType.Uint32) {\n                    offset += buildAttribute(attr, offset, built);\n                }\n            });\n            // Uint8 Bytes last\n            toBuild.forEach(attr => {\n                if (attr.type === AttributeType.Uint8) {\n                    offset += buildAttribute(attr, offset, built);\n                }\n            });\n            const align = offset % 4;\n            if (offset % 4 !== 0) {\n                offset += buildAttribute({\n                    name: SpacerAttributeName,\n                    type: AttributeType.Uint8,\n                    size: 4 - align,\n                }, offset, built);\n            }\n            built.stride = offset;\n            return built;\n        },\n    };\n    return me;\n}\n/**\n * Gets the total number of bytes required to represent a single item in memory\n * @param layout The memory layout\n */\nexport function getBytesPerItem(layout) {\n    let byteSizePerItem = 0;\n    layout.forEach(attribData => {\n        byteSizePerItem = Math.max(byteSizePerItem, attribData.offset +\n            attribData.size * getAttributeTypeByteSize(attribData.type));\n    });\n    return byteSizePerItem;\n}\n/**\n * Builds a attribute specification from __attr__ build configuration\n * @param attr The attribute specification\n * @param offset The offset for the attribute\n * @param built The current mapping of all the attributes\n */\nfunction buildAttribute(attr, offset, built) {\n    const bytesPerItem = getAttributeTypeByteSize(attr.type);\n    const typedOffset = offset / bytesPerItem;\n    // add the primary attribute\n    built.set(attr.name, {\n        name: attr.name,\n        size: attr.size,\n        type: attr.type,\n        hint: attr.hint,\n        typedOffset,\n        offset,\n    });\n    // add any vector component aliases\n    let componentIndex = 0;\n    let component;\n    for (component of attr.options?.components || []) {\n        built.set(component, {\n            name: component,\n            size: 1,\n            type: attr.type,\n            typedOffset: typedOffset + componentIndex,\n            offset: offset + componentIndex * bytesPerItem,\n        });\n        componentIndex++;\n    }\n    // add any reinterpretation aliases\n    let alias;\n    for (alias of attr.options?.aliases || []) {\n        built.set(alias.name, {\n            name: alias.name,\n            size: alias.size || 1,\n            type: alias.type,\n            hint: alias.hint,\n            typedOffset: offset / getAttributeTypeByteSize(alias.type),\n            offset,\n        });\n    }\n    return attr.size * bytesPerItem;\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './AttributeType';\nexport * from './LayoutBuilder';\nexport * from './types';\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport var AttributeType;\n(function (AttributeType) {\n    AttributeType[AttributeType[\"Float32\"] = 0] = \"Float32\";\n    AttributeType[AttributeType[\"Uint8\"] = 1] = \"Uint8\";\n    AttributeType[AttributeType[\"Uint32\"] = 2] = \"Uint32\";\n})(AttributeType || (AttributeType = {}));\n/**\n * Indicates how a value should be interpreted\n */\nexport var InterpretationHint;\n(function (InterpretationHint) {\n    /**\n     * Interpret a uint8 value as a boolean\n     */\n    InterpretationHint[InterpretationHint[\"Boolean\"] = 0] = \"Boolean\";\n})(InterpretationHint || (InterpretationHint = {}));\n","import { DEFAULT_SHARED, DEFAULT_CAPACITY } from './defaults';\nconst DEFAULT_OPTIONS = {\n    shared: DEFAULT_SHARED,\n    capacity: DEFAULT_CAPACITY,\n};\n/**\n * Implementation of an ArrayStore\n * @see {@link ArrayStore} for more info\n */\nexport class ArrayStoreImpl {\n    /**\n     * Constructor for the ItemArrayBuffer\n     * @param layout The memory layout\n     * @param options The store options\n     */\n    constructor(layout, options = DEFAULT_OPTIONS) {\n        this.layout = layout;\n        this.onResizeHandlers = [];\n        // determine capacity based on the following:\n        // * if an explicit value is provided, use that\n        // * if a buffer is provided, calculate the buffer capacity\n        // * else use default capacity\n        const capacity = options.capacity ||\n            (options.buffer?.byteLength || 0) / layout.stride ||\n            DEFAULT_CAPACITY;\n        this.config = {\n            capacity,\n            shared: typeof options.shared === 'boolean' ? options.shared : DEFAULT_SHARED,\n        };\n        this.bytesPerItem = layout.stride;\n        if (options.buffer) {\n            this._buffer = options.buffer;\n        }\n        this.resize(this.config.capacity);\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.buffer}\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.dataView}\n     */\n    get dataView() {\n        return this._dataView;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.float32Array}\n     */\n    get float32Array() {\n        return this._float32Array;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.uint8Array}\n     */\n    get uint8Array() {\n        return this._uint8Array;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.uint32Array}\n     */\n    get uint32Array() {\n        return this._uint32Array;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.onResize}\n     */\n    onResize(handler) {\n        this.onResizeHandlers.push(handler);\n        return () => {\n            this.onResizeHandlers = this.onResizeHandlers.filter(h => h !== handler);\n        };\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.resize}\n     */\n    resize(newSize) {\n        if (this.count === newSize) {\n            // existing buffer is correct size, don't resize buffer\n            if (!this.uint8Array) {\n                // when initializing, the array aliases may be undefined when the buffer is\n                this._uint8Array = new Uint8Array(this._buffer);\n                this._uint32Array = new Uint32Array(this._buffer);\n                this._float32Array = new Float32Array(this._buffer);\n            }\n            return;\n        }\n        else {\n            const oldSize = this.count;\n            const oldData = this.buffer;\n            // create a new byte array\n            const numBytes = newSize * this.bytesPerItem;\n            if (numBytes % 4 !== 0) {\n                throw new Error(`buffer size ${numBytes} must be word-aligned. size=${newSize}, bpi=${this.bytesPerItem}`);\n            }\n            const newBuffer = this.config.shared && typeof SharedArrayBuffer !== 'undefined'\n                ? new SharedArrayBuffer(numBytes)\n                : new ArrayBuffer(numBytes);\n            if (oldSize > 0 && newSize > oldSize) {\n                // copy the old data in\n                const newByteArray = new Uint8Array(newBuffer);\n                newByteArray.set(new Uint8Array(oldData));\n            }\n            // set a new data view\n            this._buffer = newBuffer;\n            this._dataView = new DataView(newBuffer);\n            this._float32Array = new Float32Array(newBuffer);\n            this._uint8Array = new Uint8Array(newBuffer);\n            this._uint32Array = new Uint32Array(newBuffer);\n            this.onResizeHandlers.forEach(h => h());\n        }\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.itemData}\n     */\n    itemData(idx) {\n        if (idx < 0 ||\n            idx * this.bytesPerItem > this.buffer.byteLength - this.bytesPerItem) {\n            throw new Error('Index out of range');\n        }\n        const byteOffset = idx * this.bytesPerItem;\n        return this.buffer.slice(byteOffset, byteOffset + this.bytesPerItem);\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.getByteOffset}\n     */\n    getByteOffset(idx) {\n        if (process.env.NODE_ENV === 'production') {\n            if (idx < 0 ||\n                idx * this.bytesPerItem > this.buffer.byteLength - this.bytesPerItem) {\n                throw new Error('Index out of range');\n            }\n        }\n        return idx * this.bytesPerItem;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.getByteOffsetAttr}\n     */\n    getByteOffsetAttr(idx, attribute) {\n        const attribLayout = this.layout.get(attribute);\n        if (process.env.NODE_ENV === 'production') {\n            if (idx < 0 ||\n                idx * this.bytesPerItem > this.buffer.byteLength - this.bytesPerItem) {\n                throw new Error('Index out of range');\n            }\n            if (!attribLayout) {\n                throw new Error(`Layout does not contain ${attribute}`);\n            }\n        }\n        return idx * this.bytesPerItem + attribLayout?.offset;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.count}\n     */\n    get count() {\n        if (this.buffer) {\n            return this.buffer.byteLength / this.bytesPerItem;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.destroy}\n     */\n    destroy() {\n        // Set the capacity to zero\n        this.config.capacity = 0;\n        // Force the data to be empty\n        this.resize(0);\n    }\n    /**\n     * @inheritdoc\n     * @see {@link ArrayStore.slurp}\n     */\n    slurp(targetIdx, sourceBuffer, sourceOffset = 0) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (!sourceBuffer) {\n                throw new Error(`Invalid store ${sourceBuffer}`);\n            }\n        }\n        // TODO: Check if they have compatible attributes\n        this.uint8Array.set(new Uint8Array(sourceBuffer, sourceOffset, this.bytesPerItem), targetIdx * this.bytesPerItem);\n    }\n}\n","/**\n * __&commat;internal__\n *\n * An implementation of an IdStore\n */\nexport class IdStoreImpl {\n    // #region construction\n    /**\n     * Constructor for the IdStoreImpl\n     * @param store The backing ArrayStore\n     * @param allocator The allocator for allocating new ids\n     */\n    constructor(store, allocator) {\n        this._count = 0;\n        /** callbacks and handlers */\n        this.onUpdateHandlers = [];\n        this.onAddHandlers = [];\n        this.onRemoveHandlers = [];\n        this._store = store;\n        this.slotAllocator = allocator;\n        this._count = allocator.usedCount;\n    }\n    // #endregion\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.store}\n     */\n    get store() {\n        return this._store;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.count}\n     */\n    get count() {\n        return this._count;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.itemIds}\n     */\n    itemIds() {\n        return this.slotAllocator.used();\n    }\n    // #region pubsub events\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.onAttributeUpdated}\n     */\n    onAttributeUpdated(handler) {\n        this.onUpdateHandlers.push(handler);\n        return () => {\n            this.onUpdateHandlers = this.onUpdateHandlers.filter(h => h !== handler);\n        };\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.onAddItem}\n     */\n    onAddItem(handler) {\n        this.onAddHandlers.push(handler);\n        return () => {\n            this.onAddHandlers = this.onAddHandlers.filter(h => h !== handler);\n        };\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.onRemoveItem}\n     */\n    onRemoveItem(handler) {\n        this.onRemoveHandlers.push(handler);\n        return () => {\n            this.onRemoveHandlers = this.onRemoveHandlers.filter(h => h !== handler);\n        };\n    }\n    // #endregion\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.add}\n     */\n    add(events = true) {\n        if (!this.slotAllocator.hasFreeSpace) {\n            const prevNumItems = this.store.count;\n            const newNumItems = prevNumItems + this.store.config.capacity;\n            this.store.resize(newNumItems);\n            this.slotAllocator.grow(newNumItems);\n        }\n        const itemIndex = this.slotAllocator.alloc();\n        this._count++;\n        if (events) {\n            this.fireAddHandlers(itemIndex);\n        }\n        return itemIndex;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.remove}\n     */\n    remove(idx, events = true) {\n        if (events) {\n            this.fireRemoveHandlers(idx);\n        }\n        this.slotAllocator.free(idx);\n        this._count--;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.reset}\n     */\n    reset() {\n        const numItems = this._store.config.capacity;\n        for (const id of this.itemIds()) {\n            this.fireRemoveHandlers(id);\n        }\n        this._store.resize(numItems);\n        this.slotAllocator.reset(numItems);\n        this._count = 0;\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.destroy}\n     */\n    destroy() {\n        this.store.destroy();\n        this.slotAllocator.destroy();\n        this.onRemoveHandlers = [];\n        this.onAddHandlers = [];\n        this.onUpdateHandlers = [];\n    }\n    /**\n     * @inheritdoc\n     * @see {@link IdStore.notify}\n     */\n    notify(id, attribute) {\n        for (const handler of this.onUpdateHandlers) {\n            try {\n                handler(id, attribute);\n            }\n            catch (e) {\n                console.error('caught error', e);\n            }\n        }\n    }\n    /**\n     * Raises the add event\n     * @param itemIndex The added item index\n     */\n    fireAddHandlers(itemIndex) {\n        this.onAddHandlers.forEach(h => h(itemIndex));\n    }\n    /**\n     * Raises the add event\n     * @param itemIndex The added item index\n     */\n    fireRemoveHandlers(itemIndex) {\n        this.onRemoveHandlers.forEach(h => h(itemIndex));\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nimport { DEFAULT_CAPACITY } from './defaults';\n/**\n * A class for managing id allocation\n */\nexport class SlotAllocator {\n    /**\n     * Constructor for the SlotAllocator\n     * @param capacity The number of ids to support\n     * @param consumed If true, the allocator is assumed to be full\n     * @throws If an invalid capacity is passed to the constructor\n     */\n    constructor(capacity = DEFAULT_CAPACITY, consumed = false) {\n        this.availableIndices = new Map();\n        this.capacity = 0;\n        if (capacity == null || capacity <= 0) {\n            throw new Error(`Invalid capacity ${capacity}, capacity must be > 0`);\n        }\n        this.capacity = capacity;\n        // if the allocator starts out consumed, don't reset its capacity\n        if (!consumed) {\n            this.reset(capacity);\n        }\n    }\n    /**\n     * Resets the allocator back to the default state\n     * @param capacity The number of items to support\n     * @throws If an invalid capacity is passed to the function\n     */\n    reset(capacity) {\n        if (capacity == null || capacity <= 0) {\n            throw new Error(`Invalid capacity ${capacity}, capacity must be > 0`);\n        }\n        this.capacity = capacity;\n        for (let i = 0; i < this.capacity - 1; i++) {\n            this.availableIndices.set(i, i + 1);\n        }\n        this.availableIndices.set(this.capacity - 1, -1);\n        this.nextAvailableIndex = 0;\n    }\n    /**\n     * Grow the capacity of the slot allocator by __newCapacity__\n     * @param newCapacity The new capacity of the allocator\n     * @throws If an invalid capacity is passed to the function\n     */\n    grow(newCapacity) {\n        if (newCapacity == null || newCapacity <= 0) {\n            throw new Error(`Invalid capacity ${newCapacity}, newCapacity must be > 0`);\n        }\n        for (let i = this.capacity; i < newCapacity - 1; i++) {\n            this.availableIndices.set(i, i + 1);\n        }\n        this.nextAvailableIndex = this.capacity;\n        this.capacity = newCapacity;\n    }\n    /**\n     * Returns true if there are available ids\n     */\n    get hasFreeSpace() {\n        return this.nextAvailableIndex != null;\n    }\n    /**\n     * Frees __index__ for re-use\n     * @param index The index to free\n     * @throws An error for an invalid index\n     */\n    free(index) {\n        if (index == null || index < 0 || index > this.capacity - 1) {\n            throw new Error(`Invalid index ${index}`);\n        }\n        this.availableIndices.set(index, this.nextAvailableIndex);\n        this.nextAvailableIndex = index;\n    }\n    /**\n     * Allocates a new index\n     *\n     * @throws An error if there is no space available\n     */\n    alloc() {\n        if (this.nextAvailableIndex == null) {\n            throw new Error('error allocating index, no space available');\n        }\n        const freeIndex = this.nextAvailableIndex;\n        this.nextAvailableIndex =\n            this.availableIndices.get(freeIndex) > 0\n                ? this.availableIndices.get(freeIndex)\n                : undefined;\n        this.availableIndices.delete(freeIndex);\n        return freeIndex;\n    }\n    /**\n     * Returns an iterator for the used slots\n     */\n    *used() {\n        // Shortcut\n        if (this.availableIndices.size === 0 &&\n            (this.nextAvailableIndex === -1 || this.nextAvailableIndex === undefined)) {\n            for (let i = 0; i < this.capacity; ++i) {\n                yield i;\n            }\n        }\n        else {\n            for (let i = 0; i < this.capacity; ++i) {\n                if (!this.availableIndices.has(i) && this.nextAvailableIndex !== i) {\n                    yield i;\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given index has been allocated\n     * @param index The index to check\n     */\n    has(index) {\n        return (index >= 0 && index < this.capacity && !this.availableIndices.has(index));\n    }\n    /**\n     * Returns the number of used indices\n     */\n    get usedCount() {\n        return this.capacity - this.availableIndices.size;\n    }\n    /**\n     * Destroy's the allocator\n     */\n    destroy() {\n        this.availableIndices = new Map();\n        this.nextAvailableIndex = -1;\n    }\n}\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport const DEFAULT_CAPACITY = 10000;\n/**\n * The default shared value of our stores\n */\nexport const DEFAULT_SHARED = true;\n","/*!\n * Copyright (c) Microsoft. All rights reserved.\n * Licensed under the MIT license. See LICENSE file in the project.\n */\nexport * from './types';\nexport * from './SlotAllocator';\nexport * from './ArrayStore';\nexport * from './IdStore';\n","export {};\n","import { createInstance } from './factory';\nimport { GraphContainer } from '@graspologic/graph';\nimport { WorkerMessageType, } from '@graspologic/layout-core';\nlet executor;\nlet subscription;\nself.console.log('openord worker bootstrapping');\n/**\n * Listens for messages from the layout exectuor\n */\nself.onmessage = (message) => {\n    const { type, payload } = message.data;\n    self.console.log('openord receive message', type);\n    switch (type) {\n        case WorkerMessageType.Configure: {\n            executor?.configure(payload);\n            break;\n        }\n        case WorkerMessageType.Execute: {\n            stopExecution();\n            terminateExecution();\n            startExecution(payload);\n            break;\n        }\n        case WorkerMessageType.Halt: {\n            haltExecution();\n            break;\n        }\n        case WorkerMessageType.Reset: {\n            stopExecution();\n            executor = undefined;\n            subscription = undefined;\n            break;\n        }\n        case WorkerMessageType.Resume: {\n            resumeExecution();\n            break;\n        }\n        default:\n            self.console.log('openord worker - unhandled message type', type);\n    }\n};\n/**\n * Halts the execution of the layout\n */\nfunction haltExecution() {\n    if (executor != null) {\n        executor.halt();\n    }\n    else {\n        self.console.log('could not halt oord, instance not defined');\n    }\n}\n/**\n * Resumes the execution of the layout\n */\nfunction resumeExecution() {\n    if (executor != null) {\n        if (!executor.isHalted && !executor.isComplete) {\n            executor.execute();\n        }\n        else {\n            self.console.log('executor is not in a resumable state');\n        }\n    }\n    else {\n        self.console.log('could not resume executor, instance not defined');\n    }\n}\n/**\n * Halts the execution of the layout\n */\nfunction stopExecution() {\n    if (executor != null) {\n        executor.halt();\n    }\n    else {\n        self.console.log('could not stop oord, instance not defined');\n    }\n}\n/**\n * Terminates the execution of the layout\n */\nfunction terminateExecution() {\n    if (subscription != null) {\n        subscription();\n    }\n    subscription = undefined;\n    executor = undefined;\n}\n/**\n * Starts the execution of the layout\n * @param param0 The execute payload\n */\nfunction startExecution({ graph, configuration, }) {\n    try {\n        executor = createInstance(GraphContainer.deserialize(graph), configuration, self);\n        subscription = executor.on('tick', data => {\n            sendMessage(WorkerMessageType.Progress, data);\n        });\n        executor.execute().then(data => {\n            // clean up after execution\n            if (subscription) {\n                subscription();\n            }\n            // clear out execution state\n            executor = undefined;\n            subscription = undefined;\n            // emit completion event\n            sendMessage(WorkerMessageType.Complete, data);\n        });\n    }\n    catch (err) {\n        self.console.log('caught error', err);\n        self.postMessage(WorkerMessageType.Error, err);\n    }\n}\n/**\n * Sends a message to the layout executor\n * @param type The type of message\n * @param payload The payload for the message\n */\nfunction sendMessage(type, payload) {\n    self.postMessage({\n        type,\n        payload,\n    }, undefined);\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAvXA;AAwXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhFA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;;;;;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhDA;AAiDA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAMA;AACA;AACA;;;;;;;;;;;;ACvEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhLA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAHA;AAKA;;;;;;;;;;;;AC3EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACrCA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AATA;AAcA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAhDA;AAiDA;AACA;AACA;AACA;AACA;AADA;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AApBA;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AASA;AAAA;AAIA;AADA;AAMA;AADA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAjDA;AAkDA;AACA;AACA;AACA;AACA;AADA;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAuBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AADA;AAHA;AAWA;AADA;AAVA;AAcA;AAAA;AAGA;AADA;AAhBA;AAsBA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAzIA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AClDA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AA5BA;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhHA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAnFA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AANA;AAQA;AACA;AAAA;AACA;AACA;AACA;AArNA;AAsNA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AArCA;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AAhMA;AAiMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;ACpRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AATA;AACA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAjRA;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;ACjCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAdA;AAgBA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAKA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AAtZA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AA9HA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAzFA;AACA;AAyFA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AArEA;AAsEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAAA;AACA;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA,iBAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA,iBAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AA5LA;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAxJA;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AA5HA;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AA1BA;AA4BA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;;;;A","sourceRoot":""}