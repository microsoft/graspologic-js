// Generated by dts-bundle v0.7.3

declare module '@graspologic/common' {
    export * from '@graspologic/common/utils';
    export * from '@graspologic/common/defaults';
    export * from '@graspologic/common/RenderConfiguration';
    export * from '@graspologic/common/types';
}

declare module '@graspologic/common/utils' {
    export * from '@graspologic/common/utils/Properties';
    export * from '@graspologic/common/utils/equality';
    export * from '@graspologic/common/utils/processMinMax';
    export * from '@graspologic/common/utils/Interpolator';
    export * from '@graspologic/common/utils/fastDebounce';
    export * from '@graspologic/common/utils/events';
}

declare module '@graspologic/common/defaults' {
    import { ColorVector, CameraAdjustmentMode, Bounds3D } from '@graspologic/common/types';
    export const DEFAULT_BG_COLOR: ColorVector;
    export const DEFAULT_DRAW_EDGES = true;
    export const DEFAULT_HIDE_EDGES_ON_MOVE = false;
    export const DEFAULT_DRAW_NODES = true;
    export const DEFAULT_HIDE_NODES_ON_MOVE = false;
    export const DEFAULT_HIDE_DESELECTED = false;
    export const DEFAULT_IS_3D = false;
    export const DEFAULT_INTERPOLATION_TIME = 1000;
    export const DEFAULT_HOVER_HIGHLIGHT_COLOR: ColorVector;
    export const DEFAULT_DRAW_AXES = true;
    export const DEFAULT_CORNER_AXES = true;
    export const DEFAULT_EDGE_CONSTANT_WIDTH = true;
    export const DEFAULT_EDGE_DEPTH_WRITE = false;
    export const DEFAULT_EDGE_ANTIALIAS = false;
    export const DEFAULT_EDGE_ALPHA = 0.15;
    export const DEFAULT_EDGE_MIN_WIDTH = 1;
    export const DEFAULT_EDGE_MAX_WIDTH = 2;
    export const DEFAULT_EDGE_FILTERED_OUT_SATURATION = 0.1;
    export const DEFAULT_EDGE_FILTERED_IN_SATURATION = 1;
    export const DEFAULT_NODE_MIN_RADIUS = 4;
    export const DEFAULT_NODE_MAX_RADIUS = 8;
    export const DEFAULT_NODE_OUTLINE = true;
    export const DEFAULT_NODE_FILTERED_OUT_SATURATION = 0.1;
    export const DEFAULT_NODE_FILTERED_IN_SATURATION = 1;
    export const DEFAULT_NODE_COUNT_HINT = 10000;
    export const DEFAULT_EDGE_COUNT_HINT = 10000;
    export const DEFAULT_WIDTH = 500;
    export const DEFAULT_HEIGHT = 500;
    export const DEFAULT_BOUNDS: Bounds3D | undefined;
    export const DEFAULT_USE_DEVICE_PIXELS: number | boolean;
    export const DEFAULT_SCALE_VIEW_ON_INIT = true;
    export const DEFAULT_CAMERA_MODE = CameraAdjustmentMode.Graph;
    export const DEFAULT_AUTO_BIND = true;
}

declare module '@graspologic/common/RenderConfiguration' {
    import { RenderConfiguration, RenderConfigurationOptions } from '@graspologic/common/types';
    /**
      * @internal
      *
      * Creates a new render configuration
      * @param props The partial set of render configuration options
      */
    export function createConfiguration(props?: Partial<RenderConfigurationOptions>): RenderConfiguration;
}

declare module '@graspologic/common/types' {
    import { PropertyChangeHandler, Disconnect } from '@graspologic/common/utils';
    export enum CameraAdjustmentMode {
            /**
                * Camera is automatically adjusted to fit the graph to the window
                */
            Graph = 0,
            /**
                * Camera is adjusted such that the graph coordinate space is a 1 to 1 mapping of the coordinate space to pixel space
                * i.e. A node at (1000, 1000) will show up at (1000, 1000) on the screen
                */
            Viewport = 1,
            /**
                * Camera is not adjusted automatically
                */
            None = 2
    }
    /**
        * A WebGL RGBA color vector. Each slot contains a float value from 0-1.
        */
    export type ColorVector = [number, number, number, number];
    /**
        * Represents a set of configuration options to control the graph renderer
        */
    export interface RenderConfiguration extends RenderConfigurationOptions {
            onBackgroundColorChanged(handler: PropertyChangeHandler<ColorVector>): Disconnect;
            onDrawEdgesChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onHideEdgesOnMoveChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onDrawNodesChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onHideNodesOnMoveChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onHideDeselectedChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onEdgeConstantWidthChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onEdgeDepthWriteChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onEdgeAlphaChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onEdgeAntialiasChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onEdgeMinWidthChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onEdgeMaxWidthChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeMinRadiusChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeMaxRadiusChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeOutlineChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onCornerAxesChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onDrawAxesChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onInterpolationTimeChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onHoverHighlightColorChanged(handler: PropertyChangeHandler<number[]>): Disconnect;
            onIs3DChanged(handler: PropertyChangeHandler<boolean>): Disconnect;
            onEdgeFilteredOutSaturationChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onEdgeFilteredInSaturationChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeFilteredOutSaturationChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeFilteredInSaturationChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onNodeFilteredIdsChanged(handler: PropertyChangeHandler<string[] | undefined>): Disconnect;
            onNodeCountHintChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onEdgeCountHintChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onWidthChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onHeightChanged(handler: PropertyChangeHandler<number>): Disconnect;
            onCameraAdjustmentModeChanged(handler: PropertyChangeHandler<CameraAdjustmentMode>): Disconnect;
            copy(): RenderConfigurationOptions;
            load(options: Partial<RenderConfigurationOptions>): void;
    }
    /**
        * The set of graph renderer configuration options
        */
    export interface RenderConfigurationOptions {
            /**
                * The background color of the renderer
                */
            backgroundColor: ColorVector;
            /**
                * If true, the axes will be shown in the corner
                */
            cornerAxes: boolean;
            /**
                * If true, the axes will be drawn
                */
            drawAxes: boolean;
            /**
                * If true, the edges will be drawn
                */
            drawEdges: boolean;
            /**
                * If true, the nodes will be drawn
                */
            drawNodes: boolean;
            /**
                * The opacity to apply to the edges, 0 (fully transparent) -> 1 (fully opaque)
                */
            edgeAlpha: number;
            /**
                * If true, edges will be antialiased
                */
            edgeAntialias: boolean;
            /**
                * If true, edges will be drawn with a constant width, regardless of zoom
                */
            edgeConstantWidth: boolean;
            /**
                * If true, edges closer to the camera will occlude further edges
                */
            edgeDepthWrite: boolean;
            /**
                * The saturation of edges which are _in_ the filtered set
                */
            edgeFilteredInSaturation: number;
            /**
                * The saturation of edges which are _not in_ the filtered set
                */
            edgeFilteredOutSaturation: number;
            /**
                * The maximum width of the edges
                */
            edgeMaxWidth: number;
            /**
                * The minimum width of the edges
                */
            edgeMinWidth: number;
            /**
                * If true, non-selected vertices will be hidden
                */
            hideDeselected: boolean;
            /**
                * If true, edges will be hidden while the user is panning/zooming
                */
            hideEdgesOnMove: boolean;
            /**
                * If true, nodes will be hidden while the user is panning/zooming
                */
            hideNodesOnMove: boolean;
            /**
                * The default color to highlight nodes when they are hovered
                */
            hoverHighlightColor: ColorVector;
            /**
                * The amount of time to transition between 3d mode and 2d mode
                */
            interpolationTime: number;
            /**
                * If true, the graph should be rendered in 3d
                */
            is3D: boolean;
            /**
                * The set of filtered node ids
                */
            nodeFilteredIds: string[] | undefined;
            /**
                * The saturation of nodes which are _in_ the filtered set
                */
            nodeFilteredInSaturation: number;
            /**
                * The saturation of nodes which are _not in_ the filtered set
                */
            nodeFilteredOutSaturation: number;
            /**
                * The maximum radius of the nodes
                */
            nodeMaxRadius: number;
            /**
                * The minimum radius of the nodes
                */
            nodeMinRadius: number;
            /**
                * If true, nodes will be drawn with an outline
                */
            nodeOutline: boolean;
            /**
                * Provides a hint to the renderer about how many nodes are expected
                * so data buffers can be preallocated with the optimal size, default = 10000
                */
            nodeCountHint: number;
            /**
                * Provides a hint to the renderer about how many edges are expected
                * so data buffers can be preallocated with the optimal size, default = 10000
                */
            edgeCountHint: number;
            /**
                * The width of the canvas, default = 500
                */
            width: number;
            /**
                * The height of the canvas, default = 500
                */
            height: number;
            /**
                * The camera mode to use
                */
            cameraAdjustmentMode: CameraAdjustmentMode;
            /**
                * If true, when nodes/edges are dynamically changed, the data will automatically be rebound to the renderer
                */
            autoBind: boolean;
            /**
                * The known bounds of the graph, setting this can speed up rendering
                */
            dataBounds: Maybe<Bounds>;
    }
    export interface NumberRange {
            /**
                * The minimum value of the range
                */
            min: number;
            /**
                * The maximum value of the range
                */
            max: number;
    }
    export interface Bounds2D {
            /**
                * Represents the bounds in the x direction
                */
            x: NumberRange;
            /**
                * Represents the bounds in the y direction
                */
            y: NumberRange;
    }
    export interface Bounds3D extends Bounds2D {
            /**
                * Represents the bounds in the z direction
                */
            z: NumberRange;
    }
    /**
        * A generic set of bounds
        */
    export type Bounds = Bounds2D & Partial<Bounds3D>;
    /**
        * The set of options used while rendering
        */
    export interface RenderOptions {
            /**
                * @internal
                * The model view matrix
                */
            modelViewMatrix: any;
            /**
                * @internal
                * The projection matrix
                */
            projectionMatrix: any;
            /**
                * @internal
                * If true, deselected nodes should be hidden
                */
            hideDeselected: boolean;
            /**
                * @internal
                * The min radius of nodes
                */
            minRadius: number;
            /**
                * @internal
                * The max radius of nodes
                */
            maxRadius: number;
            /**
                * @internal
                * The size in pixels of the canvas [width, height]
                */
            canvasPixelSize: [number, number];
            /**
                * @internal
                * The framebuffer to render to
                */
            framebuffer: any;
            /**
                * @internal
                * If true, device pixels should be used
                */
            useDevicePixels: boolean | number;
            /**
                * @internal
                * The current mouse position
                */
            _mousePosition: any;
            /**
                * @internal
                * Scale of weight to pixel size
                */
            weightToPixel: number;
            /**
                * @internal
                * The engine time
                */
            engineTime: number;
            /**
                * @internal
                * The real time
                */
            time: number;
            /**
                * If true, rendering should be forced
                */
            forceRender: boolean;
    }
    export interface ItemBasedRenderable {
            itemType: symbol;
            data: any;
    }
    export interface BoundedRenderable {
            computeBounds(): Bounds3D | undefined;
    }
    export interface Renderable {
            enabled: boolean;
            needsRedraw: boolean;
            /**
                * Updates the current engine time
                * @param engineTime The current engine time
                */
            updateEngineTime?(engineTime: number): void;
            draw(options: RenderOptions): void;
            resize(width: number, height: number): void;
            destroy?(): void;
            /**
                * Binds the data in our databuffer to the model
                * @param force Force a reload of all the data
                */
            bindDataToModel?(force: boolean): void;
    }
    /**
        * An id type
        */
    export type Id = string | number;
    /**
        * Type that indicates a type that maybe defined maybe not
        */
    export type Maybe<T> = T | null | undefined;
}

declare module '@graspologic/common/utils/Properties' {
    import { EventEmitter } from '@graspologic/common/utils/events';
    export type PropertyChangeHandler<T> = (newValue: T) => void;
    export type PropertyChangeValidator<T> = (newValue: T) => boolean;
    export type AreEqualFn<T> = (a: T, b: T) => boolean;
    export const identity: <T>(a: any, b: any) => boolean;
    export interface PropertyContainerEvents<T> {
            /**
                * Event that is raised when the property is changed
                * @param value The new value
                */
            change(value: T | undefined): void;
    }
    /**
        * @internal
        *
        * A class for managing a property that emits an event when it changes
        */
    export class PropertyContainer<T> extends EventEmitter<PropertyContainerEvents<T>> {
            /**
                * Constructor
                * @param _value The current value
                * @param areEqual An equality function
                */
            constructor(_value: T, areEqual?: AreEqualFn<T>);
            /**
                * Sets the validator which validates whether or not a value is a valid value for this property container
                * @param isValid The validator
                */
            checkValidity(isValid: PropertyChangeValidator<T>): void;
            /**
                * Gets the value contained in the container
                */
            get value(): T;
            /**
                * Sets the value in the container
                */
            set value(newValue: T);
    }
}

declare module '@graspologic/common/utils/equality' {
    export function areColorsEqual(a: number[], b: number[]): boolean;
}

declare module '@graspologic/common/utils/processMinMax' {
    import { Bounds3D } from '@graspologic/common/types';
    /**
        * Updates the given bounds based on the new x, y, z values
        * @param bounds The current bounds
        * @param x The new x to be added
        * @param y The new y to be added
        * @param z The new z to be added
        */
    export function processMinMax(bounds: Bounds3D, x: number, y: number, z: number): void;
    /**
        * Updates the given bounds based on the new bounds
        * @param target The current bounds
        * @param newBounds The new bounds
        */
    export function processMinMaxBounds(target: Bounds3D, newBounds: Bounds3D): void;
}

declare module '@graspologic/common/utils/Interpolator' {
    export class Interpolator {
            /**
                * Constructor
                * @param config The render configuration
                */
            constructor(_interpolationTime: number);
            /**
                * Resets the interpolation state
                */
            reset(): void;
            /**
                * Gets the current value of the interpolator
                */
            get current(): number;
            /**
                * Sets the current value of the interpolator
                */
            set current(value: number);
            /**
                * Gets the target value of the interpolator
                */
            set target(value: number);
            /**
                * Sets the target value of the interpolator
                */
            get target(): number;
            /**
                * Gets whether or not interpolation is complete
                */
            get isComplete(): boolean;
            /**
                * Gets the interpolation time
                */
            get interpolationTime(): number;
            /**
                * Sets the interpolation time
                */
            set interpolationTime(value: number);
            /**
                * Updates the interpolation state based on the current time
                * @param time The current time
                */
            tick(time: number): void;
    }
}

declare module '@graspologic/common/utils/fastDebounce' {
    export function fastDebounce(callback: () => any, delay?: number): () => void;
}

declare module '@graspologic/common/utils/events' {
    import { ClassType, SingleArgument } from '@graspologic/common/utils/mixin';
    export type Disconnect = () => void;
    /**
        * An interface which represents object which emits a set of events
        */
    export interface HasEvents<Events> {
            /**
                * Adds an event listener for the given event
                */
            on<N extends keyof Events>(name: N, handler: Events[N]): () => void;
            /**
                * Removes an event listener for the given event
                */
            off<N extends keyof Events>(name: N, handler: Events[N]): void;
            /**
                * Raises the given event
                */
            emit<N extends keyof Events>(name: N, payload?: SingleArgument<Events[N]>): void;
            /**
                * Returns true if there are any listeners for the given event
                * @param name The event name
                */
            hasListeners<N extends keyof Events>(name: N): boolean;
    }
    /**
        * An implementation of an object which emits a set of events
        */
    export class EventEmitter<Events> implements HasEvents<Events> {
            /**
                * Adds an event listener for the given event
                */
            on<N extends keyof Events>(name: N, handler: Events[N]): Disconnect;
            /**
                * Removes an event listener for the given event
                */
            off<N extends keyof Events>(name: N, handler: Events[N]): void;
            /**
                * Raises the given event
                */
            emit<N extends keyof Events>(name: N, payload?: SingleArgument<Events[N]>): void;
            /**
                * Returns true if there are any listeners for the given event
                * @param name The event name
                */
            hasListeners<N extends keyof Events>(name: N): boolean;
    }
    /**
        * A mixin that adds support for event emitting
        * @param Base The base class to mixin the EventEmitter into
        */
    export function EventsMixin<Events, TBase>(Base: ClassType<TBase>): ClassType<TBase & EventEmitter<Events>>;
}

declare module '@graspologic/common/utils/mixin' {
    export type Arguments<T> = [T] extends [(...args: infer U) => any] ? U : [T] extends [void] ? [] : [T];
    export type SingleArgument<T> = [T] extends [(arg: infer U) => any] ? U : [T] extends [void] ? [] : [T];
    export interface ClassType<T> {
        new (...args: any[]): T;
    }
    export function applyMixins<T>(derivedCtor: ClassType<T>, constructors: any[]): ClassType<T>;
}

