!function(){"use strict";const t=Object.freeze({emitDensitySnapshots:!1,densitySnapshotSamplingRate:4,edgeCut:.8,schedule:{}});var e,i;!function(t){t[t.Initial=0]="Initial";t[t.Liquid=1]="Liquid";t[t.Expansion=2]="Expansion";t[t.Cooldown=3]="Cooldown";t[t.Crunch=4]="Crunch";t[t.Simmer=5]="Simmer";t[t.Complete=6]="Complete"}(e||(e={})),function(t){t[t.CentroidJump=0]="CentroidJump";t[t.RandomJump=1]="RandomJump"}(i||(i={}));
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
class s{__init(){this._phase=e.Initial}__init2(){this._iteration=0}__init3(){this._phaseIteration=0}__init4(){this._temperature=0}__init5(){this._attraction=0}__init6(){this._damping=0}constructor(t=.8,i={}){s.prototype.__init.call(this),s.prototype.__init2.call(this),s.prototype.__init3.call(this),s.prototype.__init4.call(this),s.prototype.__init5.call(this),s.prototype.__init6.call(this),this._schedule={...r,...i},this._targetIterations=Object.values(this._schedule).map((t=>t.iterations)).reduce(((t,e)=>t+e),0),this._minEdges=20.000001,this._cutEnd=4e4*(1-t),this._cutLengthEnd=this._cutEnd<1?1:this._cutEnd,this._cutLengthStart=4*this._cutLengthEnd,this._cutOffLength=this._cutLengthStart,this._cutRate=(this._cutLengthStart-this._cutLengthEnd)/400,this.schedulePhase(e.Initial)}get phase(){return this._phase}get isComplete(){return this._phase===e.Complete}get iteration(){return this._iteration}get phaseIteration(){return this._phaseIteration}get targetPhaseIterations(){return null!=this.phase?this.schedule[this.phase].iterations:0}get targetIterations(){return this._targetIterations}get attraction(){return this._attraction}get temperature(){return this._temperature}get damping(){return this._damping}get minEdges(){return this._minEdges}get schedule(){return this._schedule}get cutEnd(){return this._cutEnd}get cutOffLength(){return this._cutOffLength}get neighborCutsEnabled(){switch(this.phase){case e.Liquid:case e.Expansion:case e.Cooldown:case e.Crunch:return!0;default:return!1}}tick(){return!this.isComplete&&(this._iteration+=1,this._phaseIteration+=1,this.phaseIteration>=this.targetPhaseIterations?this.handlePhaseComplete():this.handlePhaseTick(),!0)}handlePhaseTick(){this.phase===e.Expansion?(this._cutLengthEnd-=this._cutRate,this.attraction>1&&(this._attraction-=.05),this.minEdges>12&&(this._minEdges-=.05),this.damping>.1&&(this._damping-=.005)):this.phase===e.Cooldown&&(this.temperature>50&&(this._temperature-=10),this._cutOffLength>this._cutLengthEnd&&(this._cutOffLength-=2*this._cutRate),this.minEdges>1&&(this._minEdges-=.2))}handlePhaseComplete(){return this._phaseIteration=0,this.phase===e.Initial?this.schedulePhase(e.Liquid):this.phase===e.Liquid?this.schedulePhase(e.Expansion):this.phase===e.Expansion?(this._minEdges=12.0000000001,this.schedulePhase(e.Cooldown)):this.phase===e.Cooldown?(this._minEdges=1+1e-14,this._cutOffLength=this._cutLengthEnd,this.schedulePhase(e.Crunch)):this.phase===e.Crunch?(this._minEdges=99,this.schedulePhase(e.Simmer)):this.phase===e.Simmer?this.schedulePhase(e.Complete):void 0}schedulePhase(t){this._phase=t,function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}([this,"access",t=>t.schedule,"access",e=>e[t],"optionalAccess",t=>t.iterations])>0?(this._temperature=this.schedule[t].temperature,this._attraction=this.schedule[t].attraction,this._damping=this.schedule[t].damping):t===e.Initial?this.schedulePhase(e.Liquid):t===e.Liquid?this.schedulePhase(e.Expansion):t===e.Cooldown?this.schedulePhase(e.Crunch):t===e.Crunch?this.schedulePhase(e.Simmer):t===e.Simmer&&(this._phase=e.Complete)}get energyDistancePower(){switch(this.phase){case e.Liquid:return 4;case e.Expansion:return 2;default:return 1}}get useFineDensity(){return this.phase===e.Simmer}}const r={[e.Initial]:{iterations:1,temperature:2e3,attraction:10,damping:1},[e.Liquid]:{iterations:200,temperature:2e3,attraction:2,damping:1},[e.Expansion]:{iterations:200,temperature:2e3,attraction:10,damping:1},[e.Cooldown]:{iterations:200,temperature:2e3,attraction:1,damping:.1},[e.Crunch]:{iterations:50,temperature:250,attraction:1,damping:.25},[e.Simmer]:{iterations:100,temperature:250,attraction:.5,damping:0},[e.Complete]:{iterations:0,temperature:0,attraction:0,damping:0}};function o(t,e){return(e.x-t.x)**2+(e.y-t.y)**2}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
function n(t,e){return Math.random()*(e-t)+t}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */var a,h,c;!function(t){t[t.Circle=0]="Circle";t[t.Square=1]="Square";t[t.Diamond=2]="Diamond"}(a||(a={})),function(t){t[t.Float32=0]="Float32";t[t.Uint8=1]="Uint8";t[t.Uint32=2]="Uint32"}(h||(h={})),function(t){t[t.Boolean=0]="Boolean"}(c||(c={}));
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const l={[h.Float32]:4,[h.Uint32]:4,[h.Uint8]:1};function d(t){return l[t]}function f(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const u="__SPACER__";function p(){const t=new Map;function e(e,i,s,r){t.set(e,{name:e,size:s,type:i,options:r})}const i={addUint8:(t,s)=>(e(t,h.Uint8,1,s),i),addUint8Vec2:(t,s)=>(e(t,h.Uint8,2,s),i),addUint8Vec3:(t,s)=>(e(t,h.Uint8,3,s),i),addUint8Vec4:(t,s)=>(e(t,h.Uint8,4,s),i),addFloat32:(t,s)=>(e(t,h.Float32,1,s),i),addFloat32Vec2:(t,s)=>(e(t,h.Float32,2,s),i),addFloat32Vec3:(t,s)=>(e(t,h.Float32,3,s),i),addUint32:(t,s)=>(e(t,h.Uint32,1,s),i),build(){const e=new Map;let i=0;t.forEach((t=>{t.type===h.Float32&&(i+=y(t,i,e))})),t.forEach((t=>{t.type===h.Uint32&&(i+=y(t,i,e))})),t.forEach((t=>{t.type===h.Uint8&&(i+=y(t,i,e))}));const s=i%4;return i%4!=0&&(i+=y({name:u,type:h.Uint8,size:4-s},i,e)),e.stride=i,e}};return i}function y(t,e,i){const s=d(t.type),r=e/s;i.set(t.name,{name:t.name,size:t.size,type:t.type,hint:t.hint,typedOffset:r,offset:e});let o,n,a=0;for(o of f([t,"access",t=>t.options,"optionalAccess",t=>t.components])||[])i.set(o,{name:o,size:1,type:t.type,typedOffset:r+a,offset:e+a*s}),a++;for(n of f([t,"access",t=>t.options,"optionalAccess",t=>t.aliases])||[])i.set(n.name,{name:n.name,size:n.size||1,type:n.type,hint:n.hint,typedOffset:e/d(n.type),offset:e});return t.size*s}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const g=1e4;
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
class A{__init(){this.availableIndices=new Map}__init2(){this.capacity=0}constructor(t=1e4,e=!1){if(A.prototype.__init.call(this),A.prototype.__init2.call(this),null==t||t<=0)throw new Error(`Invalid capacity ${t}, capacity must be > 0`);this.capacity=t,e||this.reset(t)}reset(t){if(null==t||t<=0)throw new Error(`Invalid capacity ${t}, capacity must be > 0`);this.capacity=t;for(let t=0;t<this.capacity-1;t++)this.availableIndices.set(t,t+1);this.availableIndices.set(this.capacity-1,-1),this.nextAvailableIndex=0}grow(t){if(null==t||t<=0)throw new Error(`Invalid capacity ${t}, newCapacity must be > 0`);for(let e=this.capacity;e<t-1;e++)this.availableIndices.set(e,e+1);this.nextAvailableIndex=this.capacity,this.capacity=t}get hasFreeSpace(){return null!=this.nextAvailableIndex}free(t){if(null==t||t<0||t>this.capacity-1)throw new Error("Invalid index "+t);this.availableIndices.set(t,this.nextAvailableIndex),this.nextAvailableIndex=t}alloc(){if(null==this.nextAvailableIndex)throw new Error("error allocating index, no space available");const t=this.nextAvailableIndex;return this.nextAvailableIndex=this.availableIndices.get(t)>0?this.availableIndices.get(t):void 0,this.availableIndices.delete(t),t}*used(){if(0!==this.availableIndices.size||-1!==this.nextAvailableIndex&&void 0!==this.nextAvailableIndex)for(let t=0;t<this.capacity;++t)this.availableIndices.has(t)||this.nextAvailableIndex===t||(yield t);else for(let t=0;t<this.capacity;++t)yield t}has(t){return t>=0&&t<this.capacity&&!this.availableIndices.has(t)}get usedCount(){return this.capacity-this.availableIndices.size}destroy(){this.availableIndices=new Map,this.nextAvailableIndex=-1}}function m(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const _={shared:true,capacity:g};class b{__init(){this.onResizeHandlers=[]}constructor(t,e=_){this.layout=t,b.prototype.__init.call(this);const i=e.capacity||(m([e,"access",t=>t.buffer,"optionalAccess",t=>t.byteLength])||0)/t.stride||g;this.config={capacity:i,shared:"boolean"!=typeof e.shared||e.shared},this.bytesPerItem=t.stride,e.buffer&&(this._buffer=e.buffer),this.resize(this.config.capacity)}get buffer(){return this._buffer}get dataView(){return this._dataView}get float32Array(){return this._float32Array}get uint8Array(){return this._uint8Array}get uint32Array(){return this._uint32Array}onResize(t){return this.onResizeHandlers.push(t),()=>{this.onResizeHandlers=this.onResizeHandlers.filter((e=>e!==t))}}resize(t){if(this.count!==t){const e=this.count,i=this.buffer,s=t*this.bytesPerItem;if(s%4!=0)throw new Error(`buffer size ${s} must be word-aligned. size=${t}, bpi=${this.bytesPerItem}`);const r=this.config.shared&&"undefined"!=typeof SharedArrayBuffer?new SharedArrayBuffer(s):new ArrayBuffer(s);if(e>0&&t>e){new Uint8Array(r).set(new Uint8Array(i))}this._buffer=r,this._dataView=new DataView(r),this._float32Array=new Float32Array(r),this._uint8Array=new Uint8Array(r),this._uint32Array=new Uint32Array(r),this.onResizeHandlers.forEach((t=>t()))}else this.uint8Array||(this._uint8Array=new Uint8Array(this._buffer),this._uint32Array=new Uint32Array(this._buffer),this._float32Array=new Float32Array(this._buffer))}itemData(t){if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");const e=t*this.bytesPerItem;return this.buffer.slice(e,e+this.bytesPerItem)}getByteOffset(t){if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");return t*this.bytesPerItem}getByteOffsetAttr(t,e){const i=this.layout.get(e);if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");if(!i)throw new Error("Layout does not contain "+e);return t*this.bytesPerItem+m([i,"optionalAccess",t=>t.offset])}get count(){return this.buffer?this.buffer.byteLength/this.bytesPerItem:0}destroy(){this.config.capacity=0,this.resize(0)}slurp(t,e,i=0){this.uint8Array.set(new Uint8Array(e,i,this.bytesPerItem),t*this.bytesPerItem)}}class w{__init(){this._count=0}__init2(){this.onUpdateHandlers=[]}__init3(){this.onAddHandlers=[]}__init4(){this.onRemoveHandlers=[]}constructor(t,e){w.prototype.__init.call(this),w.prototype.__init2.call(this),w.prototype.__init3.call(this),w.prototype.__init4.call(this),this._store=t,this.slotAllocator=e,this._count=e.usedCount}get store(){return this._store}get count(){return this._count}itemIds(){return this.slotAllocator.used()}onAttributeUpdated(t){return this.onUpdateHandlers.push(t),()=>{this.onUpdateHandlers=this.onUpdateHandlers.filter((e=>e!==t))}}onAddItem(t){return this.onAddHandlers.push(t),()=>{this.onAddHandlers=this.onAddHandlers.filter((e=>e!==t))}}onRemoveItem(t){return this.onRemoveHandlers.push(t),()=>{this.onRemoveHandlers=this.onRemoveHandlers.filter((e=>e!==t))}}add(t=!0){if(!this.slotAllocator.hasFreeSpace){const t=this.store.count+this.store.config.capacity;this.store.resize(t),this.slotAllocator.grow(t)}const e=this.slotAllocator.alloc();return this._count++,t&&this.fireAddHandlers(e),e}remove(t,e=!0){e&&this.fireRemoveHandlers(t),this.slotAllocator.free(t),this._count--}reset(){const t=this._store.config.capacity;for(const t of this.itemIds())this.fireRemoveHandlers(t);this._store.resize(t),this.slotAllocator.reset(t),this._count=0}destroy(){this.store.destroy(),this.slotAllocator.destroy(),this.onRemoveHandlers=[],this.onAddHandlers=[],this.onUpdateHandlers=[]}notify(t,e){for(const i of this.onUpdateHandlers)try{i(t,e)}catch(t){console.error("caught error",t)}}fireAddHandlers(t){this.onAddHandlers.forEach((e=>e(t)))}fireRemoveHandlers(t){this.onRemoveHandlers.forEach((e=>e(t)))}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function O(t,e,i=[]){class s{__init(){this.storeId=-1}__init2(){this.byteOffset=0}__init3(){this.wordOffset=0}constructor(t,r=-1){s.prototype.__init.call(this),s.prototype.__init2.call(this),s.prototype.__init3.call(this);if(null==t){this.isFlushNeeded=!0;const t=new ArrayBuffer(e.stride);this.uint8Array=new Uint8Array(t),this.uint32Array=new Uint32Array(t),this.float32Array=new Float32Array(t),this.propertyBag={}}else this.isFlushNeeded=!1,this.connect(r,t);i.forEach((t=>{if("string"!=typeof t){const{name:e,initialValue:i,ephemeral:s}=t;s?this[e]=i:this.propertyBag[e]=i}}))}get type(){return t}get layout(){return e}get buffer(){return this.uint8Array.buffer}connect(t,e){this.storeId!==t&&(this.byteOffset=t*e.store.bytesPerItem,this.wordOffset=this.byteOffset/4,this.storeId=t,this.isFlushNeeded&&(e.slurp(t,this.uint8Array.buffer,this.propertyBag),this.isFlushNeeded=!1),this.propertyBag=e.propertyBags[t]),this.store=e,this.uint32Array=e.store.uint32Array,this.float32Array=e.store.float32Array,this.uint8Array=e.store.uint8Array}handleAttributeUpdated(t){}}const r=s.prototype;return e.forEach((t=>{if(t.name===u)return;const{name:e,size:i,type:s,typedOffset:o,hint:n}=t;let a,l;s===h.Float32?1===i?(l=function(){return this.float32Array[this.wordOffset+o]},a=function(t){this.float32Array[this.wordOffset+o]=t||0,this.handleAttributeUpdated(e)}):2===i?(l=function(){return[this.float32Array[this.wordOffset+o],this.float32Array[this.wordOffset+o+1]]},a=function(t){this.float32Array[this.wordOffset+o]=t[0]||0,this.float32Array[this.wordOffset+o+1]=t[1]||0,this.handleAttributeUpdated(e)}):3===i&&(l=function(){return[this.float32Array[this.wordOffset+o],this.float32Array[this.wordOffset+o+1],this.float32Array[this.wordOffset+o+2]]},a=function(t){this.float32Array[this.wordOffset+o]=t[0]||0,this.float32Array[this.wordOffset+o+1]=t[1]||0,this.float32Array[this.wordOffset+o+2]=t[2]||0,this.handleAttributeUpdated(e)}):s===h.Uint8?1===i?n===c.Boolean?(l=function(){return this.uint8Array[this.byteOffset+o]>0},a=function(t){this.uint8Array[this.byteOffset+o]=t?1:0,this.handleAttributeUpdated(e)}):(l=function(){return this.uint8Array[this.byteOffset+o]},a=function(t){this.uint8Array[this.byteOffset+o]=t,this.handleAttributeUpdated(e)}):2===i?(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.handleAttributeUpdated(e)}):3===i?(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1],this.uint8Array[this.byteOffset+o+2]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.uint8Array[this.byteOffset+o+2]=t[2]||0,this.handleAttributeUpdated(e)}):4===i&&(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1],this.uint8Array[this.byteOffset+o+2],this.uint8Array[this.byteOffset+o+3]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.uint8Array[this.byteOffset+o+2]=t[2]||0,this.uint8Array[this.byteOffset+o+3]=t[3]||0,this.handleAttributeUpdated(e)}):s===h.Uint32&&1===i&&(l=function(){return this.uint32Array[this.wordOffset+o]},a=function(t){this.uint32Array[this.wordOffset+o]=t||0,this.handleAttributeUpdated(e)}),a&&r.__defineSetter__(e,a),l&&r.__defineGetter__(e,l)})),i.forEach((t=>{const e="string"==typeof t?t:t.name;"string"!=typeof t&&Boolean(t.ephemeral)||(r.__defineGetter__(e,(function(){return this.propertyBag[e]})),r.__defineSetter__(e,(function(t){this.propertyBag[e]=t})))})),s}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class I extends w{__init(){this.propertyBags={}}constructor(t,e,i=new A(e.config.capacity)){super(e,i),I.prototype.__init.call(this),this.items=new Array(e.config.capacity),this.itemClass=t,e.onResize((()=>{this.items.forEach((t=>t&&t.connect(t.storeId,this)))}))}receive(t){const e=this.add(!1);return this.slurp(e,t.buffer,t.byteOffset),t.connect(e,this),this.fireAddHandlers(e),e}itemAt(t){return this.items[t]||(this.items[t]=this.createConnectedItem(t))}createConnectedItem(t){return this.propertyBags[t]||(this.propertyBags[t]={}),new this.itemClass(this,t)}*[Symbol.iterator](){let t;for(t of this.itemIds())yield this.itemAt(t)}*scan(){let t,e;if(this.count>0&&(e=this.createConnectedItem(0)),e)for(t of this.itemIds())this.propertyBags[t]||(this.propertyBags[t]={}),e.connect(t,this),yield e}slurp(t,e,i={},s=0){this.store.slurp(t,e,s),this.propertyBags[t]=i||void 0,this.notify(t)}add(t=!0){const e=super.add(!1);return this.propertyBags[e]={},t&&this.fireAddHandlers(e),e}remove(t){super.remove(t),this.propertyBags[t]=void 0}reset(){super.reset(),this.propertyBags={}}destroy(){super.destroy(),this.propertyBags={}}}function E(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const v=Float32Array.BYTES_PER_ELEMENT;class U{getByteOffset(t,e){const i=t.layout.get(e);return t.byteOffset+i.offset}getTypedOffset(t,e){return t.layout.get(e).typedOffset}getWordOffset(t,e){return this.getByteOffset(t,e)/v}readProperty(t,e){const i=t.store.propertyBags[t.storeId];if(null!=i)return i[e]}writeProperty(t,e,i){let s=t.store.propertyBags[t.storeId];s||(s={},t.store.propertyBags[t.storeId]=s),s[e]=i,E([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readNumber(t,e){if(t.layout.has(e)){const i=t.layout.get(e);return i.type===h.Uint8?this.readUint8Attr(t,e):i.type===h.Uint32?this.readUint32Attr(t,e):this.readFloat32Attr(t,e)}return this.readProperty(t,e)||0}writeNumber(t,e,i){const s=t.layout.get(e);s?s.type===h.Uint8?this.writeUint8Attr(t,e,i):s.type===h.Uint32?this.writeUint32Attr(t,e,i):this.writeFloat32Attr(t,e,i):this.writeProperty(t,e,i),E([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readString(t,e){return this.readProperty(t,e)}writeString(t,e,i){this.writeProperty(t,e,i),E([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readBoolAttr(t,e){return Boolean(this.readUint8Attr(t,e))}writeBoolAttr(t,e,i){this.writeUint8Attr(t,e,i?1:0)}readFloat32Attr(t,e){return t.float32Array[this.getWordOffset(t,e)]}writeFloat32Attr(t,e,i){t.float32Array[this.getWordOffset(t,e)]=i}readFloat32Vec2Attr(t,e){const i=this.getWordOffset(t,e);return[t.float32Array[i],t.float32Array[i+1]]}writeFloat32Vec2Attr(t,e,i,s){const r=this.getWordOffset(t,e);t.float32Array[r]=i,t.float32Array[r+1]=s}writeFloat32Vec2Offset(t,e,i,s){t.float32Array[t.wordOffset+e]=i,t.float32Array[t.wordOffset+e+1]=s}copyFloat32Vec3Attr(t,e,i){const s=this.getWordOffset(t,e),r=t.float32Array.subarray(s,s+3);return t.float32Array.set(r,this.getWordOffset(t,i)),r}copyFloat32Vec3Offset(t,e,i){const s=t.float32Array.subarray(t.wordOffset+e,t.wordOffset+e+3);return t.float32Array.set(s,t.wordOffset+i),s}writeFloat32Vec3Attr(t,e,i,s,r){const o=this.getWordOffset(t,e);t.float32Array[o]=i,t.float32Array[o+1]=s,t.float32Array[o+2]=r}writeFloat32Vec3Offset(t,e,i,s,r){t.float32Array[t.wordOffset+e]=i,t.float32Array[t.wordOffset+e+1]=s,t.float32Array[t.wordOffset+e+2]=r}readFloat32Vec3Attr(t,e){const i=this.getWordOffset(t,e);return[t.float32Array[i],t.float32Array[i+1],t.float32Array[i+2]]}readUint8Attr(t,e){return t.uint8Array[this.getByteOffset(t,e)]}writeUint8Attr(t,e,i){t.uint8Array[this.getByteOffset(t,e)]=i}readUint8Vec2Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1]]}writeUint8Vec2Attr(t,e,i,s){const r=this.getByteOffset(t,e);t.uint8Array[r]=i,t.uint8Array[r+1]=s}readUint8Vec3Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1],t.uint8Array[i+2]]}writeUint8Vec3Attr(t,e,i,s,r){const o=this.getByteOffset(t,e);t.uint8Array[o]=i,t.uint8Array[o+1]=s,t.uint8Array[o+2]=r}readUint8Vec4Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1],t.uint8Array[i+2],t.uint8Array[i+3]]}writeUint8Vec4Attr(t,e,i,s,r,o){const n=this.getByteOffset(t,e);t.uint8Array[n]=i,t.uint8Array[n+1]=s,t.uint8Array[n+2]=r,t.uint8Array[n+3]=o}readUint32Attr(t,e){return t.uint32Array[this.getWordOffset(t,e)]}writeUint32Attr(t,e,i){t.uint32Array[this.getWordOffset(t,e)]=i}writeUint32Offset(t,e,i){t.uint32Array[t.wordOffset+e]=i}copyUint32Offset(t,e,i){t.uint32Array[t.wordOffset+i]=t.uint32Array[t.wordOffset+e]}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const x=Symbol("@graspologic::node"),C=p().addFloat32("weight").addFloat32("radius",{aliases:[{name:"size",type:h.Float32}]}).addUint8("fixed").addUint32("color").addUint32("color.start").addFloat32Vec2("color.tween",{components:["color.duration","color.startTime"]}).addFloat32Vec3("position",{components:["x","y","z"]}).addFloat32Vec3("position.start").addFloat32Vec2("position.tween",{components:["position.duration","position.startTime"]}).addFloat32("saturation").addUint8("shape").addUint8("visible",{hint:c.Boolean}).addUint8Vec3("pickingColor").build();function P(t){return function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}([C,"access",t=>t.get,"call",e=>e(t),"optionalAccess",t=>t.typedOffset])}const F=C.get("position").typedOffset,B=C.get("radius").typedOffset,k=C.get("shape").typedOffset,V=C.get("weight").typedOffset,L=C.get("color").typedOffset,S=C.get("visible").typedOffset,z=O(x,C,["id","group","label","data",{name:"mass",ephemeral:!0,initialValue:0},{name:"dx",ephemeral:!0,initialValue:0},{name:"dy",ephemeral:!0,initialValue:0},{name:"old_dx",ephemeral:!0,initialValue:0},{name:"old_dy",ephemeral:!0,initialValue:0},{name:"convergence",ephemeral:!0,initialValue:1}]);class N extends z{load(t){this.propertyBag=this.store.propertyBags[this.storeId]||{},this.store.propertyBags[this.storeId]=this.propertyBag,this.propertyBag.id=t.id,this.propertyBag.group=t.group,this.propertyBag.label=t.label,this.float32Array[this.wordOffset+B]=t.size||t.radius||0,this.float32Array[this.wordOffset+F]=t.x||0,this.float32Array[this.wordOffset+F+1]=t.y||0,this.float32Array[this.wordOffset+F+2]=t.z||0,this.float32Array[this.wordOffset+V]=t.weight||1,this.uint32Array[this.wordOffset+L]=t.color||0,this.uint8Array[this.byteOffset+k]=function(t){if("string"==typeof t){if("square"===(t=t.toLocaleLowerCase()))return a.Square;if("diamond"===t)return a.Diamond}else if(t===a.Square||t===a.Diamond||t===a.Circle)return t;return a.Circle}(t.shape),this.uint8Array[this.byteOffset+S]=1}}function R(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const j="color",H="color.start",M="color.tween",T="position",W="position.start",D="position.tween",G=P(T),q=P(W),$=P(D),J=P(j),X=P(H),Y=P(M),K=new U;const Q=class extends N{animatePosition(t,e=0){K.copyFloat32Vec3Offset(this,G,q),this.handleAttributeUpdated(W),K.writeFloat32Vec2Offset(this,$,e,R([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(D),K.writeFloat32Vec3Offset(this,G,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(T)}animateColor(t,e=0){K.copyUint32Offset(this,J,X),this.handleAttributeUpdated(H),K.writeFloat32Vec2Offset(this,Y,e,R([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(M),K.writeUint32Offset(this,J,t),this.handleAttributeUpdated(j)}load(t){super.load(t),this.handleAttributeUpdated("*")}handleAttributeUpdated(t){this.store&&this.store.notify(this.storeId,t)}};function Z(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function tt(t){const e=new b(C,t),i=new A(e.config.capacity,0!==Z([t,"optionalAccess",t=>t.capacity])&&Boolean(Z([t,"optionalAccess",t=>t.allocatedOnCreate]))),s=!1!==Z([t,"optionalAccess",t=>t.animation])?Q:N;return new I(s,e,i)}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const et=Symbol("@graspologic::edge"),it=p().addUint32("sourceIndex").addUint32("targetIndex").addFloat32("weight").addFloat32("trueWeight").addFloat32("saturation").addFloat32("saturation2").addUint32("color").addUint32("color2").addUint8("visible",{hint:c.Boolean}).addFloat32Vec3("sourcePosition.start").addFloat32Vec3("sourcePosition").addFloat32Vec2("sourcePosition.tween",{components:["sourcePosition.duration","sourcePosition.startTime"]}).addFloat32Vec3("targetPosition.start").addFloat32Vec3("targetPosition").addFloat32Vec2("targetPosition.tween",{components:["targetPosition.duration","targetPosition.startTime"]}).build();function st(t){return function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}([it,"access",t=>t.get,"call",e=>e(t),"optionalAccess",t=>t.typedOffset])}const rt=it.get("sourceIndex").typedOffset,ot=it.get("targetIndex").typedOffset,nt=it.get("color").typedOffset,at=it.get("color2").typedOffset,ht=it.get("weight").typedOffset,ct=O(et,it,["id","source","target","data"]);class lt extends ct{load(t,e,i=1){this.propertyBag=this.store.propertyBags[this.storeId]||{},this.store.propertyBags[this.storeId]=this.propertyBag,this.propertyBag.source=t.source,this.propertyBag.target=t.target,this.uint32Array[this.wordOffset+rt]=e.get(t.source),this.uint32Array[this.wordOffset+ot]=e.get(t.target),this.float32Array[this.wordOffset+ht]=null!=t.weight?t.weight:i,this.uint32Array[this.wordOffset+nt]=t.color||t.sourceColor||0,this.uint32Array[this.wordOffset+at]=t.color2||t.targetColor||0}}function dt(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const ft="sourcePosition",ut="sourcePosition.start",pt="sourcePosition.tween",yt="targetPosition",gt="targetPosition.start",At="targetPosition.tween",mt=st(ft),_t=st(ut),bt=st(pt),wt=st(yt),Ot=st(gt),It=st(At),Et=new U;const vt=class extends lt{animateSourcePosition(t,e){Et.copyFloat32Vec3Offset(this,mt,_t),this.handleAttributeUpdated(ut),Et.writeFloat32Vec2Offset(this,bt,e||0,dt([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(pt),Et.writeFloat32Vec3Offset(this,mt,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(ft)}animateTargetPosition(t,e){Et.copyFloat32Vec3Offset(this,wt,Ot),this.handleAttributeUpdated(gt),Et.writeFloat32Vec2Offset(this,It,e||0,dt([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(At),Et.writeFloat32Vec3Offset(this,wt,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(yt)}load(t,e,i=1){super.load(t,e,i),this.handleAttributeUpdated("*")}handleAttributeUpdated(t){this.store&&this.store.notify(this.storeId,t)}};function Ut(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function xt(t){const e=new b(it,t),i=new A(e.config.capacity,0!==Ut([t,"optionalAccess",t=>t.capacity])&&Boolean(Ut([t,"optionalAccess",t=>t.allocatedOnCreate]))),s=!1!==Ut([t,"optionalAccess",t=>t.animation])?vt:lt;return new I(s,e,i)}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const Ct=Object.freeze({defaultEdgeWeight:1,shareable:!0});function Pt(t,{shareable:e=Ct.shareable,randomize:i,defaultEdgeWeight:s=Ct.defaultEdgeWeight}=Ct){const r=function(t,e,i=!0){return new Bt(tt({capacity:t,shared:i,allocatedOnCreate:!0}),xt({capacity:e,shared:i,allocatedOnCreate:!0}))}(t.nodes.length,t.edges.length,e);let o=0;const a=new Map;if(t.nodes.length>0){let e,s;for(e of(o=0,r.nodes.scan())){if(o>=t.nodes.length)break;s=t.nodes[o],t.edges.length>0&&a.set(s.id,o),e.connect(o,r.nodes),e.load(s),i&&0===e.x&&0===e.y&&(e.x=n(i[0],i[1]),e.y=n(i[2],i[3])),++o}}if(t.edges.length>0){let e;for(e of(o=0,r.edges.scan())){if(o>=t.edges.length)break;e.connect(o,r.edges),e.load(t.edges[o],a,s),++o}}return r}function Ft(t,e){const i=new Map;let s;for(s of t)i.set(s.storeId,{});let r,o,n,a,h,c=1e-6;for(n of e){const{sourceIndex:t,targetIndex:e,weight:s}=n;r=i.get(t),o=i.get(e),s>c&&(c=s),r[e]=s,o[t]=s}for(a of i.values())for(h of Object.keys(a))a[parseInt(h,10)]/=c;return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class Bt{constructor(t,e){this._nodes=t,this._edges=e}get nodes(){return this._nodes}get edges(){return this._edges}static intern(t,e=Ct){return Pt(t,e)}serialize(){return{nodes:this.nodes.store.buffer,edges:this.edges.store.buffer}}static deserialize(t){const e=tt({buffer:t.nodes,allocatedOnCreate:!0}),i=xt({buffer:t.edges,allocatedOnCreate:!0});return new Bt(e,i)}getNeighbors(t){const e=this.getAdjacencyMap(!1).get(t);return e?Object.keys(e).map((t=>parseInt(t,10))):[]}getNeighborsObjective(t){const e=this.getAdjacencyMap(!0).get(t);if(!e)throw new Error("could not get adjacency for node "+t);return Object.keys(e).map((t=>parseInt(t,10)))}getEdgeWeight(t,e){const i=this.getAdjacencyMap(!1).get(t);if(!i)throw new Error("could not get adjacency for node "+t);return i[e]}getEdgeWeightObjective(t,e){const i=this.getAdjacencyMap(!0).get(t);if(!i)throw new Error("could not get objective adjacency for node "+t);return i[e]}getNeighborhoodCentroid(t){const e=this.getNeighbors(t),i=this.nodes.itemAt(t);if(i){if(0===e.length)return{x:i.x,y:i.y};{const s=[i],r=[1];e.forEach((e=>{const i=this.nodes.itemAt(e),o=this.getEdgeWeight(t,e);s.push(i),r.push(o)}));return function(t,e){if(0===t.length)throw new Error("could not compute centroid out of zero points");if(t.length!==e.length)throw new Error("points array and weights array must be the same length");let i=0,s=0,r=0;return t.forEach(((t,o)=>{const n=e[o];r+=n,i+=t.x*n,s+=t.y*n})),{x:i/r,y:s/r}}(s,r)}}throw new Error("could not get node "+t)}pruneEdge(t,e){const i=this.getAdjacencyMap(!1).get(t),s=this.getAdjacencyMap(!1).get(e);if(!i||!s)throw new Error(`could not get edge for (${t}, ${e})`);delete i[e],delete s[t]}getAdjacencyMap(t){return this._originalAdjacency||(this._originalAdjacency=Ft(this.nodes,this.edges)),this._adjacency||t||(this._adjacency=Ft(this.nodes,this.edges)),t?this._originalAdjacency:this._adjacency}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const kt=1e3,Vt=10,Lt=function(){const t=[];for(let e=-10;e<=Vt;++e){t[e+Vt]=[];for(let i=-10;i<=Vt;++i){const s=Vt,r=Math.abs(e),o=Math.abs(i),n=(s-r)/s*((s-o)/s);t[e+Vt][i+Vt]=n}}return t}();class St{constructor(){St.prototype.__init.call(this),St.prototype.__init2.call(this),St.prototype.__init3.call(this),St.prototype.__init4.call(this)}__init(){this.initialLoad=!0}__init2(){this._bitmap=function(){const t=[];for(let e=0;e<kt;++e){const e=new Float32Array(kt);t.push(e);for(let t=0;t<kt;++t)e[t]=0}return t}()}__init3(){this._bins=function(){const t=[];for(let e=0;e<kt;++e){const e=[];t.push(e);for(let t=0;t<kt;++t)e.push({})}return t}()}__init4(){this._trackedNodes=new Set}contains(t){return this._trackedNodes.has(t.storeId)}get size(){return this._trackedNodes.size}get bitmap(){return this._bitmap}get checksum(){let t=0;for(let e=0;e<kt;++e)for(let i=0;i<kt;++i)t+=this._bitmap[e][i];return t}add(t){if(this.contains(t))throw new Error(`cannot add node ${t.storeId} to density grid twice`);this._trackedNodes.add(t.storeId),this.addToBins(t),this.addToBitmap(t)}subtract(t){if(!this.contains(t))throw new Error(`cannot remove node ${t.storeId}from density grid`);this._trackedNodes.delete(t.storeId),this.subtractFromBitmap(t),this.subtractFromBins(t)}addToBitmap(t){const e=zt(t.x)-Vt,i=zt(t.y)-Vt;for(let t=0;t<=20;++t)for(let s=0;s<=20;++s){const r=e+s,o=i+t;Rt(r,o)&&(this._bitmap[o][r]+=Lt[t][s])}}subtractFromBitmap(t){const e=zt(t.x)-Vt,i=zt(t.y)-Vt;for(let t=0;t<=20;++t)for(let s=0;s<=20;++s){const r=e+s,o=i+t;Rt(r,o)&&(this.bitmap[o][r]-=Lt[t][s])}}addToBins(t){const e=zt(t.x),i=zt(t.y);Nt(e,i);this._bins[i][e][t.storeId]=t}subtractFromBins(t){const e=zt(t.x),i=zt(t.y);Nt(e,i);const s=this._bins[i][e];s[t.storeId]&&delete s[t.storeId]}getDensity(t,e,i=!1){if(Number.isNaN(e.x)||Number.isNaN(e.y))throw new Error("test position has NaN component");return function(t){const e=10,i=zt(t.x),s=zt(t.y),r=t=>t>kt-e||t<e;return!r(i)&&!r(s)}(e)?i?this.getFineDensity(t,e):this.getCoarseDensity(t,e):1e4}getFineDensity(t,e){const i=zt(e.x),s=zt(e.y);let r,n,a,h=0;for(r=s-1;r<=s+1;++r)for(n=i-1;n<=i+1;++n){const i=this._bins[r][n];for(a of Object.keys(i))if(parseInt(a,10)!==t.storeId){h+=1e-4/(o(e,i[a])+1e-50)}}return h}getOverlap(t,e){const i=zt(e.x),s=zt(e.y);let r,n,a,h=0;for(r=s-1;r<=s+1;++r)for(n=i-1;n<=i+1;++n){const i=this._bins[r][n];for(a of Object.keys(i))if(parseInt(a,10)!==t.storeId){const s=i[a],r=(c=e,l=s,Math.sqrt(o(c,l)))-t.size-s.size;r<0&&(h+=Math.abs(r))}}var c,l;return h}getCoarseDensity(t,e){const i=zt(e.x),s=zt(e.y),r=this.getDensityToExcludeAtPoint(t,e);return(this._bitmap[s][i]-r)**2}getDensityToExcludeAtPoint(t,e){const i=zt(t.x),s=zt(t.y),r=zt(e.x)-i,o=zt(e.y)-s;return!this.initialLoad&&this.contains(t)&&Math.abs(r)<Vt&&Math.abs(o)<Vt?Lt[Math.floor(Vt+o)][Math.floor(Vt+r)]:0}}function zt(t){const e=Math.floor(.25*(t+2e3+.5));return Math.max(0,Math.min(e,999))}function Nt(t,e){if(t>=kt||e>=kt)throw new Error(`invalid grid storeId: (${t}, ${e})`)}function Rt(t,e){return e>=0&&t>=0&&e<kt&&t<kt}var jt,Ht;!function(t){t.Configure="CONFIGURE";t.Execute="EXECUTE";t.Halt="HALT";t.Resume="RESUME";t.Reset="RESET";t.Error="ERROR";t.Progress="PROGRESS";t.Complete="COMPLETE"}(jt||(jt={}));
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
class Mt{constructor(){Mt.prototype.__init.call(this)}__init(){this.listeners={}}on(t,e){return this.listeners[t]=this.listeners[t]||[],this.listeners[t].push(e),()=>this.off(t,e)}off(t,e){const i=this.listeners[t];if(i){const t=i.indexOf(e);t>=0&&i.splice(t,1)}}emit(t,e){const i=this.listeners[t];i&&i.forEach((t=>{t.call(this,e)}))}hasListeners(t){this.listeners=this.listeners||{};const e=this.listeners[t];return!!e&&e.length>0}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */!function(t){t[t.Graph=0]="Graph";t[t.Viewport=1]="Viewport";t[t.None=2]="None"}(Ht||(Ht={})),
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
Ht.Graph;class Tt extends Mt{__init(){this._halted=!1}__init2(){this._complete=!1}constructor(t,e,i,s){super(),Tt.prototype.__init.call(this),Tt.prototype.__init2.call(this),this._clock=i,this._graph=t,this._global=s,this._configuration=e,this.executeStep=this.executeStep.bind(this),s.console.log(`create new ${this.getName()} instance`,this._configuration)}halt(){this._halted=!0}get isHalted(){return this._halted}get isComplete(){return this._complete}get clock(){return this._clock}get graph(){return this._graph}get globalObject(){return this._global}get configuration(){return this._configuration}configure(t){this._configuration={...this.defaultConfiguration,...t}}execute(){return this._global.console.log(`execute ${this.getName()}, %s nodes, %s edges`,this.graph.nodes.count,this.graph.edges.count),this._halted=!1,this._complete=!1,this.clearTickListener(),new Promise((t=>{this.executeStep(),this._tickListener=this.on("tick",(()=>{this._complete&&(t(this.getProgress()),this.clearTickListener())}))}))}clearTickListener(){this._tickListener&&(this._tickListener(),this._tickListener=void 0)}executeStep(){this.performUnitOfWork();const t=this._clock.tick();t||(this._complete=!0),t&&!this._halted&&this._global.setTimeout(this.executeStep,0),this.emit("tick",this.getProgress())}}class Wt extends Tt{constructor(t,e,i,s,r){super(t,e,i,s),this._densityGrid=r;let o,a=!0;for(o of this.graph.nodes)if(0!==o.x||0!==o.y){a=!1;break}if(a)for(o of(this.globalObject.console.log("randomizing layouts"),this.graph.nodes))o.x=n(0,1024),o.y=n(0,1024);this.initializeDensityGrid()}getName(){return"OpenOrd"}get densityGrid(){return this._densityGrid}get defaultConfiguration(){return t}getProgress(){const{phase:t,iteration:e,phaseIteration:i,targetPhaseIterations:s,targetIterations:r}=this.clock,{emitDensitySnapshots:o,densitySnapshotSamplingRate:n,densitySnapshotEmitRate:a,emitEnergy:h,emitObjectiveEnergy:c}=this.configuration,l={clock:{phase:t,iteration:e,phaseIteration:i,targetIterations:r,targetPhaseIterations:s},densityGrid:{},metrics:{}};if(o&&(null!=a&&this.clock.iteration%a!=0||(l.densityGrid.bitmap=function(t,e){const i=t.bitmap,s=[];for(let t=0;t<i.length;t+=e){const r=[];s.push(r);for(let s=0;s<i[0].length;s+=e)r.push(i[t][s])}return s}(this.densityGrid,n))),h){const t=this.energy;l.metrics.energy=t}if(c){const[t,e,i,s]=this.objectiveEnergy;l.metrics.objectiveEnergy=t,l.metrics.attractiveEnergy=e,l.metrics.repulsiveEnergy=i,l.metrics.overlapEnergy=s}return l}performUnitOfWork(){this.configuration.iterativeForceModel?this.performIterativeUnitOfWork():this.performConcurrentUnitOfWork()}initializeDensityGrid(){let t;for(t of this.graph.nodes)this.densityGrid.add(t)}performConcurrentUnitOfWork(){let t;for(t of this.graph.nodes){const e=this.computeNodeUpdate(t);this.applyUpdate(e)}}performIterativeUnitOfWork(){let t;for(t of this.computeIterativeUpdates())this.applyUpdate(t)}*computeIterativeUpdates(){let t;for(t of this.graph.nodes)yield this.computeNodeUpdate(t)}computeNodeUpdate(t){const[e,s]=this.computeCentroidJump(t),r=this.computeNodePosEnergy(t,e),o=function(t,e){const i=Math.random(),s=Math.random();return{x:t.x+(.5-i)*e,y:t.y+(.5-s)*e}}(e,.01*this.clock.temperature),n=this.computeNodePosEnergy(t,o);return n<r?{node:t,kind:i.RandomJump,position:o,energy:n}:{node:t,kind:i.CentroidJump,position:e,energy:r,prunedEdge:s}}computeNodePosEnergy(t,e){return this.nodeAttractiveForce(t,e)+this.nodeRepulsiveForce(t,e)}nodeAttractiveForce(t,e){const i=this.clock.energyDistancePower;let s,r,n,a=0;for(s of this.graph.getNeighbors(t.storeId))if(r=this.graph.nodes.itemAt(s),n=this.graph.getEdgeWeight(t.storeId,s),null!=n){a+=n*o(e,r)**i}return a}nodeRepulsiveForce(t,e){return this.densityGrid.getDensity(t,e,this.clock.useFineDensity)}computeCentroidJump(t){const e=this.graph.getNeighborhoodCentroid(t.storeId),i=function(t,e,i){if(i<0||i>1)throw new Error("jump factor must be between 0-1");{const s=1-i;return{x:t.x*s+i*e.x,y:t.y*s+i*e.y}}}(t,e,this.clock.damping);return[i,o(e,i)>0&&(()=>{const e=this.clock.cutEnd<39500.9;return this.clock.neighborCutsEnabled&&e&&(()=>this.graph.getNeighbors(t.storeId).length>this.clock.minEdges)()})()?this.getEdgeToCut(t,e):void 0]}getEdgeToCut(t,e){const i=this.graph.getNeighbors(t.storeId),s=Math.sqrt(i.length);let r,n=0;return i.forEach((t=>{const i=this.graph.nodes.itemAt(t),a=o(e,i)*s;a>n&&a>this.clock.cutOffLength&&(n=a,r=t)})),r}applyUpdate({node:t,position:e,prunedEdge:i}){this.densityGrid.contains(t)&&this.densityGrid.subtract(t),t.x=e.x,t.y=e.y,i&&this.graph.pruneEdge(t.storeId,i),this.densityGrid.add(t)}get energy(){let t,e=0;for(t of this.graph.nodes)e+=this.computeNodePosEnergy(t,t);return e}get objectiveEnergy(){let t,i,s=0,r=0,n=.001;for(t of this.graph.nodes)for(i of(r+=this.densityGrid.getDensity(t,t,!1),this.clock.phase&&this.clock.phase>e.Liquid&&(n+=this.densityGrid.getOverlap(t,t)),this.graph.getNeighborsObjective(t.storeId).map((t=>this.graph.nodes.itemAt(t))))){s+=o(t,i)*this.graph.getEdgeWeightObjective(t.storeId,i.storeId)}return[s+r,s,r,n]}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */let Dt,Gt;function qt(){null!=Dt?Dt.halt():self.console.log("could not stop oord, instance not defined")}function $t(t,e){self.postMessage({type:t,payload:e},void 0)}self.console.log("openord worker bootstrapping"),self.onmessage=e=>{const{type:i,payload:r}=e.data;switch(self.console.log("openord receive message",i),i){case jt.Configure:!function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}}([Dt,"optionalAccess",t=>t.configure,"call",t=>t(r)]);break;case jt.Execute:qt(),function(){null!=Gt&&Gt();Gt=void 0,Dt=void 0}(),function({graph:e,configuration:i}){try{Dt=function(e,i={},r=window){const o={...t,...i};return new Wt(e,o,new s(i.edgeCut,i.schedule),r,new St)}(Bt.deserialize(e),i,self),Gt=Dt.on("tick",(t=>{$t(jt.Progress,t)})),Dt.execute().then((t=>{Gt&&Gt(),Dt=void 0,Gt=void 0,$t(jt.Complete,t)}))}catch(t){self.console.log("caught error",t),self.postMessage(jt.Error,t)}}(r);break;case jt.Halt:null!=Dt?Dt.halt():self.console.log("could not halt oord, instance not defined");break;case jt.Reset:qt(),Dt=void 0,Gt=void 0;break;case jt.Resume:null!=Dt?Dt.isHalted||Dt.isComplete?self.console.log("executor is not in a resumable state"):Dt.execute():self.console.log("could not resume executor, instance not defined");break;default:self.console.log("openord worker - unhandled message type",i)}}}();
