// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@graspologic/graph
//   ../@graspologic/layout-core

declare module '@graspologic/layout-openord' {
    export * from '@graspologic/layout-openord/types';
    export * from '@graspologic/layout-openord/executeLayout';
    export * from '@graspologic/layout-openord/OpenOrdLayoutExecutor';
}

declare module '@graspologic/layout-openord/types' {
    import { Position, Node, NodeIndex } from '@graspologic/graph';
    /**
        * @internal
        *
        * The configuration for the OpenOrd layout
        */
    export interface OpenOrdConfiguration {
            /**
                * The percentage of edges to exclude from the layout
                * @defaultValue 0.8
                */
            edgeCut: number;
            /**
                * If true, forces will be applied in series rather than concurrently
                *
                * @defaultValue false
                */
            iterativeForceModel?: boolean;
            /**
                * The scheduling for the various phases of the layout
                */
            schedule: Partial<Record<AnnealingPhase, PhaseSchedule>>;
            /**
                * If true, density snapshots will be emitted
                */
            emitDensitySnapshots?: boolean;
            /**
                * If emitDensitySnapshots is true, this controls the sampling rate for the snapshots
                */
            densitySnapshotSamplingRate: number;
            /**
                * If emitDensitySnapshots is true, this controls the emit rate for the snapshots
                */
            densitySnapshotEmitRate?: number;
            /**
                * If true, the energy of the graph will be emitted in the metrics
                */
            emitEnergy?: boolean;
            /**
                * If true, the objective energy of the graph will be emitted in the metrics
                */
            emitObjectiveEnergy?: boolean;
    }
    /**
        * @internal
        *
        * The default set of configuration options for the layout
        */
    export const DEFAULT_CONFIGURATION: OpenOrdConfiguration;
    /**
        * @internal
        *
        * The phase of the layout
        */
    export enum AnnealingPhase {
            Initial = 0,
            Liquid = 1,
            Expansion = 2,
            Cooldown = 3,
            Crunch = 4,
            Simmer = 5,
            Complete = 6
    }
    /**
        * @internal
        *
        * Gets a user friendly string of the given annealing phase
        * @param input The annealing phase
        */
    export function getAnnealingPhaseString(input: AnnealingPhase): string;
    /**
        * @internal
        *
        * The current progress of the layout process
        */
    export interface OpenOrdTickProgress {
            /**
                * The current density grid status
                */
            densityGrid: {
                    /**
                        * The sampled density grid bitmap. config.emitDensitySnapshots must be set
                        * to true to receive these
                        */
                    bitmap?: number[][];
            };
            /**
                * The current clock status
                */
            clock: {
                    /**
                        * The iteration the layout is on
                        */
                    iteration: number;
                    /**
                        * The phase iteration the layout is on
                        */
                    phaseIteration: number;
                    /**
                        * The target number of iterations
                        */
                    targetIterations: number;
                    /**
                        * The target number of phase iterations
                        */
                    targetPhaseIterations: number;
                    /**
                        * The current phase of the layout
                        */
                    phase: AnnealingPhase;
            };
            /**
                * The set of metrics associated with the current layout
                */
            metrics: {
                    /**
                        * The energy contained in the graph, enabled by adding `emitEnergy: true` to the layout configuration
                        */
                    energy?: number;
                    /**
                        * The energy contained in the graph, enabled by adding `emitObjectiveEnergy: true` to the layout configuration
                        */
                    objectiveEnergy?: number;
                    /**
                        * The attractive energy in the graph, enabled by adding `emitObjectiveEnergy: true` to the layout configuration
                        */
                    attractiveEnergy?: number;
                    /**
                        * The repulsive energy in the graph, enabled by adding `emitObjectiveEnergy: true` to the layout configuration
                        */
                    repulsiveEnergy?: number;
                    /**
                        * The overlap energy in the graph, enabled by adding `emitObjectiveEnergy: true` to the layout configuration
                        */
                    overlapEnergy?: number;
            };
    }
    /**
        * A schedule for a layout phase
        */
    export interface PhaseSchedule {
            /**
                * The number of iterations to run
                */
            iterations: number;
            temperature: number;
            attraction: number;
            damping: number;
    }
    export interface NodeUpdate {
            node: Node;
            position: Position;
            energy: number;
            kind: NodeUpdateKind;
            prunedEdge?: NodeIndex;
    }
    export enum NodeUpdateKind {
            CentroidJump = 0,
            RandomJump = 1
    }
}

declare module '@graspologic/layout-openord/executeLayout' {
    import { OpenOrdConfiguration, OpenOrdTickProgress } from '@graspologic/layout-openord/types';
    import { GraphContainer } from '@graspologic/graph';
    import { OnTickHandler } from '@graspologic/layout-core';
    /**
      * @internal
      *
      * Runs the openOrd layout algorithm
      * @param graph The graph to layout
      * @param configuration The layout configuration
      * @param onTick A callback for when the layout has performed an interation
      * @param globalObject The global object
      * @returns A promise for when the layout is complete
      */
    export function openOrd(graph: GraphContainer, configuration?: Partial<OpenOrdConfiguration>, onTick?: OnTickHandler<OpenOrdTickProgress>, globalObject?: any): Promise<void>;
}

declare module '@graspologic/layout-openord/OpenOrdLayoutExecutor' {
    import { AnnealingClock } from '@graspologic/layout-openord/AnnealingClock';
    import { DensityGrid } from '@graspologic/layout-openord/DensityGrid';
    import { OpenOrdTickProgress, OpenOrdConfiguration } from '@graspologic/layout-openord/types';
    import { GraphContainer } from '@graspologic/graph';
    import { BaseExecutor } from '@graspologic/layout-core';
    /**
        * @internal
        *
        * A layout executor which will run the OpenOrd layout on a graph
        */
    export class OpenOrdLayoutExecutor extends BaseExecutor<OpenOrdConfiguration, AnnealingClock, OpenOrdTickProgress> {
            /**
                * Constructor for the OpenOrdLayoutExecutor
                * @param graph The graph to layout
                * @param configuration The configuration for the algorithm
                * @param clock The annealing clock which controls how long phases are run
                * @param globalObject The global object
                * @param densityGrid The node density grid
                */
            constructor(graph: GraphContainer, configuration: OpenOrdConfiguration, clock: AnnealingClock, globalObject: any, densityGrid: DensityGrid);
            /**
                * Gets the name of the layout algorithm
                */
            getName(): string;
            /**
                * Gets the density grid
                */
            get densityGrid(): DensityGrid;
            /**
                * Gets the default configuration
                */
            protected get defaultConfiguration(): OpenOrdConfiguration;
            /**
                * Constructs the tick progress object
                */
            protected getProgress(): OpenOrdTickProgress;
            /**
                * Performs a single unit of work
                */
            protected performUnitOfWork(): void;
            /**
                * Gets the working energy. This differs from the objective energy in that we cull low-weight edges as the
                * algorithm progresses. The objective energy keep these in tact.
                */
            get energy(): number;
            /**
                * Gets the objective energy according to Equation 1 of the OpenOrd Paper
                *
                * https://www.researchgate.net/publication/253087985_OpenOrd_An_Open-Source_Toolbox_for_Large_Graph_Layout
                */
            get objectiveEnergy(): [number, number, number, number];
    }
}

declare module '@graspologic/layout-openord/AnnealingClock' {
    import { AnnealingPhase, PhaseSchedule } from '@graspologic/layout-openord/types';
    import { TickingClock } from '@graspologic/layout-core';
    /**
        * @internal
        *
        * A type of clock that uses simulated annealing through several phases
        */
    export class AnnealingClock implements TickingClock {
            constructor(edgeCut?: number, schedule?: Partial<Record<AnnealingPhase, PhaseSchedule>>);
            /**
                * Gets the current phase
                */
            get phase(): AnnealingPhase;
            /**
                * Determines if annealing is complete
                */
            get isComplete(): boolean;
            /**
                * Gets the current iteration
                */
            get iteration(): number;
            /**
                * Gets the current phase iteration
                */
            get phaseIteration(): number;
            /**
                * Gets the target phase iterations
                */
            get targetPhaseIterations(): number;
            /**
                * Gets the target number of iterations
                */
            get targetIterations(): number;
            get attraction(): number;
            get temperature(): number;
            get damping(): number;
            get minEdges(): number;
            /**
                * Gets the annealing schedule
                */
            get schedule(): Record<AnnealingPhase, PhaseSchedule>;
            get cutEnd(): number;
            get cutOffLength(): number;
            get neighborCutsEnabled(): boolean;
            /**
                * Runs an annealing iteration
                * @returns True if an iteration was run
                */
            tick(): boolean;
            get energyDistancePower(): number;
            get useFineDensity(): boolean;
    }
}

declare module '@graspologic/layout-openord/DensityGrid' {
    import { Node, Position } from '@graspologic/graph';
    export const GRID_SIZE = 1000;
    export const RADIUS = 10;
    export const DIAMETER: number;
    export const FALLOFF: number[][];
    /**
        * @internal
        *
        * A node density grid to track the density of nodes in a grid pattern
        */
    export class DensityGrid {
            initialLoad: boolean;
            /**
                * Determines whether the given node is in the denisty grid
                * @param id The node id
                */
            contains(node: Node): boolean;
            /**
                * Gets the number of tracked nodes in the grid
                */
            get size(): number;
            /**
                * Gets the density bitmap
                */
            get bitmap(): Float32Array[];
            get checksum(): number;
            /**
                * Adds a node to the density grid
                * @param node The node to add to the density grid
                */
            add(node: Node): void;
            /**
                * Subtracts a node from the density grid
                */
            subtract(node: Node): void;
            getDensity(node: Node, testPosition: Position, fine?: boolean): number;
            getOverlap(node: Node, position: Position): number;
    }
}

