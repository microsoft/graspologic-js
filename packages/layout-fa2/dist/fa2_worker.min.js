!function(){"use strict";function t(t,e,i){return Math.min(1,Math.sqrt(i*(t.dx**2+t.dy**2)/(1+Math.sqrt(e))))}function e(t,e,i){return t*Math.log(1+e)/(1+Math.sqrt(i))}function i(t,e){t.x+=t.dx*e,t.y+=t.dy*e}function s(t){return t.mass*Math.sqrt((t.old_dx-t.dx)**2+(t.old_dy-t.dy)**2)}function r(t){return Math.sqrt((t.old_dx+t.dx)**2+(t.old_dy+t.dy)**2)/2}function o(t){return Math.sqrt(t.dx**2+t.dy**2)}function n(t,e,i){const s=i.scalingRatio,r=t.x-e.x,o=t.y-e.y,n=s*t.mass*e.mass;let a,l,c=0,h=0;return i.adjustSize?(c=Math.sqrt(r**2+o**2)-t.size-e.size,c>0?(h=n/c**2,a=r*h,l=o*h,t.dx+=a,t.dy+=l,e.dx-=a,e.dy-=l):c<0?(h=100*n,a=r*h,l=o*h,t.dx+=a,t.dy+=l,e.dx-=a,e.dy-=l):console.log("Zero Distance 2")):(c=Math.sqrt(r**2+o**2),c>0&&(h=n/c**2,a=r*h,l=o*h,t.dx+=a,t.dy+=l,e.dx-=a,e.dy-=l)),0}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
function a(t=1e-6){return(Math.random()-.5)*t}function l(t,e){return Math.random()*(e-t)+t}function c(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class h{__init(){this.mass=0}__init2(){this.cx=0}__init3(){this.cy=0}__init4(){this.x0=Number.POSITIVE_INFINITY}__init5(){this.x1=Number.NEGATIVE_INFINITY}__init6(){this.y0=Number.POSITIVE_INFINITY}__init7(){this.y1=Number.NEGATIVE_INFINITY}constructor(t,e=0){let i,s,r;h.prototype.__init.call(this),h.prototype.__init2.call(this),h.prototype.__init3.call(this),h.prototype.__init4.call(this),h.prototype.__init5.call(this),h.prototype.__init6.call(this),h.prototype.__init7.call(this),this.level=e;let o=0;for(i of t)o++,c([s,"optionalAccess",t=>t.x])===i.x&&c([s,"optionalAccess",t=>t.y])===i.y&&(i.x+=a(.001),i.y+=a(.001)),r=i.mass+this.mass,this.cx=(i.x*i.mass+this.cx*this.mass)/r,this.cy=(i.y*i.mass+this.cy*this.mass)/r,this.mass=r,this.x0=Math.min(this.x0,i.x),this.x1=Math.max(this.x1,i.x),this.y0=Math.min(this.y0,i.y),this.y1=Math.max(this.y1,i.y),s=i;if(0===o)throw new Error("there should be at least one node in a QuadTree node");if(1===o)this.node=t[0];else{const e=[],s=[],r=[],o=[];for(i of t)i.y>this.cy?i.x>this.cx?s.push(i):e.push(i):i.x>this.cx?o.push(i):r.push(i);s.length>0&&(this.neChild=new h(s,this.level+1)),e.length>0&&(this.nwChild=new h(e,this.level+1)),o.length>0&&(this.seChild=new h(o,this.level+1)),r.length>0&&(this.swChild=new h(r,this.level+1))}}get depth(){return this.isLeaf?0:1+Math.max(this.nwChild?this.nwChild.depth:0,this.neChild?this.neChild.depth:0,this.swChild?this.swChild.depth:0,this.seChild?this.seChild.depth:0)}get size(){return(this.x1-this.x0)/2}get isLeaf(){return!(this.nwChild||this.neChild||this.swChild||this.seChild)}visit(t){const e=[this];for(;e.length>0;){const i=e.pop();t(i)||(i.nwChild&&e.push(i.nwChild),i.neChild&&e.push(i.neChild),i.swChild&&e.push(i.swChild),i.seChild&&e.push(i.seChild))}}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */var d,f,u;!function(t){t[t.Circle=0]="Circle";t[t.Square=1]="Square";t[t.Diamond=2]="Diamond"}(d||(d={})),function(t){t[t.Float32=0]="Float32";t[t.Uint8=1]="Uint8";t[t.Uint32=2]="Uint32"}(f||(f={})),function(t){t[t.Boolean=0]="Boolean"}(u||(u={}));
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const y={[f.Float32]:4,[f.Uint32]:4,[f.Uint8]:1};function p(t){return y[t]}function g(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const A="__SPACER__";function b(){const t=new Map;function e(e,i,s,r){t.set(e,{name:e,size:s,type:i,options:r})}const i={addUint8:(t,s)=>(e(t,f.Uint8,1,s),i),addUint8Vec2:(t,s)=>(e(t,f.Uint8,2,s),i),addUint8Vec3:(t,s)=>(e(t,f.Uint8,3,s),i),addUint8Vec4:(t,s)=>(e(t,f.Uint8,4,s),i),addFloat32:(t,s)=>(e(t,f.Float32,1,s),i),addFloat32Vec2:(t,s)=>(e(t,f.Float32,2,s),i),addFloat32Vec3:(t,s)=>(e(t,f.Float32,3,s),i),addUint32:(t,s)=>(e(t,f.Uint32,1,s),i),build(){const e=new Map;let i=0;t.forEach((t=>{t.type===f.Float32&&(i+=m(t,i,e))})),t.forEach((t=>{t.type===f.Uint32&&(i+=m(t,i,e))})),t.forEach((t=>{t.type===f.Uint8&&(i+=m(t,i,e))}));const s=i%4;return i%4!=0&&(i+=m({name:A,type:f.Uint8,size:4-s},i,e)),e.stride=i,e}};return i}function m(t,e,i){const s=p(t.type),r=e/s;i.set(t.name,{name:t.name,size:t.size,type:t.type,hint:t.hint,typedOffset:r,offset:e});let o,n,a=0;for(o of g([t,"access",t=>t.options,"optionalAccess",t=>t.components])||[])i.set(o,{name:o,size:1,type:t.type,typedOffset:r+a,offset:e+a*s}),a++;for(n of g([t,"access",t=>t.options,"optionalAccess",t=>t.aliases])||[])i.set(n.name,{name:n.name,size:n.size||1,type:n.type,hint:n.hint,typedOffset:e/p(n.type),offset:e});return t.size*s}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const w=1e4;
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
class _{__init(){this.availableIndices=new Map}__init2(){this.capacity=0}constructor(t=1e4,e=!1){if(_.prototype.__init.call(this),_.prototype.__init2.call(this),null==t||t<=0)throw new Error(`Invalid capacity ${t}, capacity must be > 0`);this.capacity=t,e||this.reset(t)}reset(t){if(null==t||t<=0)throw new Error(`Invalid capacity ${t}, capacity must be > 0`);this.capacity=t;for(let t=0;t<this.capacity-1;t++)this.availableIndices.set(t,t+1);this.availableIndices.set(this.capacity-1,-1),this.nextAvailableIndex=0}grow(t){if(null==t||t<=0)throw new Error(`Invalid capacity ${t}, newCapacity must be > 0`);for(let e=this.capacity;e<t-1;e++)this.availableIndices.set(e,e+1);this.nextAvailableIndex=this.capacity,this.capacity=t}get hasFreeSpace(){return null!=this.nextAvailableIndex}free(t){if(null==t||t<0||t>this.capacity-1)throw new Error("Invalid index "+t);this.availableIndices.set(t,this.nextAvailableIndex),this.nextAvailableIndex=t}alloc(){if(null==this.nextAvailableIndex)throw new Error("error allocating index, no space available");const t=this.nextAvailableIndex;return this.nextAvailableIndex=this.availableIndices.get(t)>0?this.availableIndices.get(t):void 0,this.availableIndices.delete(t),t}*used(){if(0!==this.availableIndices.size||-1!==this.nextAvailableIndex&&void 0!==this.nextAvailableIndex)for(let t=0;t<this.capacity;++t)this.availableIndices.has(t)||this.nextAvailableIndex===t||(yield t);else for(let t=0;t<this.capacity;++t)yield t}has(t){return t>=0&&t<this.capacity&&!this.availableIndices.has(t)}get usedCount(){return this.capacity-this.availableIndices.size}destroy(){this.availableIndices=new Map,this.nextAvailableIndex=-1}}function O(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const x={shared:true,capacity:w};class I{__init(){this.onResizeHandlers=[]}constructor(t,e=x){this.layout=t,I.prototype.__init.call(this);const i=e.capacity||(O([e,"access",t=>t.buffer,"optionalAccess",t=>t.byteLength])||0)/t.stride||w;this.config={capacity:i,shared:"boolean"!=typeof e.shared||e.shared},this.bytesPerItem=t.stride,e.buffer&&(this._buffer=e.buffer),this.resize(this.config.capacity)}get buffer(){return this._buffer}get dataView(){return this._dataView}get float32Array(){return this._float32Array}get uint8Array(){return this._uint8Array}get uint32Array(){return this._uint32Array}onResize(t){return this.onResizeHandlers.push(t),()=>{this.onResizeHandlers=this.onResizeHandlers.filter((e=>e!==t))}}resize(t){if(this.count!==t){const e=this.count,i=this.buffer,s=t*this.bytesPerItem;if(s%4!=0)throw new Error(`buffer size ${s} must be word-aligned. size=${t}, bpi=${this.bytesPerItem}`);const r=this.config.shared&&"undefined"!=typeof SharedArrayBuffer?new SharedArrayBuffer(s):new ArrayBuffer(s);if(e>0&&t>e){new Uint8Array(r).set(new Uint8Array(i))}this._buffer=r,this._dataView=new DataView(r),this._float32Array=new Float32Array(r),this._uint8Array=new Uint8Array(r),this._uint32Array=new Uint32Array(r),this.onResizeHandlers.forEach((t=>t()))}else this.uint8Array||(this._uint8Array=new Uint8Array(this._buffer),this._uint32Array=new Uint32Array(this._buffer),this._float32Array=new Float32Array(this._buffer))}itemData(t){if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");const e=t*this.bytesPerItem;return this.buffer.slice(e,e+this.bytesPerItem)}getByteOffset(t){if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");return t*this.bytesPerItem}getByteOffsetAttr(t,e){const i=this.layout.get(e);if(t<0||t*this.bytesPerItem>this.buffer.byteLength-this.bytesPerItem)throw new Error("Index out of range");if(!i)throw new Error("Layout does not contain "+e);return t*this.bytesPerItem+O([i,"optionalAccess",t=>t.offset])}get count(){return this.buffer?this.buffer.byteLength/this.bytesPerItem:0}destroy(){this.config.capacity=0,this.resize(0)}slurp(t,e,i=0){this.uint8Array.set(new Uint8Array(e,i,this.bytesPerItem),t*this.bytesPerItem)}}class v{__init(){this._count=0}__init2(){this.onUpdateHandlers=[]}__init3(){this.onAddHandlers=[]}__init4(){this.onRemoveHandlers=[]}constructor(t,e){v.prototype.__init.call(this),v.prototype.__init2.call(this),v.prototype.__init3.call(this),v.prototype.__init4.call(this),this._store=t,this.slotAllocator=e,this._count=e.usedCount}get store(){return this._store}get count(){return this._count}itemIds(){return this.slotAllocator.used()}onAttributeUpdated(t){return this.onUpdateHandlers.push(t),()=>{this.onUpdateHandlers=this.onUpdateHandlers.filter((e=>e!==t))}}onAddItem(t){return this.onAddHandlers.push(t),()=>{this.onAddHandlers=this.onAddHandlers.filter((e=>e!==t))}}onRemoveItem(t){return this.onRemoveHandlers.push(t),()=>{this.onRemoveHandlers=this.onRemoveHandlers.filter((e=>e!==t))}}add(t=!0){if(!this.slotAllocator.hasFreeSpace){const t=this.store.count+this.store.config.capacity;this.store.resize(t),this.slotAllocator.grow(t)}const e=this.slotAllocator.alloc();return this._count++,t&&this.fireAddHandlers(e),e}remove(t,e=!0){e&&this.fireRemoveHandlers(t),this.slotAllocator.free(t),this._count--}reset(){const t=this._store.config.capacity;for(const t of this.itemIds())this.fireRemoveHandlers(t);this._store.resize(t),this.slotAllocator.reset(t),this._count=0}destroy(){this.store.destroy(),this.slotAllocator.destroy(),this.onRemoveHandlers=[],this.onAddHandlers=[],this.onUpdateHandlers=[]}notify(t,e){for(const i of this.onUpdateHandlers)try{i(t,e)}catch(t){console.error("caught error",t)}}fireAddHandlers(t){this.onAddHandlers.forEach((e=>e(t)))}fireRemoveHandlers(t){this.onRemoveHandlers.forEach((e=>e(t)))}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function U(t,e,i=[]){class s{__init(){this.storeId=-1}__init2(){this.byteOffset=0}__init3(){this.wordOffset=0}constructor(t,r=-1){s.prototype.__init.call(this),s.prototype.__init2.call(this),s.prototype.__init3.call(this);if(null==t){this.isFlushNeeded=!0;const t=new ArrayBuffer(e.stride);this.uint8Array=new Uint8Array(t),this.uint32Array=new Uint32Array(t),this.float32Array=new Float32Array(t),this.propertyBag={}}else this.isFlushNeeded=!1,this.connect(r,t);i.forEach((t=>{if("string"!=typeof t){const{name:e,initialValue:i,ephemeral:s}=t;s?this[e]=i:this.propertyBag[e]=i}}))}get type(){return t}get layout(){return e}get buffer(){return this.uint8Array.buffer}connect(t,e){this.storeId!==t&&(this.byteOffset=t*e.store.bytesPerItem,this.wordOffset=this.byteOffset/4,this.storeId=t,this.isFlushNeeded&&(e.slurp(t,this.uint8Array.buffer,this.propertyBag),this.isFlushNeeded=!1),this.propertyBag=e.propertyBags[t]),this.store=e,this.uint32Array=e.store.uint32Array,this.float32Array=e.store.float32Array,this.uint8Array=e.store.uint8Array}handleAttributeUpdated(t){}}const r=s.prototype;return e.forEach((t=>{if(t.name===A)return;const{name:e,size:i,type:s,typedOffset:o,hint:n}=t;let a,l;s===f.Float32?1===i?(l=function(){return this.float32Array[this.wordOffset+o]},a=function(t){this.float32Array[this.wordOffset+o]=t||0,this.handleAttributeUpdated(e)}):2===i?(l=function(){return[this.float32Array[this.wordOffset+o],this.float32Array[this.wordOffset+o+1]]},a=function(t){this.float32Array[this.wordOffset+o]=t[0]||0,this.float32Array[this.wordOffset+o+1]=t[1]||0,this.handleAttributeUpdated(e)}):3===i&&(l=function(){return[this.float32Array[this.wordOffset+o],this.float32Array[this.wordOffset+o+1],this.float32Array[this.wordOffset+o+2]]},a=function(t){this.float32Array[this.wordOffset+o]=t[0]||0,this.float32Array[this.wordOffset+o+1]=t[1]||0,this.float32Array[this.wordOffset+o+2]=t[2]||0,this.handleAttributeUpdated(e)}):s===f.Uint8?1===i?n===u.Boolean?(l=function(){return this.uint8Array[this.byteOffset+o]>0},a=function(t){this.uint8Array[this.byteOffset+o]=t?1:0,this.handleAttributeUpdated(e)}):(l=function(){return this.uint8Array[this.byteOffset+o]},a=function(t){this.uint8Array[this.byteOffset+o]=t,this.handleAttributeUpdated(e)}):2===i?(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.handleAttributeUpdated(e)}):3===i?(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1],this.uint8Array[this.byteOffset+o+2]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.uint8Array[this.byteOffset+o+2]=t[2]||0,this.handleAttributeUpdated(e)}):4===i&&(l=function(){return[this.uint8Array[this.byteOffset+o],this.uint8Array[this.byteOffset+o+1],this.uint8Array[this.byteOffset+o+2],this.uint8Array[this.byteOffset+o+3]]},a=function(t){this.uint8Array[this.byteOffset+o]=t[0]||0,this.uint8Array[this.byteOffset+o+1]=t[1]||0,this.uint8Array[this.byteOffset+o+2]=t[2]||0,this.uint8Array[this.byteOffset+o+3]=t[3]||0,this.handleAttributeUpdated(e)}):s===f.Uint32&&1===i&&(l=function(){return this.uint32Array[this.wordOffset+o]},a=function(t){this.uint32Array[this.wordOffset+o]=t||0,this.handleAttributeUpdated(e)}),a&&r.__defineSetter__(e,a),l&&r.__defineGetter__(e,l)})),i.forEach((t=>{const e="string"==typeof t?t:t.name;"string"!=typeof t&&Boolean(t.ephemeral)||(r.__defineGetter__(e,(function(){return this.propertyBag[e]})),r.__defineSetter__(e,(function(t){this.propertyBag[e]=t})))})),s}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class C extends v{__init(){this.propertyBags={}}constructor(t,e,i=new _(e.config.capacity)){super(e,i),C.prototype.__init.call(this),this.items=new Array(e.config.capacity),this.itemClass=t,e.onResize((()=>{this.items.forEach((t=>t&&t.connect(t.storeId,this)))}))}receive(t){const e=this.add(!1);return this.slurp(e,t.buffer,t.byteOffset),t.connect(e,this),this.fireAddHandlers(e),e}itemAt(t){return this.items[t]||(this.items[t]=this.createConnectedItem(t))}createConnectedItem(t){return this.propertyBags[t]||(this.propertyBags[t]={}),new this.itemClass(this,t)}*[Symbol.iterator](){let t;for(t of this.itemIds())yield this.itemAt(t)}*scan(){let t,e;if(this.count>0&&(e=this.createConnectedItem(0)),e)for(t of this.itemIds())this.propertyBags[t]||(this.propertyBags[t]={}),e.connect(t,this),yield e}slurp(t,e,i={},s=0){this.store.slurp(t,e,s),this.propertyBags[t]=i||void 0,this.notify(t)}add(t=!0){const e=super.add(!1);return this.propertyBags[e]={},t&&this.fireAddHandlers(e),e}remove(t){super.remove(t),this.propertyBags[t]=void 0}reset(){super.reset(),this.propertyBags={}}destroy(){super.destroy(),this.propertyBags={}}}function F(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const E=Float32Array.BYTES_PER_ELEMENT;class B{getByteOffset(t,e){const i=t.layout.get(e);return t.byteOffset+i.offset}getTypedOffset(t,e){return t.layout.get(e).typedOffset}getWordOffset(t,e){return this.getByteOffset(t,e)/E}readProperty(t,e){const i=t.store.propertyBags[t.storeId];if(null!=i)return i[e]}writeProperty(t,e,i){let s=t.store.propertyBags[t.storeId];s||(s={},t.store.propertyBags[t.storeId]=s),s[e]=i,F([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readNumber(t,e){if(t.layout.has(e)){const i=t.layout.get(e);return i.type===f.Uint8?this.readUint8Attr(t,e):i.type===f.Uint32?this.readUint32Attr(t,e):this.readFloat32Attr(t,e)}return this.readProperty(t,e)||0}writeNumber(t,e,i){const s=t.layout.get(e);s?s.type===f.Uint8?this.writeUint8Attr(t,e,i):s.type===f.Uint32?this.writeUint32Attr(t,e,i):this.writeFloat32Attr(t,e,i):this.writeProperty(t,e,i),F([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readString(t,e){return this.readProperty(t,e)}writeString(t,e,i){this.writeProperty(t,e,i),F([t,"access",t=>t.store,"optionalAccess",t=>t.notify,"call",i=>i(t.storeId,e)])}readBoolAttr(t,e){return Boolean(this.readUint8Attr(t,e))}writeBoolAttr(t,e,i){this.writeUint8Attr(t,e,i?1:0)}readFloat32Attr(t,e){return t.float32Array[this.getWordOffset(t,e)]}writeFloat32Attr(t,e,i){t.float32Array[this.getWordOffset(t,e)]=i}readFloat32Vec2Attr(t,e){const i=this.getWordOffset(t,e);return[t.float32Array[i],t.float32Array[i+1]]}writeFloat32Vec2Attr(t,e,i,s){const r=this.getWordOffset(t,e);t.float32Array[r]=i,t.float32Array[r+1]=s}writeFloat32Vec2Offset(t,e,i,s){t.float32Array[t.wordOffset+e]=i,t.float32Array[t.wordOffset+e+1]=s}copyFloat32Vec3Attr(t,e,i){const s=this.getWordOffset(t,e),r=t.float32Array.subarray(s,s+3);return t.float32Array.set(r,this.getWordOffset(t,i)),r}copyFloat32Vec3Offset(t,e,i){const s=t.float32Array.subarray(t.wordOffset+e,t.wordOffset+e+3);return t.float32Array.set(s,t.wordOffset+i),s}writeFloat32Vec3Attr(t,e,i,s,r){const o=this.getWordOffset(t,e);t.float32Array[o]=i,t.float32Array[o+1]=s,t.float32Array[o+2]=r}writeFloat32Vec3Offset(t,e,i,s,r){t.float32Array[t.wordOffset+e]=i,t.float32Array[t.wordOffset+e+1]=s,t.float32Array[t.wordOffset+e+2]=r}readFloat32Vec3Attr(t,e){const i=this.getWordOffset(t,e);return[t.float32Array[i],t.float32Array[i+1],t.float32Array[i+2]]}readUint8Attr(t,e){return t.uint8Array[this.getByteOffset(t,e)]}writeUint8Attr(t,e,i){t.uint8Array[this.getByteOffset(t,e)]=i}readUint8Vec2Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1]]}writeUint8Vec2Attr(t,e,i,s){const r=this.getByteOffset(t,e);t.uint8Array[r]=i,t.uint8Array[r+1]=s}readUint8Vec3Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1],t.uint8Array[i+2]]}writeUint8Vec3Attr(t,e,i,s,r){const o=this.getByteOffset(t,e);t.uint8Array[o]=i,t.uint8Array[o+1]=s,t.uint8Array[o+2]=r}readUint8Vec4Attr(t,e){const i=this.getByteOffset(t,e);return[t.uint8Array[i],t.uint8Array[i+1],t.uint8Array[i+2],t.uint8Array[i+3]]}writeUint8Vec4Attr(t,e,i,s,r,o){const n=this.getByteOffset(t,e);t.uint8Array[n]=i,t.uint8Array[n+1]=s,t.uint8Array[n+2]=r,t.uint8Array[n+3]=o}readUint32Attr(t,e){return t.uint32Array[this.getWordOffset(t,e)]}writeUint32Attr(t,e,i){t.uint32Array[this.getWordOffset(t,e)]=i}writeUint32Offset(t,e,i){t.uint32Array[t.wordOffset+e]=i}copyUint32Offset(t,e,i){t.uint32Array[t.wordOffset+i]=t.uint32Array[t.wordOffset+e]}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const V=Symbol("@graspologic::node"),P=b().addFloat32("weight").addFloat32("radius",{aliases:[{name:"size",type:f.Float32}]}).addUint8("fixed").addUint32("color").addUint32("color.start").addFloat32Vec2("color.tween",{components:["color.duration","color.startTime"]}).addFloat32Vec3("position",{components:["x","y","z"]}).addFloat32Vec3("position.start").addFloat32Vec2("position.tween",{components:["position.duration","position.startTime"]}).addFloat32("saturation").addUint8("shape").addUint8("visible",{hint:u.Boolean}).addUint8Vec3("pickingColor").build();function z(t){return function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}([P,"access",t=>t.get,"call",e=>e(t),"optionalAccess",t=>t.typedOffset])}const M=P.get("position").typedOffset,k=P.get("radius").typedOffset,H=P.get("shape").typedOffset,R=P.get("weight").typedOffset,T=P.get("color").typedOffset,S=P.get("visible").typedOffset,j=U(V,P,["id","group","label","data",{name:"mass",ephemeral:!0,initialValue:0},{name:"dx",ephemeral:!0,initialValue:0},{name:"dy",ephemeral:!0,initialValue:0},{name:"old_dx",ephemeral:!0,initialValue:0},{name:"old_dy",ephemeral:!0,initialValue:0},{name:"convergence",ephemeral:!0,initialValue:1}]);class N extends j{load(t){this.propertyBag=this.store.propertyBags[this.storeId]||{},this.store.propertyBags[this.storeId]=this.propertyBag,this.propertyBag.id=t.id,this.propertyBag.group=t.group,this.propertyBag.label=t.label,this.float32Array[this.wordOffset+k]=t.size||t.radius||0,this.float32Array[this.wordOffset+M]=t.x||0,this.float32Array[this.wordOffset+M+1]=t.y||0,this.float32Array[this.wordOffset+M+2]=t.z||0,this.float32Array[this.wordOffset+R]=t.weight||1,this.uint32Array[this.wordOffset+T]=t.color||0,this.uint8Array[this.byteOffset+H]=function(t){if("string"==typeof t){if("square"===(t=t.toLocaleLowerCase()))return d.Square;if("diamond"===t)return d.Diamond}else if(t===d.Square||t===d.Diamond||t===d.Circle)return t;return d.Circle}(t.shape),this.uint8Array[this.byteOffset+S]=1}}function L(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const W="color",q="color.start",D="color.tween",G="position",$="position.start",Y="position.tween",Z=z(G),Q=z($),X=z(Y),J=z(W),K=z(q),tt=z(D),et=new B;const it=class extends N{animatePosition(t,e=0){et.copyFloat32Vec3Offset(this,Z,Q),this.handleAttributeUpdated($),et.writeFloat32Vec2Offset(this,X,e,L([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(Y),et.writeFloat32Vec3Offset(this,Z,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(G)}animateColor(t,e=0){et.copyUint32Offset(this,J,K),this.handleAttributeUpdated(q),et.writeFloat32Vec2Offset(this,tt,e,L([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(D),et.writeUint32Offset(this,J,t),this.handleAttributeUpdated(W)}load(t){super.load(t),this.handleAttributeUpdated("*")}handleAttributeUpdated(t){this.store&&this.store.notify(this.storeId,t)}};function st(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function rt(t){const e=new I(P,t),i=new _(e.config.capacity,0!==st([t,"optionalAccess",t=>t.capacity])&&Boolean(st([t,"optionalAccess",t=>t.allocatedOnCreate]))),s=!1!==st([t,"optionalAccess",t=>t.animation])?it:N;return new C(s,e,i)}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
const ot=Symbol("@graspologic::edge"),nt=b().addUint32("sourceIndex").addUint32("targetIndex").addFloat32("weight").addFloat32("trueWeight").addFloat32("saturation").addFloat32("saturation2").addUint32("color").addUint32("color2").addUint8("visible",{hint:u.Boolean}).addFloat32Vec3("sourcePosition.start").addFloat32Vec3("sourcePosition").addFloat32Vec2("sourcePosition.tween",{components:["sourcePosition.duration","sourcePosition.startTime"]}).addFloat32Vec3("targetPosition.start").addFloat32Vec3("targetPosition").addFloat32Vec2("targetPosition.tween",{components:["targetPosition.duration","targetPosition.startTime"]}).build();function at(t){return function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}([nt,"access",t=>t.get,"call",e=>e(t),"optionalAccess",t=>t.typedOffset])}const lt=nt.get("sourceIndex").typedOffset,ct=nt.get("targetIndex").typedOffset,ht=nt.get("color").typedOffset,dt=nt.get("color2").typedOffset,ft=nt.get("weight").typedOffset,ut=U(ot,nt,["id","source","target","data"]);class yt extends ut{load(t,e,i=1){this.propertyBag=this.store.propertyBags[this.storeId]||{},this.store.propertyBags[this.storeId]=this.propertyBag,this.propertyBag.source=t.source,this.propertyBag.target=t.target,this.uint32Array[this.wordOffset+lt]=e.get(t.source),this.uint32Array[this.wordOffset+ct]=e.get(t.target),this.float32Array[this.wordOffset+ft]=null!=t.weight?t.weight:i,this.uint32Array[this.wordOffset+ht]=t.color||t.sourceColor||0,this.uint32Array[this.wordOffset+dt]=t.color2||t.targetColor||0}}function pt(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}const gt="sourcePosition",At="sourcePosition.start",bt="sourcePosition.tween",mt="targetPosition",wt="targetPosition.start",_t="targetPosition.tween",Ot=at(gt),xt=at(At),It=at(bt),vt=at(mt),Ut=at(wt),Ct=at(_t),Ft=new B;const Et=class extends yt{animateSourcePosition(t,e){Ft.copyFloat32Vec3Offset(this,Ot,xt),this.handleAttributeUpdated(At),Ft.writeFloat32Vec2Offset(this,It,e||0,pt([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(bt),Ft.writeFloat32Vec3Offset(this,Ot,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(gt)}animateTargetPosition(t,e){Ft.copyFloat32Vec3Offset(this,vt,Ut),this.handleAttributeUpdated(wt),Ft.writeFloat32Vec2Offset(this,Ct,e||0,pt([this.store,"optionalAccess",t=>t.engineTime])||0),this.handleAttributeUpdated(_t),Ft.writeFloat32Vec3Offset(this,vt,t[0]||0,t[1]||0,t[2]||0),this.handleAttributeUpdated(mt)}load(t,e,i=1){super.load(t,e,i),this.handleAttributeUpdated("*")}handleAttributeUpdated(t){this.store&&this.store.notify(this.storeId,t)}};function Bt(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */function Vt(t){const e=new I(nt,t),i=new _(e.config.capacity,0!==Bt([t,"optionalAccess",t=>t.capacity])&&Boolean(Bt([t,"optionalAccess",t=>t.allocatedOnCreate]))),s=!1!==Bt([t,"optionalAccess",t=>t.animation])?Et:yt;return new C(s,e,i)}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */const Pt=Object.freeze({defaultEdgeWeight:1,shareable:!0});function zt(t,{shareable:e=Pt.shareable,randomize:i,defaultEdgeWeight:s=Pt.defaultEdgeWeight}=Pt){const r=function(t,e,i=!0){return new kt(rt({capacity:t,shared:i,allocatedOnCreate:!0}),Vt({capacity:e,shared:i,allocatedOnCreate:!0}))}(t.nodes.length,t.edges.length,e);let o=0;const n=new Map;if(t.nodes.length>0){let e,s;for(e of(o=0,r.nodes.scan())){if(o>=t.nodes.length)break;s=t.nodes[o],t.edges.length>0&&n.set(s.id,o),e.connect(o,r.nodes),e.load(s),i&&0===e.x&&0===e.y&&(e.x=l(i[0],i[1]),e.y=l(i[2],i[3])),++o}}if(t.edges.length>0){let e;for(e of(o=0,r.edges.scan())){if(o>=t.edges.length)break;e.connect(o,r.edges),e.load(t.edges[o],n,s),++o}}return r}function Mt(t,e){const i=new Map;let s;for(s of t)i.set(s.storeId,{});let r,o,n,a,l,c=1e-6;for(n of e){const{sourceIndex:t,targetIndex:e,weight:s}=n;r=i.get(t),o=i.get(e),s>c&&(c=s),r[e]=s,o[t]=s}for(a of i.values())for(l of Object.keys(a))a[parseInt(l,10)]/=c;return i}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class kt{constructor(t,e){this._nodes=t,this._edges=e}get nodes(){return this._nodes}get edges(){return this._edges}static intern(t,e=Pt){return zt(t,e)}serialize(){return{nodes:this.nodes.store.buffer,edges:this.edges.store.buffer}}static deserialize(t){const e=rt({buffer:t.nodes,allocatedOnCreate:!0}),i=Vt({buffer:t.edges,allocatedOnCreate:!0});return new kt(e,i)}getNeighbors(t){const e=this.getAdjacencyMap(!1).get(t);return e?Object.keys(e).map((t=>parseInt(t,10))):[]}getNeighborsObjective(t){const e=this.getAdjacencyMap(!0).get(t);if(!e)throw new Error("could not get adjacency for node "+t);return Object.keys(e).map((t=>parseInt(t,10)))}getEdgeWeight(t,e){const i=this.getAdjacencyMap(!1).get(t);if(!i)throw new Error("could not get adjacency for node "+t);return i[e]}getEdgeWeightObjective(t,e){const i=this.getAdjacencyMap(!0).get(t);if(!i)throw new Error("could not get objective adjacency for node "+t);return i[e]}getNeighborhoodCentroid(t){const e=this.getNeighbors(t),i=this.nodes.itemAt(t);if(i){if(0===e.length)return{x:i.x,y:i.y};{const s=[i],r=[1];e.forEach((e=>{const i=this.nodes.itemAt(e),o=this.getEdgeWeight(t,e);s.push(i),r.push(o)}));return function(t,e){if(0===t.length)throw new Error("could not compute centroid out of zero points");if(t.length!==e.length)throw new Error("points array and weights array must be the same length");let i=0,s=0,r=0;return t.forEach(((t,o)=>{const n=e[o];r+=n,i+=t.x*n,s+=t.y*n})),{x:i/r,y:s/r}}(s,r)}}throw new Error("could not get node "+t)}pruneEdge(t,e){const i=this.getAdjacencyMap(!1).get(t),s=this.getAdjacencyMap(!1).get(e);if(!i||!s)throw new Error(`could not get edge for (${t}, ${e})`);delete i[e],delete s[t]}getAdjacencyMap(t){return this._originalAdjacency||(this._originalAdjacency=Mt(this.nodes,this.edges)),this._adjacency||t||(this._adjacency=Mt(this.nodes,this.edges)),t?this._originalAdjacency:this._adjacency}}function Ht(t,e,i){return t.visit((t=>{if(t.isLeaf)return t.node&&n(e,t.node,i),!0;const s=e.x-t.cx,r=e.y-t.cy,o=Math.sqrt(s**2+r**2),a=t.size/o<i.barnesHutTheta;if(a){const n=i.scalingRatio*e.mass*t.mass;if(o>0){const t=n/o**2;e.dx+=s*t,e.dy+=r*t}else console.log("Zero Distance 3")}return a})),0}function Rt(t,e){return e.barnesHutOptimize?function(t,e){const i=new h([...t]);let s,r=0;for(s of t)r+=Ht(i,s,e);return r}(t,e):function(t,e){let i,s;for(i=0;i<t.count;++i)for(s=0;s<i;++s)n(t.itemAt(i),t.itemAt(s),e);return 0}(t,e)}function Tt(n,a,l){!function(t){let e;for(e of t)e.dx=0,e.dy=0}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */(n);const c=performance.now(),h=Rt(n,l),d=performance.now(),f=function(t,e){const i=e.gravity/e.scalingRatio,s=e.scalingRatio;let r,o,n,a=0;for(r of t)o=Math.sqrt(r.x**2+r.y**2),n=0,e.strongGravityMode?o>0&&(n=s*r.mass*i):o>0&&(n=s*r.mass*i/o),a+=o*n,r.dx-=r.x*n,r.dy-=r.y*n;return a}(n,l),u=performance.now(),y=function(t,e,i){const s=1*(i.outboundAttractionDistribution?function(t,e){let i=0;if(e.outboundAttractionDistribution){let e;for(e of(i=0,t))i+=e.mass;i/=t.count}return i}(t,i):1);let r,o,n,a,l,c,h,d,f=0,u=0;for(r of e)o=t.itemAt(r.sourceIndex),n=t.itemAt(r.targetIndex),a=r.weight,l=Math.pow(a,i.edgeWeightInfluence),c=o.x-n.x,h=o.y-n.y,i.adjustSizes?(d=Math.sqrt(c**2+h**2-o.size-n.size),i.linLogMode?i.outboundAttractionDistribution?d>0&&(f=-s*l*Math.log(1+d)/d/o.mass):d>0&&(f=-s*l*Math.log(1+d)/d):i.outboundAttractionDistribution?d>0&&(f=-s*l/o.mass):d>0&&(f=-s*l)):(d=Math.sqrt(c**2+h**2),i.linLogMode?i.outboundAttractionDistribution?d>0&&(f=-s*l*Math.log(1+d)/d/o.mass):d>0&&(f=-s*l*Math.log(1+d)/d):i.outboundAttractionDistribution?(d=1,f=-s*l/o.mass):(d=1,f=-s*l)),d>0&&(o.dx+=c*f,o.dy+=h*f,n.dx-=c*f,n.dy-=h*f,u+=d*f);return u}(n,a,l),p=performance.now();return console.log("perf - repulsion=%s, gravity=%s, attraction=%s",d-c,u-d,p-u),function(n,a,l,c,h){let d,f,u,y,p,g,A=0,b=0,m=0;for(p of n)p.fixed||(d=o(p),f=s(p),u=r(p),A+=d,b+=f,m+=u,a.adjustSizes?(d>a.maxForce&&(g=a.maxForce/d,p.dx*=g,p.dy*=g),y=e(.1,u,f)):(y=e(p.convergence,u,f),p.convergence=t(p,f,y)),i(p,y/a.slowDown));return[A,b,m,l,c,h]}(n,l,h,f,y)}const St=Object.freeze({adjustSize:!1,linLogMode:!1,outboundAttractionDistribution:!1,adjustSizes:!1,edgeWeightInfluence:0,scalingRatio:1,strongGravityMode:!1,gravity:1,slowDown:1,barnesHutOptimize:!0,barnesHutTheta:1.2,startingIterations:1,maxForce:10,targetIterations:100});var jt,Nt;!function(t){t.Configure="CONFIGURE";t.Execute="EXECUTE";t.Halt="HALT";t.Resume="RESUME";t.Reset="RESET";t.Error="ERROR";t.Progress="PROGRESS";t.Complete="COMPLETE"}(jt||(jt={}));
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
class Lt{constructor(){Lt.prototype.__init.call(this)}__init(){this.listeners={}}on(t,e){return this.listeners[t]=this.listeners[t]||[],this.listeners[t].push(e),()=>this.off(t,e)}off(t,e){const i=this.listeners[t];if(i){const t=i.indexOf(e);t>=0&&i.splice(t,1)}}emit(t,e){const i=this.listeners[t];i&&i.forEach((t=>{t.call(this,e)}))}hasListeners(t){this.listeners=this.listeners||{};const e=this.listeners[t];return!!e&&e.length>0}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */!function(t){t[t.Graph=0]="Graph";t[t.Viewport=1]="Viewport";t[t.None=2]="None"}(Nt||(Nt={})),
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */
Nt.Graph;class Wt extends Lt{__init(){this._halted=!1}__init2(){this._complete=!1}constructor(t,e,i,s){super(),Wt.prototype.__init.call(this),Wt.prototype.__init2.call(this),this._clock=i,this._graph=t,this._global=s,this._configuration=e,this.executeStep=this.executeStep.bind(this),s.console.log(`create new ${this.getName()} instance`,this._configuration)}halt(){this._halted=!0}get isHalted(){return this._halted}get isComplete(){return this._complete}get clock(){return this._clock}get graph(){return this._graph}get globalObject(){return this._global}get configuration(){return this._configuration}configure(t){this._configuration={...this.defaultConfiguration,...t}}execute(){return this._global.console.log(`execute ${this.getName()}, %s nodes, %s edges`,this.graph.nodes.count,this.graph.edges.count),this._halted=!1,this._complete=!1,this.clearTickListener(),new Promise((t=>{this.executeStep(),this._tickListener=this.on("tick",(()=>{this._complete&&(t(this.getProgress()),this.clearTickListener())}))}))}clearTickListener(){this._tickListener&&(this._tickListener(),this._tickListener=void 0)}executeStep(){this.performUnitOfWork();const t=this._clock.tick();t||(this._complete=!0),t&&!this._halted&&this._global.setTimeout(this.executeStep,0),this.emit("tick",this.getProgress())}}class qt{__init(){this._ticks=0}constructor(t){qt.prototype.__init.call(this),this._targetTicks=t}get currentTicks(){return this._ticks}get targetTicks(){return this._targetTicks}tick(){return this._ticks++,this._ticks<this._targetTicks}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */class Dt extends Wt{__init(){this._metrics=[0,0,0,0,0,0]}constructor(t,e,i,s){super(t,e,i,s),Dt.prototype.__init.call(this),this.checkforRandomization(),this.computeMass()}getName(){return"ForceAtlas2"}get defaultConfiguration(){return St}performUnitOfWork(){try{this._metrics=Tt(this.graph.nodes,this.graph.edges,this.configuration)}catch(t){throw this.globalObject.console.log("caught error",t),t}}getProgress(){return{clock:{iteration:this.clock.currentTicks,targetIterations:this.clock.targetTicks},metrics:{tension:this._metrics[0],swing:this._metrics[1],traction:this._metrics[2]}}}checkforRandomization(){let t,e=!0;for(t of this.graph.nodes)if(0!==t.x||0!==t.y){e=!1;break}if(e)for(t of(this.globalObject.console.log("randomizing layouts"),this.graph.nodes))t.x=l(0,1024),t.y=l(0,1024)}computeMass(){let t,e;for(t of this.graph.nodes)t.mass=1;for(e of this.graph.edges)this.graph.nodes.itemAt(e.sourceIndex).mass+=1,this.graph.nodes.itemAt(e.targetIndex).mass+=1}}
/*!
	 * Copyright (c) Microsoft. All rights reserved.
	 * Licensed under the MIT license. See LICENSE file in the project.
	 */let Gt,$t;function Yt(){null!=Gt?Gt.halt():self.console.log("could not stop executor, instance not defined")}function Zt(t,e){self.postMessage({type:t,payload:e},void 0)}self.console.log("fa2 worker bootstrapping"),self.onmessage=t=>{const{type:e,payload:i}=t.data;switch(self.console.log("fa2 receive message",e),e){case jt.Configure:!function(t){let e=void 0,i=t[0],s=1;for(;s<t.length;){const r=t[s],o=t[s+1];if(s+=2,("optionalAccess"===r||"optionalCall"===r)&&null==i)return;"access"===r||"optionalAccess"===r?(e=i,i=o(i)):"call"!==r&&"optionalCall"!==r||(i=o(((...t)=>i.call(e,...t))),e=void 0)}}([Gt,"optionalAccess",t=>t.configure,"call",t=>t(i)]);break;case jt.Execute:Yt(),function(){null!=$t&&$t();$t=void 0,Gt=void 0}(),function({graph:t,configuration:e}){try{Gt=function(t,e={},i=window){const s={...St,...e};return new Dt(t,s,new qt(e.targetIterations||100),i)}(kt.deserialize(t),e,self),$t=Gt.on("tick",(t=>{Zt(jt.Progress,t)})),Gt.execute().then((t=>{$t&&$t(),Gt=void 0,$t=void 0,Zt(jt.Complete,t)}))}catch(t){self.console.log("caught error",t),self.postMessage(jt.Error,t)}}(i);break;case jt.Halt:null!=Gt?Gt.halt():self.console.log("could not halt executor, instance not defined");break;case jt.Reset:Yt(),Gt=void 0,$t=void 0;break;case jt.Resume:null!=Gt?Gt.isHalted||Gt.isComplete?self.console.log("executor is not in a resumable state"):Gt.execute():self.console.log("could not resume executor, instance not defined");break;default:self.console.log("fa2 worker - unhandled message type",e)}}}();
